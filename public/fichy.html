<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Fichy ‚Äî TikTok Live Fishing</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #0a0a0a;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100vh;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    }
    #game-container {
      position: relative;
      width: 100vw;
      height: min(100vh, calc(100vw * 9 / 16));
      background: #0a0a0a;
    }
    canvas { display: block; width: 100%; height: 100%; }

    /* Loading screen */
    .loading-screen {
      position: absolute; inset: 0; z-index: 100;
      background: #0a0a0a;
      display: flex; flex-direction: column; align-items: center; justify-content: center;
      gap: 16px; transition: opacity 0.5s;
    }
    .loading-screen.hidden { opacity: 0; pointer-events: none; }
    .loading-screen h1 {
      font-size: 36px; font-weight: 800;
      background: linear-gradient(135deg, #0ea5e9, #38bdf8);
      -webkit-background-clip: text; -webkit-text-fill-color: transparent;
    }
    .loading-bar { width: 200px; height: 6px; background: #222; border-radius: 3px; overflow: hidden; }
    .loading-fill { width: 0%; height: 100%; background: #0ea5e9; border-radius: 3px; transition: width 0.3s; }
    .loading-text { color: #888; font-size: 12px; }

    /* ===== HUD ===== */
    .hud { position: absolute; inset: 0; pointer-events: none; z-index: 10; }

    .hud-title {
      position: absolute; top: 12px; left: 50%; transform: translateX(-50%);
      font-size: clamp(18px, 3vw, 36px); font-weight: 800;
      background: linear-gradient(135deg, #0ea5e9, #38bdf8);
      -webkit-background-clip: text; -webkit-text-fill-color: transparent;
      letter-spacing: 3px; opacity: 0.9;
    }

    .hud-zone {
      position: absolute; top: 12px; left: 12px;
      background: rgba(0,0,0,0.6); border-radius: 20px; padding: 6px 14px;
      font-size: 13px; color: #fff; font-weight: 600;
      display: flex; align-items: center; gap: 6px;
    }
    .hud-zone .zone-dot { width: 8px; height: 8px; border-radius: 50%; }

    .hud-dex {
      position: absolute; top: 12px; right: 12px;
      background: rgba(0,0,0,0.6); border-radius: 20px; padding: 6px 14px;
      font-size: 13px; color: #fff; font-weight: 600;
    }

    .hud-leaderboard {
      position: absolute; top: 50px; right: 12px;
      background: rgba(0,0,0,0.6); border-radius: 12px; padding: 10px 14px;
      font-size: 12px; color: #fff; min-width: 180px; max-width: 220px;
    }
    .hud-leaderboard h3 {
      font-size: 11px; color: #0ea5e9; text-transform: uppercase;
      letter-spacing: 1px; margin-bottom: 6px;
    }
    .lb-row { display: flex; justify-content: space-between; padding: 2px 0; font-size: 11px; }
    .lb-row .lb-name { color: #ccc; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; max-width: 110px; }
    .lb-row .lb-score { color: #fbbf24; font-weight: 700; }

    .hud-players {
      position: absolute; bottom: 12px; left: 12px;
      background: rgba(0,0,0,0.6); border-radius: 20px; padding: 6px 14px;
      font-size: 12px; color: #888;
    }

    .hud-controls {
      position: absolute; bottom: 12px; right: 12px;
      background: rgba(0,0,0,0.6); border-radius: 12px; padding: 8px 12px;
      font-size: 10px; color: #888; line-height: 1.6;
    }
    .hud-controls span { color: #0ea5e9; font-weight: 700; }

    .notif-container {
      position: absolute; bottom: 60px; left: 50%; transform: translateX(-50%);
      display: flex; flex-direction: column-reverse; align-items: center; gap: 4px;
      max-height: 200px; overflow: hidden;
    }
    .notif {
      background: rgba(0,0,0,0.7); border-radius: 20px; padding: 6px 16px;
      font-size: 12px; color: #fff; white-space: nowrap;
      animation: notifIn 0.3s ease-out, notifOut 0.5s ease-in 3.5s forwards;
    }
    @keyframes notifIn { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
    @keyframes notifOut { to { opacity: 0; transform: translateY(-10px); } }

    .notif .rarity-common { color: #9ca3af; }
    .notif .rarity-uncommon { color: #22c55e; }
    .notif .rarity-rare { color: #3b82f6; }
    .notif .rarity-epic { color: #a855f7; }
    .notif .rarity-legendary { color: #f59e0b; }
    .notif .rarity-mythical { color: #ef4444; }

    .mega-alert {
      position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
      font-size: clamp(24px, 4vw, 48px); font-weight: 800; color: #ef4444;
      text-shadow: 0 0 30px rgba(239,68,68,0.8), 0 0 60px rgba(239,68,68,0.4);
      animation: megaPulse 0.5s ease-in-out infinite alternate;
      display: none; text-align: center; line-height: 1.3;
    }
    @keyframes megaPulse { from { transform: translate(-50%,-50%) scale(1); } to { transform: translate(-50%,-50%) scale(1.05); } }

    .hud-zone-buttons {
      position: absolute; top: 50px; left: 12px;
      display: flex; flex-direction: column; gap: 4px;
    }
    .zone-btn {
      pointer-events: auto; cursor: pointer;
      background: rgba(0,0,0,0.5); border: 1px solid #333;
      border-radius: 8px; padding: 4px 10px;
      font-size: 10px; color: #aaa; font-weight: 600;
    }
    .zone-btn:hover { border-color: #0ea5e9; color: #fff; }
    .zone-btn.active { border-color: #0ea5e9; color: #0ea5e9; }
  </style>
</head>
<body>
  <div id="game-container">
    <canvas id="canvas"></canvas>

    <!-- Loading screen -->
    <div class="loading-screen" id="loadingScreen">
      <h1>FICHY</h1>
      <div class="loading-bar"><div class="loading-fill" id="progressFill"></div></div>
      <div class="loading-text" id="loadingText">Loading assets...</div>
    </div>

    <div class="hud" id="hud" style="display:none">
      <div class="hud-title">FICHY</div>
      <div class="hud-zone" id="hudZone"><div class="zone-dot" style="background:#22c55e"></div><span>Beach</span></div>
      <div class="hud-dex" id="hudDex">Dex: 0/30</div>
      <div class="hud-leaderboard" id="hudLB">
        <h3>Leaderboard</h3>
        <div id="lbRows"></div>
      </div>
      <div class="hud-players" id="hudPlayers">0 anglers</div>
      <div class="hud-controls">
        <span>Like</span> = Cast | <span>Chat</span> = Zone<br>
        <span>Gift</span> = Boost | <span>Follow</span> = Rod+
      </div>
      <div class="notif-container" id="notifContainer"></div>
      <div class="mega-alert" id="megaAlert">MEGALODON<br>SPOTTED!</div>
      <div class="hud-zone-buttons" id="zoneButtons">
        <button class="zone-btn active" data-zone="beach">Beach</button>
        <button class="zone-btn" data-zone="lava">Lava</button>
        <button class="zone-btn" data-zone="temple">Temple</button>
        <button class="zone-btn" data-zone="lost_isle">Lost Isle</button>
      </div>
    </div>
  </div>

  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.162.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.162.0/examples/jsm/"
    }
  }
  </script>
  <script src="/socket.io/socket.io.js"></script>
  <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import * as SkeletonUtils from 'three/addons/utils/SkeletonUtils.js';

    // ============================================================
    //  FICHY ‚Äî TikTok Live Fishing Game (Landscape 16:9)
    //  Mannequin model + UAL animations
    // ============================================================

    const CHAR_SCALE = 0.55;
    const CHAR_COLORS = [0xff6b6b, 0x4ecdc4, 0xffe66d, 0xa8e6cf, 0xdda0dd, 0x87ceeb, 0xffa07a, 0x98d8c8, 0xf0e68c, 0xadd8e6];
    const MAX_PLAYERS = 20;

    // ===== FISH DATA ‚Äî 30 species across 4 zones =====
    const RARITY = {
      common:    { label: 'Common',    color: '#9ca3af', odds: 1/2,    gold: 5,    css: 'rarity-common' },
      uncommon:  { label: 'Uncommon',  color: '#22c55e', odds: 1/5,    gold: 15,   css: 'rarity-uncommon' },
      rare:      { label: 'Rare',      color: '#3b82f6', odds: 1/20,   gold: 50,   css: 'rarity-rare' },
      epic:      { label: 'Epic',      color: '#a855f7', odds: 1/100,  gold: 200,  css: 'rarity-epic' },
      legendary: { label: 'Legendary', color: '#f59e0b', odds: 1/500,  gold: 1000, css: 'rarity-legendary' },
      mythical:  { label: 'Mythical',  color: '#ef4444', odds: 1/3000, gold: 5000, css: 'rarity-mythical' },
    };

    const FISH = [
      // Beach (8)
      { name: 'Sardine',        zone: 'beach', rarity: 'common',    emoji: 'üêü' },
      { name: 'Clownfish',      zone: 'beach', rarity: 'common',    emoji: 'üê†' },
      { name: 'Pufferfish',     zone: 'beach', rarity: 'uncommon',  emoji: 'üê°' },
      { name: 'Sea Bass',       zone: 'beach', rarity: 'uncommon',  emoji: 'üêü' },
      { name: 'Swordfish',      zone: 'beach', rarity: 'rare',      emoji: 'üó°Ô∏è' },
      { name: 'Blue Marlin',    zone: 'beach', rarity: 'rare',      emoji: 'üêü' },
      { name: 'Golden Koi',     zone: 'beach', rarity: 'epic',      emoji: '‚ú®' },
      { name: 'Sea Dragon',     zone: 'beach', rarity: 'legendary', emoji: 'üêâ' },
      // Lava (8)
      { name: 'Magma Guppy',    zone: 'lava', rarity: 'common',    emoji: 'üî•' },
      { name: 'Ember Eel',      zone: 'lava', rarity: 'common',    emoji: 'üêç' },
      { name: 'Lava Catfish',   zone: 'lava', rarity: 'uncommon',  emoji: 'üåã' },
      { name: 'Flame Snapper',  zone: 'lava', rarity: 'uncommon',  emoji: 'üî•' },
      { name: 'Obsidian Pike',  zone: 'lava', rarity: 'rare',      emoji: '‚¨õ' },
      { name: 'Inferno Ray',    zone: 'lava', rarity: 'rare',      emoji: '‚òÄÔ∏è' },
      { name: 'Phoenix Fish',   zone: 'lava', rarity: 'epic',      emoji: 'ü¶Ö' },
      { name: 'Volcanic Titan', zone: 'lava', rarity: 'legendary', emoji: 'üåã' },
      // Temple (7)
      { name: 'Spirit Minnow',  zone: 'temple', rarity: 'common',    emoji: 'üëª' },
      { name: 'Temple Guardian', zone: 'temple', rarity: 'uncommon',  emoji: 'üóø' },
      { name: 'Jade Carp',      zone: 'temple', rarity: 'uncommon',  emoji: 'üíé' },
      { name: 'Sacred Koi',     zone: 'temple', rarity: 'rare',      emoji: 'üèÆ' },
      { name: 'Ancient Serpent', zone: 'temple', rarity: 'epic',      emoji: 'üê≤' },
      { name: 'Void Leviathan', zone: 'temple', rarity: 'legendary', emoji: 'üï≥Ô∏è' },
      { name: 'Transcended One',zone: 'temple', rarity: 'mythical',  emoji: 'üëÅÔ∏è' },
      // Lost Isle (7)
      { name: 'Abyssal Minnow',   zone: 'lost_isle', rarity: 'uncommon',  emoji: 'üåä' },
      { name: 'Crystal Jellyfish', zone: 'lost_isle', rarity: 'rare',      emoji: 'ü™º' },
      { name: 'Deep Sea Angler',   zone: 'lost_isle', rarity: 'rare',      emoji: 'üêô' },
      { name: 'Shadow Barracuda',  zone: 'lost_isle', rarity: 'epic',      emoji: 'ü¶à' },
      { name: 'Atlantean Whale',   zone: 'lost_isle', rarity: 'legendary', emoji: 'üêã' },
      { name: 'Water Snake',       zone: 'lost_isle', rarity: 'legendary', emoji: 'üêç' },
      { name: 'Megalodon',         zone: 'lost_isle', rarity: 'mythical',  emoji: 'ü¶à' },
    ];

    const ZONES = {
      beach:     { label: 'Beach',     dot: '#22c55e', water: 0x0077be, sky: 0x87ceeb, skyTop: 0x0077be, fog: 0x87ceeb, sunColor: 0xffdd44, ambient: 0xffffff, ambientI: 0.6, dirI: 1.0 },
      lava:      { label: 'Lava',      dot: '#ef4444', water: 0xcc3300, sky: 0x331100, skyTop: 0x110000, fog: 0x331100, sunColor: 0xff4400, ambient: 0xff6633, ambientI: 0.4, dirI: 0.8 },
      temple:    { label: 'Temple',    dot: '#a855f7', water: 0x1a0033, sky: 0x1a0044, skyTop: 0x0d0022, fog: 0x1a0044, sunColor: 0xcc88ff, ambient: 0x9966cc, ambientI: 0.3, dirI: 0.6 },
      lost_isle: { label: 'Lost Isle', dot: '#0ea5e9', water: 0x001133, sky: 0x001122, skyTop: 0x000011, fog: 0x001122, sunColor: 0x2288ff, ambient: 0x4488cc, ambientI: 0.25, dirI: 0.5 },
    };

    const RODS = [
      { name: 'Starter Rod', luck: 0,    color: 0x8b6914 },
      { name: 'Grass Rod',   luck: 0.1,  color: 0x22c55e },
      { name: 'Lava Rod',    luck: 0.2,  color: 0xef4444 },
      { name: 'Chrome Rod',  luck: 0.35, color: 0xc0c0c0 },
      { name: 'Grand Rod',   luck: 0.5,  color: 0xfbbf24 },
      { name: 'Mythic Rod',  luck: 0.75, color: 0xa855f7 },
    ];

    // ===== THREE.JS SCENE =====
    const container = document.getElementById('game-container');
    const canvas = document.getElementById('canvas');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setClearColor(0x87ceeb);
    renderer.shadowMap.enabled = true;

    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x87ceeb, 0.006);

    const camera = new THREE.PerspectiveCamera(55, container.clientWidth / container.clientHeight, 0.1, 500);
    camera.position.set(0, 10, 28);
    camera.lookAt(0, 1, 0);

    // Sky
    const skyGeo = new THREE.SphereGeometry(200, 32, 16);
    const skyMat = new THREE.ShaderMaterial({
      side: THREE.BackSide,
      uniforms: {
        topColor: { value: new THREE.Color(0x0077be) },
        bottomColor: { value: new THREE.Color(0x87ceeb) },
      },
      vertexShader: `
        varying vec3 vWorldPosition;
        void main() {
          vec4 worldPos = modelMatrix * vec4(position, 1.0);
          vWorldPosition = worldPos.xyz;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }`,
      fragmentShader: `
        uniform vec3 topColor; uniform vec3 bottomColor;
        varying vec3 vWorldPosition;
        void main() {
          float h = normalize(vWorldPosition).y;
          gl_FragColor = vec4(mix(bottomColor, topColor, max(h, 0.0)), 1.0);
        }`,
    });
    scene.add(new THREE.Mesh(skyGeo, skyMat));

    // Sun
    const sunGeo = new THREE.SphereGeometry(4, 16, 16);
    const sunMat = new THREE.MeshBasicMaterial({ color: 0xffdd44 });
    const sun = new THREE.Mesh(sunGeo, sunMat);
    sun.position.set(60, 40, -100);
    scene.add(sun);

    // Lights
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);
    const dirLight = new THREE.DirectionalLight(0xffeecc, 1.0);
    dirLight.position.set(60, 40, -100);
    dirLight.castShadow = true;
    dirLight.shadow.mapSize.set(1024, 1024);
    dirLight.shadow.camera.near = 1; dirLight.shadow.camera.far = 200;
    dirLight.shadow.camera.left = -30; dirLight.shadow.camera.right = 30;
    dirLight.shadow.camera.top = 30; dirLight.shadow.camera.bottom = -30;
    scene.add(dirLight);

    // Water
    const waterGeo = new THREE.PlaneGeometry(400, 400, 80, 80);
    const waterMat = new THREE.MeshPhongMaterial({
      color: 0x0077be, transparent: true, opacity: 0.8,
      shininess: 100, specular: 0x88ccff, flatShading: true,
    });
    const water = new THREE.Mesh(waterGeo, waterMat);
    water.rotation.x = -Math.PI / 2;
    water.receiveShadow = true;
    scene.add(water);

    // Dock
    const dockMat = new THREE.MeshLambertMaterial({ color: 0x8b6914 });
    const dockPlanks = new THREE.Mesh(new THREE.BoxGeometry(32, 0.3, 6), dockMat);
    dockPlanks.position.set(0, 1.5, 18);
    dockPlanks.receiveShadow = true; dockPlanks.castShadow = true;
    scene.add(dockPlanks);
    for (let x = -14; x <= 14; x += 4) {
      const leg = new THREE.Mesh(new THREE.BoxGeometry(0.5, 3, 0.5), dockMat);
      leg.position.set(x, 0, 18); leg.castShadow = true;
      scene.add(leg);
    }
    // Railing
    const railMat = new THREE.MeshLambertMaterial({ color: 0x6b4f12 });
    const rail = new THREE.Mesh(new THREE.BoxGeometry(32, 0.2, 0.2), railMat);
    rail.position.set(0, 2.8, 20.8);
    scene.add(rail);
    // Posts
    for (let x = -14; x <= 14; x += 7) {
      const post = new THREE.Mesh(new THREE.BoxGeometry(0.2, 1.3, 0.2), railMat);
      post.position.set(x, 2.15, 20.8);
      scene.add(post);
    }

    // Wave base positions
    const posAttr = waterGeo.attributes.position;
    const baseZ = new Float32Array(posAttr.count);
    for (let i = 0; i < posAttr.count; i++) baseZ[i] = posAttr.getZ(i);

    // ===== ASSET LOADING =====
    const loader = new GLTFLoader();
    let mannequinTemplate = null;
    const ualClips = {};
    let assetsLoaded = false;

    // UAL bone names work directly on Mannequin (same skeleton)
    function parseUALClip(clip) {
      const tracks = [];
      for (const track of clip.tracks) {
        const dotIdx = track.name.indexOf('.');
        const boneName = track.name.substring(0, dotIdx);
        const property = track.name.substring(dotIdx + 1);
        if (property === 'quaternion') {
          tracks.push({ boneName, interpolant: track.createInterpolant(), type: 'quaternion' });
        } else if (property === 'position' && boneName === 'pelvis') {
          const interp = track.createInterpolant();
          tracks.push({ boneName, interpolant: interp, type: 'position' });
        }
      }
      return { name: clip.name, duration: clip.duration, tracks };
    }

    async function loadAssets() {
      const totalAssets = 4; // Mannequin + UAL1 + UAL2 + Rigs
      let loaded = 0;
      function progress(text) {
        loaded++;
        document.getElementById('progressFill').style.width = Math.round((loaded / totalAssets) * 100) + '%';
        document.getElementById('loadingText').textContent = text;
      }

      // 1. Mannequin model
      try {
        const gltf = await loader.loadAsync('/characters/Mannequin_F.glb');
        gltf.scene.traverse(c => { if (c.isMesh) { c.castShadow = true; c.receiveShadow = true; } });
        mannequinTemplate = gltf.scene;
        progress('Mannequin loaded');
      } catch (e) { console.error('Mannequin load failed:', e); progress('Mannequin failed'); }

      // 2. UAL1 animations
      try {
        const ual = await loader.loadAsync('/characters/UAL1_Standard.glb');
        ual.animations.forEach(clip => {
          const parsed = parseUALClip(clip);
          if (parsed.tracks.length > 0) ualClips['UAL_' + clip.name] = parsed;
        });
        progress(`UAL1 (${Object.keys(ualClips).length} clips)`);
      } catch (e) { console.warn('UAL1 failed:', e); progress('UAL1 failed'); }

      // 3. UAL2 animations (dance, punch, etc.)
      try {
        const ual2 = await loader.loadAsync('/characters/UAL2_Standard.glb');
        let count = 0;
        ual2.animations.forEach(clip => {
          const parsed = parseUALClip(clip);
          if (parsed.tracks.length > 0) { ualClips['UAL_' + clip.name] = parsed; count++; }
        });
        progress(`UAL2 (+${count} clips)`);
      } catch (e) { console.warn('UAL2 failed:', e); progress('UAL2 failed'); }

      // 4. KayKit rigs (extra animations)
      try {
        const g = await loader.loadAsync('/characters/Rig_Medium_General.glb');
        // These use KayKit bone names ‚Äî skip for mannequin, but count as loaded
        progress('Rigs loaded');
      } catch (e) { progress('Rigs skipped'); }

      assetsLoaded = true;
      console.log(`Fichy ready: mannequin=${!!mannequinTemplate}, UAL clips=${Object.keys(ualClips).length}`);
      console.log('Available UAL:', Object.keys(ualClips).slice(0, 20));

      document.getElementById('loadingScreen').classList.add('hidden');
      document.getElementById('hud').style.display = '';
    }

    // ===== GAME STATE =====
    const players = new Map();
    let currentZone = 'beach';
    let globalDex = new Set();
    let megalodonActive = false;

    // ===== PLAYER =====
    function hashCode(s) { let h = 0; for (let i = 0; i < s.length; i++) h = (h * 31 + s.charCodeAt(i)) | 0; return Math.abs(h); }

    function getOrCreatePlayer(data) {
      const id = data.uniqueId || data.userId || data.nickname || ('anon_' + Math.random().toString(36).slice(2, 6));
      if (players.has(id)) return players.get(id);
      if (players.size >= MAX_PLAYERS) return null; // cap

      const player = {
        id, nickname: data.nickname || id,
        gold: 0, rodTier: 0, luck: 0,
        dex: new Set(), totalCatches: 0,
        casting: false, castTimer: null,
        // 3D
        model: null, boneMap: {}, rodMesh: null,
        bobber: null, line: null, label: null,
        position: { x: 0, z: 0 },
        // UAL
        ualPlayback: null,
        hipsBone: null,
      };

      spawnPlayerModel(player);
      players.set(id, player);
      updateHUD();
      return player;
    }

    function spawnPlayerModel(player) {
      const idx = players.size;
      const spread = 28;
      const x = -spread / 2 + (idx % 10) * (spread / 9);
      const z = 16 + Math.floor(idx / 10) * 2.5;
      player.position = { x, z };

      // Clone mannequin or fallback to capsule
      if (mannequinTemplate) {
        const model = SkeletonUtils.clone(mannequinTemplate);
        model.scale.setScalar(CHAR_SCALE);

        // Tint with player color
        const color = CHAR_COLORS[hashCode(player.id) % CHAR_COLORS.length];
        model.traverse(child => {
          if (child.isMesh && child.material) {
            child.material = child.material.clone();
            child.material.color.lerp(new THREE.Color(color), 0.25);
          }
          if (child.isBone) {
            player.boneMap[child.name] = child;
            if (child.name === 'pelvis') player.hipsBone = child;
          }
        });

        model.position.set(x, 1.65, z);
        model.rotation.y = Math.PI; // Face water
        scene.add(model);
        player.model = model;

        // Start with idle
        const idleClip = ualClips['UAL_Idle_Loop'];
        if (idleClip) {
          player.ualPlayback = { clip: idleClip, time: Math.random() * idleClip.duration, loop: true };
        }
      } else {
        // Fallback capsule
        const bodyGeo = new THREE.CapsuleGeometry(0.3, 0.8, 4, 8);
        const bodyMat = new THREE.MeshLambertMaterial({ color: new THREE.Color().setHSL(Math.random(), 0.7, 0.5) });
        const body = new THREE.Mesh(bodyGeo, bodyMat);
        body.position.set(x, 2.4, z);
        body.castShadow = true;
        scene.add(body);
        player.model = body;
      }

      // Rod mesh (attached near hand)
      const rodColor = RODS[player.rodTier].color;
      const rodGeo = new THREE.CylinderGeometry(0.02, 0.04, 2.5, 6);
      const rodMesh = new THREE.Mesh(rodGeo, new THREE.MeshLambertMaterial({ color: rodColor }));
      rodMesh.rotation.x = -Math.PI / 3.5;
      rodMesh.position.set(x + 0.4, 2.6, z - 0.8);
      rodMesh.castShadow = true;
      scene.add(rodMesh);
      player.rodMesh = rodMesh;

      // Name label sprite
      const nc = document.createElement('canvas');
      nc.width = 256; nc.height = 64;
      const ctx = nc.getContext('2d');
      ctx.fillStyle = 'rgba(0,0,0,0.6)';
      ctx.roundRect(0, 0, 256, 64, 12);
      ctx.fill();
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 26px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText(player.nickname.slice(0, 12), 128, 42);
      const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(nc), transparent: true, depthTest: false }));
      sprite.scale.set(2.5, 0.625, 1);
      sprite.position.set(x, 3.8, z);
      sprite.renderOrder = 999;
      scene.add(sprite);
      player.label = sprite;
    }

    // ===== UAL PLAYBACK =====
    function playUAL(player, clipName, loop) {
      const clip = ualClips[clipName];
      if (!clip) return;
      player.ualPlayback = { clip, time: 0, loop: loop !== undefined ? loop : clipName.includes('Loop') };
    }

    function playIdle(player) {
      const clip = ualClips['UAL_Idle_Loop'];
      if (clip) player.ualPlayback = { clip, time: Math.random() * clip.duration, loop: true };
    }

    function applyUALFrame(player, time) {
      if (!player.ualPlayback) return;
      for (const t of player.ualPlayback.clip.tracks) {
        const bone = player.boneMap[t.boneName];
        if (!bone) continue;
        const result = t.interpolant.evaluate(time);
        if (t.type === 'quaternion') {
          bone.quaternion.set(result[0], result[1], result[2], result[3]);
        } else if (t.type === 'position') {
          bone.position.set(result[0], result[1], result[2]);
        }
      }
    }

    // ===== FISHING =====
    function castLine(player) {
      if (!player || player.casting) return;
      player.casting = true;

      // Play cast animation (Spell_Simple_Shoot looks like a cast motion)
      const castClip = ualClips['UAL_Spell_Simple_Shoot'] || ualClips['UAL_Punch_Jab'];
      if (castClip) playUAL(player, castClip === ualClips['UAL_Spell_Simple_Shoot'] ? 'UAL_Spell_Simple_Shoot' : 'UAL_Punch_Jab', false);

      // Bobber
      const bobGeo = new THREE.SphereGeometry(0.15, 8, 8);
      const bobMat = new THREE.MeshBasicMaterial({ color: 0xff4444 });
      const bobber = new THREE.Mesh(bobGeo, bobMat);
      const targetX = player.position.x + (Math.random() - 0.5) * 8;
      const targetZ = player.position.z - 6 - Math.random() * 10;
      bobber.position.set(targetX, 0.3, targetZ);
      scene.add(bobber);
      player.bobber = bobber;

      // Line
      const lineGeo = new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(player.position.x + 0.4, 2.8, player.position.z - 0.8),
        bobber.position,
      ]);
      const line = new THREE.Line(lineGeo, new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.5 }));
      scene.add(line);
      player.line = line;

      // Return to idle after cast anim
      if (castClip) {
        setTimeout(() => {
          if (player.ualPlayback && !player.ualPlayback.loop) playIdle(player);
        }, (castClip.duration || 0.8) * 1000);
      }

      // Catch delay
      const delay = 2000 + Math.random() * 2500;
      player.castTimer = setTimeout(() => catchFish(player), delay);
    }

    function catchFish(player) {
      const zoneFish = FISH.filter(f => f.zone === currentZone);
      const fish = rollFish(zoneFish, player);

      if (fish) {
        const rarity = RARITY[fish.rarity];
        const weight = (0.5 + Math.random() * 10).toFixed(1);
        const gold = rarity.gold + Math.floor(Math.random() * rarity.gold * 0.5);

        player.gold += gold;
        player.totalCatches++;
        player.dex.add(fish.name);
        globalDex.add(fish.name);

        upgradeRod(player);
        showNotif(`${fish.emoji} <b>${player.nickname}</b> caught <span class="${rarity.css}">${fish.name}</span> (${weight}kg) +${gold}g`);
        if (player.bobber) splashEffect(player.bobber.position.clone());

        // Celebrate rare catches
        if (['epic', 'legendary', 'mythical'].includes(fish.rarity)) {
          const danceClip = ualClips['UAL_Dance_Loop'];
          if (danceClip) {
            playUAL(player, 'UAL_Dance_Loop', true);
            setTimeout(() => playIdle(player), 2500);
          }
        }
        if (fish.name === 'Megalodon') {
          showNotif(`ü¶àü¶àü¶à <b>${player.nickname}</b> caught the <span class="rarity-mythical">MEGALODON</span>!! ü¶àü¶àü¶à`);
        }
      }

      // Cleanup
      if (player.bobber) { scene.remove(player.bobber); player.bobber = null; }
      if (player.line) { scene.remove(player.line); player.line = null; }
      player.casting = false;
      updateHUD();
    }

    function rollFish(zoneFish, player) {
      const totalLuck = RODS[player.rodTier].luck + player.luck;
      const rarityOrder = ['mythical', 'legendary', 'epic', 'rare', 'uncommon', 'common'];
      for (const rarity of rarityOrder) {
        const candidates = zoneFish.filter(f => f.rarity === rarity);
        if (!candidates.length) continue;
        const boosted = Math.min(RARITY[rarity].odds * (1 + totalLuck), 0.95);
        if (Math.random() < boosted) return candidates[Math.floor(Math.random() * candidates.length)];
      }
      const commons = zoneFish.filter(f => f.rarity === 'common');
      return commons.length ? commons[Math.floor(Math.random() * commons.length)] : zoneFish[0];
    }

    function upgradeRod(player) {
      const thresholds = [0, 50, 200, 800, 3000, 10000];
      for (let i = thresholds.length - 1; i >= 0; i--) {
        if (player.gold >= thresholds[i] && player.rodTier < i) {
          player.rodTier = i;
          if (player.rodMesh) player.rodMesh.material.color.setHex(RODS[i].color);
          showNotif(`üé£ <b>${player.nickname}</b> upgraded to <b style="color:#${RODS[i].color.toString(16).padStart(6,'0')}">${RODS[i].name}</b>!`);
          break;
        }
      }
    }

    // ===== GIFTS =====
    function applyGift(player, diamondCount) {
      if (!player) return;
      if (diamondCount >= 500) {
        player.luck += 5;
        showNotif(`üåü <b>${player.nickname}</b> activated <span class="rarity-legendary">LEGENDARY LURE</span>!`);
        triggerMegalodon();
        setTimeout(() => { player.luck = Math.max(0, player.luck - 5); }, 30000);
      } else if (diamondCount >= 100) {
        player.luck += 0.5;
        showNotif(`üíé <b>${player.nickname}</b> used <span class="rarity-epic">Enchant Stone</span> (+50% luck)`);
        setTimeout(() => { player.luck = Math.max(0, player.luck - 0.5); }, 60000);
      } else if (diamondCount >= 10) {
        showNotif(`ü™ù <b>${player.nickname}</b> got <span class="rarity-rare">Golden Hook</span> x3!`);
        for (let i = 0; i < 3; i++) setTimeout(() => castLine(player), i * 600);
      } else {
        player.luck += 0.2;
        showNotif(`ü™± <b>${player.nickname}</b> used <span class="rarity-uncommon">Lucky Bait</span> (+20% luck)`);
        setTimeout(() => { player.luck = Math.max(0, player.luck - 0.2); }, 30000);
      }
    }

    // ===== MEGALODON =====
    function triggerMegalodon() {
      if (megalodonActive) return;
      megalodonActive = true;
      document.getElementById('megaAlert').style.display = 'block';
      const prevZone = currentZone;
      switchZone('lost_isle');
      showNotif('ü¶à <b>MEGALODON SPOTTED!</b> Everyone cast now! 30 seconds!');
      players.forEach(p => { if (!p.casting) castLine(p); });
      setTimeout(() => {
        megalodonActive = false;
        document.getElementById('megaAlert').style.display = 'none';
        switchZone(prevZone);
        showNotif('ü¶à The Megalodon retreated to the depths...');
      }, 30000);
    }

    // ===== ZONES =====
    function switchZone(zoneName) {
      if (!ZONES[zoneName]) return;
      currentZone = zoneName;
      const z = ZONES[zoneName];
      waterMat.color.setHex(z.water);
      skyMat.uniforms.topColor.value.setHex(z.skyTop);
      skyMat.uniforms.bottomColor.value.setHex(z.sky);
      scene.fog.color.setHex(z.fog);
      renderer.setClearColor(z.sky);
      sunMat.color.setHex(z.sunColor);
      ambientLight.color.setHex(z.ambient);
      ambientLight.intensity = z.ambientI;
      dirLight.intensity = z.dirI;
      document.getElementById('hudZone').innerHTML = `<div class="zone-dot" style="background:${z.dot}"></div><span>${z.label}</span>`;
      document.querySelectorAll('.zone-btn').forEach(btn => btn.classList.toggle('active', btn.dataset.zone === zoneName));
    }

    // ===== SPLASH =====
    const splashParticles = [];
    function splashEffect(pos) {
      for (let i = 0; i < 10; i++) {
        const mat = new THREE.MeshBasicMaterial({ color: 0x88ccff, transparent: true, opacity: 0.9 });
        const p = new THREE.Mesh(new THREE.SphereGeometry(0.08, 4, 4), mat);
        p.position.copy(pos);
        scene.add(p);
        splashParticles.push({ mesh: p, vel: new THREE.Vector3((Math.random()-0.5)*0.4, 0.3+Math.random()*0.4, (Math.random()-0.5)*0.4), life: 1.0 });
      }
    }

    // ===== HUD =====
    function updateHUD() {
      document.getElementById('hudDex').textContent = `Dex: ${globalDex.size}/30`;
      document.getElementById('hudPlayers').textContent = `${players.size} angler${players.size !== 1 ? 's' : ''}`;
      const sorted = Array.from(players.values()).sort((a, b) => b.gold - a.gold).slice(0, 8);
      document.getElementById('lbRows').innerHTML = sorted.map((p, i) => {
        const medal = i === 0 ? 'ü•á' : i === 1 ? 'ü•à' : i === 2 ? 'ü•â' : `${i+1}.`;
        return `<div class="lb-row"><span class="lb-name">${medal} ${p.nickname}</span><span class="lb-score">${p.gold}g</span></div>`;
      }).join('');
    }

    function showNotif(html) {
      const cont = document.getElementById('notifContainer');
      const el = document.createElement('div');
      el.className = 'notif';
      el.innerHTML = html;
      cont.appendChild(el);
      setTimeout(() => el.remove(), 4000);
      while (cont.children.length > 6) cont.removeChild(cont.firstChild);
    }

    // ===== RESIZE =====
    function onResize() {
      const w = container.clientWidth, h = container.clientHeight;
      renderer.setSize(w, h);
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
    }
    window.addEventListener('resize', onResize);
    onResize();

    // ===== RENDER LOOP =====
    const clock = new THREE.Clock();

    function animate() {
      requestAnimationFrame(animate);
      const dt = clock.getDelta();
      const t = clock.getElapsedTime();

      // Waves
      const waveH = currentZone === 'lava' ? 0.3 : 0.5;
      for (let i = 0; i < posAttr.count; i++) {
        const x = posAttr.getX(i), y = posAttr.getY(i);
        posAttr.setZ(i, baseZ[i] + Math.sin(x * 0.05 + t * 0.8) * waveH + Math.cos(y * 0.04 + t * 0.6) * waveH * 0.6);
      }
      posAttr.needsUpdate = true;
      waterGeo.computeVertexNormals();

      // Player updates
      players.forEach(p => {
        // UAL bone playback
        if (p.ualPlayback) {
          p.ualPlayback.time += dt;
          if (p.ualPlayback.time >= p.ualPlayback.clip.duration) {
            if (p.ualPlayback.loop) p.ualPlayback.time %= p.ualPlayback.clip.duration;
            else { playIdle(p); return; }
          }
          applyUALFrame(p, p.ualPlayback.time);
        }

        // Bobber bob
        if (p.bobber) {
          p.bobber.position.y = 0.3 + Math.sin(t * 3 + p.position.x) * 0.15;
          if (p.line) {
            const pts = p.line.geometry.attributes.position;
            pts.setXYZ(1, p.bobber.position.x, p.bobber.position.y, p.bobber.position.z);
            pts.needsUpdate = true;
          }
        }
      });

      // Splash particles
      for (let i = splashParticles.length - 1; i >= 0; i--) {
        const sp = splashParticles[i];
        sp.mesh.position.add(sp.vel.clone().multiplyScalar(dt * 4));
        sp.vel.y -= dt * 2;
        sp.life -= dt * 1.5;
        sp.mesh.material.opacity = Math.max(0, sp.life);
        if (sp.life <= 0) { scene.remove(sp.mesh); splashParticles.splice(i, 1); }
      }

      renderer.render(scene, camera);
    }

    // ===== SOCKET.IO =====
    const params = new URLSearchParams(window.location.search);
    const room = params.get('room') || '';
    const socket = io({ query: { room } });

    socket.on('connect', () => console.log('Fichy connected, room:', room || 'default'));

    socket.on('like', (data) => {
      const p = getOrCreatePlayer(data);
      if (p && !p.casting) castLine(p);
    });

    socket.on('chat', (data) => {
      getOrCreatePlayer(data);
      const msg = (data.comment || '').toLowerCase().trim();
      if (msg === 'beach' || msg === 'shore') switchZone('beach');
      else if (msg === 'lava' || msg === 'fire' || msg === 'volcano') switchZone('lava');
      else if (msg === 'temple' || msg === 'sacred') switchZone('temple');
      else if (msg === 'deep' || msg === 'abyss' || msg === 'atlantis' || msg === 'lost isle') switchZone('lost_isle');
    });

    socket.on('gift', (data) => {
      const p = getOrCreatePlayer(data);
      applyGift(p, data.diamondCount || 1);
    });

    socket.on('follow', (data) => {
      const p = getOrCreatePlayer(data);
      if (!p) return;
      if (p.rodTier < 1) {
        p.rodTier = 1;
        if (p.rodMesh) p.rodMesh.material.color.setHex(RODS[1].color);
      }
      showNotif(`‚≠ê <b>${p.nickname}</b> followed! Got <span style="color:#22c55e">Grass Rod</span> + 5 casts!`);
      for (let i = 0; i < 5; i++) setTimeout(() => { if (!p.casting) castLine(p); }, i * 800);
    });

    socket.on('share', (data) => {
      const p = getOrCreatePlayer(data);
      if (!p) return;
      showNotif(`üì¢ <b>${p.nickname}</b> shared! +3 casts!`);
      for (let i = 0; i < 3; i++) setTimeout(() => { if (!p.casting) castLine(p); }, i * 600);
    });

    socket.on('viewer-join', (data) => getOrCreatePlayer(data));

    // Zone buttons
    document.querySelectorAll('.zone-btn').forEach(btn => {
      btn.addEventListener('click', () => switchZone(btn.dataset.zone));
    });

    // ===== TEST KEYS =====
    document.addEventListener('keydown', (e) => {
      if (e.key === 't' || e.key === 'T') {
        const id = 'test_' + Math.floor(Math.random() * 999);
        const p = getOrCreatePlayer({ uniqueId: id, nickname: 'Tester' + id.slice(5) });
        if (p) castLine(p);
      }
      if (e.key === 'l' || e.key === 'L') {
        players.forEach(p => { if (!p.casting) castLine(p); });
      }
      if (e.key === 'b' || e.key === 'B') {
        const first = players.values().next().value;
        if (first) applyGift(first, 150);
      }
      if (e.key === 'm' || e.key === 'M') triggerMegalodon();
      if (e.key === 'a' || e.key === 'A') {
        const names = ['Aisyah','Haziq','MeiLing','Arjun','Nurul','Danish','Siti','Yuki'];
        for (let i = 0; i < names.length; i++) {
          getOrCreatePlayer({ uniqueId: 'auto_' + i, nickname: names[i] });
        }
        setInterval(() => players.forEach(p => { if (!p.casting) castLine(p); }), 3000);
      }
      if (e.key === '1') switchZone('beach');
      if (e.key === '2') switchZone('lava');
      if (e.key === '3') switchZone('temple');
      if (e.key === '4') switchZone('lost_isle');
    });

    // ===== INIT =====
    loadAssets().then(() => animate());

  </script>
</body>
</html>
