<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='80' font-size='80'>üîÆ</text></svg>">
  <title>Fortune Teller - AI Fortune Reader</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; display: flex; justify-content: center; align-items: center; width: 100vw; height: 100vh; }

    .game-frame {
      position: relative;
      width: min(100vw, calc(100vh * 9 / 16));
      height: 100vh;
      overflow: hidden;
      background: #000;
    }
    #gameCanvas { display: block; width: 100%; height: 100%; }

    /* Loading screen */
    #loadingScreen {
      position: absolute; inset: 0; z-index: 1000;
      background: linear-gradient(135deg, #0a0015 0%, #1a0030 50%, #2c0a3e 100%);
      display: flex; flex-direction: column; align-items: center; justify-content: center;
      color: #fff; transition: opacity 0.8s;
    }
    #loadingScreen.hidden { opacity: 0; pointer-events: none; }
    #loadingScreen h1 { font-size: 2.4em; margin-bottom: 4px; text-shadow: 0 0 30px rgba(155,89,182,0.8); color: #d4a0ff; letter-spacing: 2px; }
    #loadingScreen .subtitle { font-size: 1em; color: #f1c40f; margin-bottom: 25px; font-weight: 600; }
    .progress-bar { width: 260px; height: 5px; background: rgba(255,255,255,0.1); border-radius: 3px; overflow: hidden; }
    .progress-fill { height: 100%; background: linear-gradient(90deg, #9b59b6, #f1c40f); width: 0%; transition: width 0.3s; border-radius: 3px; }
    #loadingText { margin-top: 12px; font-size: 0.85em; color: #888; }

    /* Top bar */
    #topBar {
      position: absolute; top: 10px; left: 12px; right: 12px; z-index: 100;
      display: flex; justify-content: space-between; align-items: center;
      pointer-events: none;
    }
    .top-pill {
      background: rgba(0,0,0,0.65); backdrop-filter: blur(10px);
      border-radius: 16px; padding: 5px 14px; border: 1px solid rgba(155,89,182,0.3);
      display: flex; align-items: center; gap: 8px;
      font-size: 13px; color: #fff; font-weight: 600;
    }
    .top-pill .label { color: #888; font-weight: 400; font-size: 10px; }
    .top-pill.live { border-color: rgba(155,89,182,0.6); }
    .live-dot { width: 7px; height: 7px; background: #9b59b6; border-radius: 50%; animation: pulse 1.5s infinite; }
    @keyframes pulse { 0%,100% { opacity: 1; } 50% { opacity: 0.3; } }

    /* Fortune display */
    #fortuneDisplay {
      position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
      z-index: 120; pointer-events: none; text-align: center;
      max-width: 85%; opacity: 0; transition: opacity 0.5s;
    }
    #fortuneDisplay.show { opacity: 1; }
    #fortuneDisplay .fortune-box {
      background: rgba(10,0,20,0.85); border: 2px solid rgba(241,196,15,0.5);
      border-radius: 16px; padding: 16px 20px;
      box-shadow: 0 0 30px rgba(155,89,182,0.3), inset 0 0 20px rgba(155,89,182,0.1);
    }
    #fortuneDisplay .fortune-zodiac { font-size: 2em; margin-bottom: 4px; }
    #fortuneDisplay .fortune-name { font-size: 12px; color: #f1c40f; font-weight: 700; margin-bottom: 6px; letter-spacing: 1px; }
    #fortuneDisplay .fortune-text { font-size: 14px; color: #e0d0ff; line-height: 1.5; }

    /* Leaderboard */
    #leaderboard {
      position: absolute; top: 44px; right: 8px; z-index: 100;
      background: rgba(0,0,0,0.7); backdrop-filter: blur(10px);
      border-radius: 12px; padding: 6px 8px; border: 1px solid rgba(155,89,182,0.2);
      width: 130px; max-height: 35%; overflow-y: auto; pointer-events: none;
    }
    #leaderboard::-webkit-scrollbar { width: 0; }
    .lb-title { font-size: 9px; color: #f1c40f; font-weight: 700; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 4px; text-align: center; }
    .lb-row { display: flex; align-items: center; gap: 4px; padding: 2px 0; font-size: 11px; color: #fff; }
    .lb-rank { width: 18px; text-align: center; font-weight: 700; color: #f1c40f; }
    .lb-name { flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    .lb-score { color: #d4a0ff; font-weight: 700; }

    /* Notifications */
    #notifications {
      position: absolute; bottom: 180px; left: 8px; z-index: 100;
      display: flex; flex-direction: column; gap: 3px;
      pointer-events: none; max-width: 65%;
    }
    .notif {
      padding: 4px 10px; background: rgba(0,0,0,0.7); backdrop-filter: blur(8px);
      border-radius: 10px; border: 1px solid rgba(155,89,182,0.3);
      animation: slideIn 0.3s ease-out, fadeOut 0.5s ease-in 4.5s forwards;
      font-size: 11px; color: #fff; line-height: 1.3;
    }
    .notif strong { color: #f1c40f; }
    .notif.gift { border-color: rgba(241,196,15,0.5); background: rgba(241,196,15,0.1); }
    .notif.zodiac { border-color: rgba(155,89,182,0.5); background: rgba(155,89,182,0.1); }
    .notif.follow { border-color: rgba(100,200,255,0.5); background: rgba(100,200,255,0.1); }
    @keyframes slideIn { from { opacity: 0; transform: translateX(-20px); } to { opacity: 1; transform: translateX(0); } }
    @keyframes fadeOut { to { opacity: 0; transform: translateY(-10px); } }

    /* Guide panel */
    #guidePanel {
      position: absolute; left: 8px; top: 44px;
      z-index: 100; pointer-events: none;
      display: flex; flex-direction: column; gap: 3px; width: 115px;
    }
    .guide-item {
      background: rgba(0,0,0,0.65); backdrop-filter: blur(8px);
      border-radius: 8px; padding: 4px 6px;
      border: 1px solid rgba(255,255,255,0.06);
      display: flex; align-items: center; gap: 5px;
    }
    .guide-icon { font-size: 12px; width: 16px; text-align: center; flex-shrink: 0; }
    .guide-label { font-size: 9px; color: #f1c40f; font-weight: 700; line-height: 1; }
    .guide-desc { font-size: 8px; color: #999; line-height: 1.1; }
    .guide-divider { height: 1px; background: rgba(155,89,182,0.15); margin: 1px 0; }
    .guide-gift {
      background: rgba(0,0,0,0.65); backdrop-filter: blur(8px);
      border-radius: 8px; padding: 3px 6px;
      border: 1px solid rgba(155,89,182,0.12);
      display: flex; align-items: center; gap: 5px;
    }
    .guide-gift .g-tier { font-size: 8px; color: #f1c40f; font-weight: 700; white-space: nowrap; }
    .guide-gift .g-name { font-size: 8px; color: #ccc; }

    /* Crystal energy bar */
    #crystalEnergy {
      position: absolute; bottom: 130px; left: 50%; transform: translateX(-50%);
      z-index: 100; pointer-events: none; text-align: center;
    }
    .energy-bar { width: 120px; height: 6px; background: rgba(255,255,255,0.1); border-radius: 3px; overflow: hidden; margin: 0 auto; }
    .energy-fill { height: 100%; background: linear-gradient(90deg, #9b59b6, #f1c40f); width: 0%; transition: width 0.3s; border-radius: 3px; }
    .energy-label { font-size: 9px; color: #d4a0ff; margin-top: 3px; }

    /* Zodiac badge */
    #zodiacBadge {
      position: absolute; top: 50px; left: 50%; transform: translateX(-50%);
      z-index: 100; pointer-events: none; text-align: center;
      opacity: 0; transition: opacity 0.5s;
    }
    #zodiacBadge.show { opacity: 1; }
    .zodiac-symbol { font-size: 2.5em; filter: drop-shadow(0 0 10px rgba(241,196,15,0.8)); }
    .zodiac-name { font-size: 11px; color: #f1c40f; font-weight: 700; letter-spacing: 1px; text-transform: uppercase; }

    /* Voice */
    #voiceIndicator {
      display: none; position: absolute; bottom: 12px; left: 50%; transform: translateX(-50%);
      z-index: 50; background: rgba(0,0,0,0.7); border: 1px solid #9b59b6; border-radius: 20px;
      padding: 6px 14px; font-size: 12px; color: #d4a0ff; pointer-events: none; white-space: nowrap;
    }
    #voiceSubtitle {
      display: none; position: absolute; bottom: 44px; left: 50%; transform: translateX(-50%);
      z-index: 50; background: rgba(10,0,20,0.9); border: 1px solid rgba(155,89,182,0.3);
      border-radius: 12px; padding: 8px 16px; font-size: 13px; color: #e0d0ff;
      max-width: 85%; text-align: center; pointer-events: none; line-height: 1.4;
    }

    /* Power flash */
    #powerFlash {
      position: absolute; inset: 0; z-index: 150; pointer-events: none;
      background: radial-gradient(circle, rgba(155,89,182,0.4), transparent 70%);
      opacity: 0; transition: opacity 0.15s;
    }
    #powerFlash.show { opacity: 1; }

    /* Viewer Focus ‚Äî profile photo + name during reading */
    #viewerFocus {
      position: absolute; top: 82px; left: 50%; transform: translateX(-50%);
      z-index: 110; pointer-events: none; text-align: center;
      opacity: 0; transition: opacity 0.5s; display: flex; flex-direction: column; align-items: center;
    }
    #viewerFocus.show { opacity: 1; }
    .focus-photo {
      width: 72px; height: 72px; border-radius: 50%; border: 3px solid #f1c40f;
      box-shadow: 0 0 20px rgba(241,196,15,0.5), 0 0 40px rgba(155,89,182,0.3);
      object-fit: cover; background: #2c0a3e;
    }
    .focus-photo.placeholder {
      display: flex; align-items: center; justify-content: center;
      font-size: 28px; color: #d4a0ff;
    }
    .focus-name {
      margin-top: 4px; font-size: 13px; font-weight: 700; color: #f1c40f;
      text-shadow: 0 0 10px rgba(241,196,15,0.5); letter-spacing: 0.5px;
    }
    .focus-reading-type {
      font-size: 10px; color: #d4a0ff; font-weight: 600; text-transform: uppercase; letter-spacing: 1px;
    }

    /* Dramatic Element Animations */
    .dramatic-overlay {
      position: absolute; inset: 0; z-index: 140; pointer-events: none;
      opacity: 0; transition: opacity 0.5s;
    }
    .dramatic-overlay.show { opacity: 1; }

    /* Fire ‚Äî intense rising flames with multiple layers */
    .fire-effect {
      background: radial-gradient(ellipse at bottom, rgba(255,60,0,0.5), rgba(255,30,0,0.2) 40%, transparent 75%);
    }
    .fire-effect::before, .fire-effect::after {
      content: ''; position: absolute; bottom: 0; left: 0; width: 100%; height: 70%;
      background: linear-gradient(to top,
        rgba(255,80,0,0.6) 0%, rgba(255,150,0,0.4) 20%,
        rgba(255,200,0,0.2) 40%, transparent 70%);
      animation: fireRise 0.6s ease-in-out infinite alternate;
      border-radius: 50% 50% 0 0;
    }
    .fire-effect::after {
      animation-delay: 0.3s; animation-duration: 0.8s; height: 55%;
      background: linear-gradient(to top,
        rgba(255,50,0,0.5) 0%, rgba(255,120,0,0.3) 30%, transparent 65%);
    }
    @keyframes fireRise {
      0% { opacity: 0.7; transform: scaleY(0.9) scaleX(1.05); filter: blur(2px); }
      50% { opacity: 1; transform: scaleY(1.1) scaleX(0.95); filter: blur(1px); }
      100% { opacity: 0.8; transform: scaleY(1.05) scaleX(1.02); filter: blur(3px); }
    }

    /* Water ‚Äî cascading waves with depth */
    .water-effect {
      background: radial-gradient(ellipse at center, rgba(0,80,200,0.35), rgba(0,40,150,0.15) 50%, transparent 80%);
    }
    .water-effect::before, .water-effect::after {
      content: ''; position: absolute; inset: 0;
      border-radius: 50%;
    }
    .water-effect::before {
      background:
        radial-gradient(circle at 30% 40%, rgba(100,200,255,0.3) 0%, transparent 40%),
        radial-gradient(circle at 70% 60%, rgba(0,150,255,0.25) 0%, transparent 35%);
      animation: waterPulse 2s ease-in-out infinite;
    }
    .water-effect::after {
      background:
        radial-gradient(circle at 50% 50%, rgba(0,180,255,0.2) 0%, transparent 50%),
        repeating-conic-gradient(from 0deg, transparent 0deg, rgba(100,200,255,0.1) 3deg, transparent 6deg);
      animation: waterSpin 4s linear infinite;
    }
    @keyframes waterPulse {
      0%,100% { transform: scale(0.8); opacity: 0.5; }
      50% { transform: scale(1.2); opacity: 1; }
    }
    @keyframes waterSpin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }

    /* Skull / Dark */
    .skull-effect {
      background: radial-gradient(circle, rgba(100,0,100,0.3), rgba(50,0,50,0.15) 50%, transparent 80%);
    }
    .skull-icon {
      position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
      font-size: 80px; opacity: 0; animation: skullAppear 2s ease-out forwards;
      filter: drop-shadow(0 0 20px rgba(200,0,200,0.8));
    }
    @keyframes skullAppear { 0% { opacity: 0; transform: translate(-50%,-50%) scale(0.3); } 30% { opacity: 0.7; transform: translate(-50%,-50%) scale(1.1); } 100% { opacity: 0; transform: translate(-50%,-50%) scale(1.5); } }

    /* Lightning ‚Äî dramatic multi-bolt storm */
    .lightning-effect {
      background: radial-gradient(circle at 50% 30%, rgba(150,150,255,0.15), transparent 60%);
    }
    .lightning-flash {
      position: absolute; inset: 0;
      animation: lightningBolt 0.12s ease-out;
      background: rgba(220,220,255,0.7);
    }
    @keyframes lightningBolt { 0% { opacity: 1; } 100% { opacity: 0; } }
    .lightning-bolt {
      position: absolute; top: -10%; left: 50%; transform: translateX(-50%);
      font-size: 120px; opacity: 0; animation: boltStrike 1.8s ease-out forwards;
      filter: drop-shadow(0 0 40px rgba(150,150,255,1)) drop-shadow(0 0 80px rgba(100,100,255,0.6));
      text-shadow: 0 0 30px rgba(200,200,255,0.9);
    }
    @keyframes boltStrike {
      0% { opacity: 0; transform: translateX(-50%) translateY(-30px) scale(0.5); }
      8% { opacity: 1; transform: translateX(-50%) translateY(0) scale(1.2); }
      15% { opacity: 0.3; transform: translateX(-50%) translateY(5px) scale(1); }
      25% { opacity: 1; transform: translateX(-50%) translateY(0) scale(1.1); }
      60% { opacity: 0.8; transform: translateX(-50%) translateY(10px) scale(1); }
      100% { opacity: 0; transform: translateX(-50%) translateY(30px) scale(0.8); }
    }

    /* Flood status bar */
    #floodStatus {
      position: absolute; top: 36px; left: 50%; transform: translateX(-50%);
      z-index: 100; pointer-events: none; text-align: center;
      opacity: 0; transition: opacity 0.3s;
    }
    #floodStatus.show { opacity: 1; }
    .flood-pill {
      background: rgba(255,60,60,0.8); backdrop-filter: blur(8px);
      border-radius: 10px; padding: 3px 12px;
      font-size: 10px; color: #fff; font-weight: 600;
      animation: pulse 1.5s infinite;
    }
  </style>
</head>
<body>
  <div class="game-frame">
    <canvas id="gameCanvas"></canvas>

    <!-- Loading Screen -->
    <div id="loadingScreen">
      <h1>FORTUNE TELLER</h1>
      <div class="subtitle">AI Fortune Reader</div>
      <div class="progress-bar"><div class="progress-fill" id="progressFill"></div></div>
      <div id="loadingText">Membangunkan bola kristal...</div>
    </div>

    <!-- HUD -->
    <div id="topBar">
      <div class="top-pill live">
        <div class="live-dot"></div>
        <span id="viewerCount">0</span>
        <span class="label">viewers</span>
      </div>
      <div style="font-size:14px; color:#d4a0ff; font-weight:700; text-shadow:0 0 15px rgba(155,89,182,0.5);">FORTUNE TELLER</div>
      <div class="top-pill">
        <span class="label">readings</span>
        <span id="readingCount">0</span>
      </div>
    </div>

    <!-- Leaderboard -->
    <div id="leaderboard">
      <div class="lb-title">Mystic Points</div>
      <div id="lbRows"></div>
    </div>

    <!-- Fortune Display -->
    <div id="fortuneDisplay">
      <div class="fortune-box">
        <div class="fortune-zodiac" id="fortuneZodiac"></div>
        <div class="fortune-name" id="fortuneName"></div>
        <div class="fortune-text" id="fortuneText"></div>
      </div>
    </div>

    <!-- Zodiac Badge -->
    <div id="zodiacBadge">
      <div class="zodiac-symbol" id="zodiacSymbol"></div>
      <div class="zodiac-name" id="zodiacName"></div>
    </div>

    <!-- Notifications -->
    <div id="notifications"></div>

    <!-- Guide Panel -->
    <div id="guidePanel">
      <div class="guide-item" style="border-color:rgba(241,196,15,0.4); background:rgba(241,196,15,0.1);">
        <div class="guide-icon">üéÅ</div>
        <div><div class="guide-label" style="color:#f1c40f;">GIFT = READING</div><div class="guide-desc">Kirim gift, dibacain!</div></div>
      </div>
      <div class="guide-item">
        <div class="guide-icon">üí¨</div>
        <div><div class="guide-label">ULTAH</div><div class="guide-desc">"15 maret" set zodiak</div></div>
      </div>
      <div class="guide-item">
        <div class="guide-icon">‚ù§Ô∏è</div>
        <div><div class="guide-label">LIKE</div><div class="guide-desc">Energi kristal!</div></div>
      </div>
      <div class="guide-divider"></div>
      <div class="guide-gift">
        <div class="g-tier">üéÅ 1-10</div>
        <div class="g-name">Ramalan singkat</div>
      </div>
      <div class="guide-gift">
        <div class="g-tier">üéÅ 11-99</div>
        <div class="g-name">Ramalan detail</div>
      </div>
      <div class="guide-gift">
        <div class="g-tier">üéÅ 100+</div>
        <div class="g-name">Visi Spesial</div>
      </div>
      <div class="guide-gift">
        <div class="g-tier">üéÅ 500+</div>
        <div class="g-name">VIP Prophecy!</div>
      </div>
    </div>

    <!-- Crystal Energy -->
    <div id="crystalEnergy">
      <div class="energy-bar"><div class="energy-fill" id="energyFill"></div></div>
      <div class="energy-label">Energi Kristal: <span id="energyValue">0</span>/10</div>
    </div>

    <!-- Viewer Focus -->
    <div id="viewerFocus">
      <div class="focus-photo placeholder" id="focusPhoto">üîÆ</div>
      <div class="focus-name" id="focusName"></div>
      <div class="focus-reading-type" id="focusType"></div>
    </div>

    <!-- Flood Status -->
    <div id="floodStatus">
      <div class="flood-pill" id="floodPill">Ramai! Antri reading...</div>
    </div>

    <!-- Dramatic Effects Overlay -->
    <div class="dramatic-overlay" id="dramaticOverlay"></div>

    <!-- Voice -->
    <div id="voiceIndicator">
      <span id="voiceSpeakerIcon" style="margin-right:4px;">üéôÔ∏è</span>
      <span id="voiceStatusText">Voice Ready</span>
    </div>
    <div id="voiceSubtitle"></div>

    <!-- Power Flash -->
    <div id="powerFlash"></div>
  </div>

  <!-- Debug Panel -->
  <div id="debugPanel">
    <div class="debug-title">VIEWERS</div>
    <button class="dbtn" onclick="window._debug('addViewer')">Add (T)</button>
    <button class="dbtn" onclick="window._debug('add10')">Add 10 (D)</button>
    <div class="debug-title" style="margin-top:6px;">ACTIONS</div>
    <button class="dbtn" onclick="window._debug('like')">Like (L)</button>
    <button class="dbtn" onclick="window._debug('gift')">Gift (B)</button>
    <button class="dbtn" onclick="window._debug('zodiac')">Zodiac (Z)</button>
    <button class="dbtn" onclick="window._debug('jodoh')">Jodoh (J)</button>
    <button class="dbtn" onclick="window._debug('question')">Question (Q)</button>
    <button class="dbtn" onclick="window._debug('autocam')">AutoCam (V)</button>
    <button class="dbtn" onclick="window._debug('auto')">Auto (A)</button>
    <div class="debug-title" style="margin-top:6px;">EFFECTS</div>
    <button class="dbtn" onclick="window._debug('skull')">Skull (S)</button>
    <button class="dbtn" onclick="window._debug('fire')">Fire (F)</button>
    <button class="dbtn" onclick="window._debug('water')">Water (W)</button>
    <button class="dbtn" onclick="window._debug('lightning')">Bolt (E)</button>
    <div class="debug-title" style="margin-top:6px;">VOICE</div>
    <button class="dbtn" id="voiceToggleBtn" onclick="window._toggleVoice()" style="border-left:3px solid #9b59b6;">Voice: OFF</button>
    <button class="dbtn" id="autoReplyToggleBtn" onclick="window._toggleAutoReply()" style="border-left:3px solid #27ae60;">Chat Reply: OFF</button>
  </div>
  <style>
    #debugPanel {
      position: fixed; right: 10px; top: 50%; transform: translateY(-50%);
      z-index: 9999; display: flex; flex-direction: column; gap: 4px;
      background: rgba(20,20,20,0.95); border: 1px solid #333; border-radius: 10px;
      padding: 10px; width: 100px; max-height: 80vh; overflow-y: auto;
    }
    .debug-title { font-size: 10px; color: #9b59b6; font-weight: 700; text-transform: uppercase; letter-spacing: 1px; text-align: center; margin-bottom: 2px; }
    .dbtn {
      background: #222; color: #ccc; border: 1px solid #444; border-radius: 6px;
      padding: 6px 8px; font-size: 11px; cursor: pointer; text-align: left;
      transition: background 0.15s;
    }
    .dbtn:hover { background: #333; color: #fff; border-color: #9b59b6; }
    @media (max-aspect-ratio: 10/16) { #debugPanel { display: none; } }
  </style>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/"
  }
}
</script>
<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

// ===== CONFIG =====
const MAX_ORBS = 20;
const ENERGY_THRESHOLD = 10;
const MYSTIC_VOICE_ID = 'tX4zpyB6s34no1FgD0Mm'; // Eyang ‚Äî deep, calm, mysterious Indonesian male
const CHAR_COLORS = [
  0xff6b9d, 0xc44dff, 0x6bff6b, 0xff9b4d, 0x4dc4ff,
  0xffd700, 0xff4d6b, 0x4dff9b, 0x9b4dff, 0xff4dc4,
  0x6b9bff, 0xc4ff4d, 0xff6b4d, 0x4dffc4, 0x9bff4d,
  0xff4d9b, 0x4d6bff, 0xffc44d, 0x6bffc4, 0xc46bff,
];

// ===== ZODIAC DATA =====
const ZODIAC_DATA = {
  aries:       { symbol: '\u2648', element: 'Api',   dates: 'Mac 21 - Apr 19',   emoji: '\uD83D\uDD25' },
  taurus:      { symbol: '\u2649', element: 'Tanah', dates: 'Apr 20 - Mei 20',   emoji: '\uD83C\uDF0D' },
  gemini:      { symbol: '\u264A', element: 'Angin', dates: 'Mei 21 - Jun 20',   emoji: '\uD83D\uDCA8' },
  cancer:      { symbol: '\u264B', element: 'Air',   dates: 'Jun 21 - Jul 22',   emoji: '\uD83D\uDCA7' },
  leo:         { symbol: '\u264C', element: 'Api',   dates: 'Jul 23 - Ogos 22',  emoji: '\uD83D\uDD25' },
  virgo:       { symbol: '\u264D', element: 'Tanah', dates: 'Ogos 23 - Sep 22',  emoji: '\uD83C\uDF0D' },
  libra:       { symbol: '\u264E', element: 'Angin', dates: 'Sep 23 - Okt 22',   emoji: '\uD83D\uDCA8' },
  scorpio:     { symbol: '\u264F', element: 'Air',   dates: 'Okt 23 - Nov 21',   emoji: '\uD83D\uDCA7' },
  sagittarius: { symbol: '\u2650', element: 'Api',   dates: 'Nov 22 - Dis 21',   emoji: '\uD83D\uDD25' },
  capricorn:   { symbol: '\u2651', element: 'Tanah', dates: 'Dis 22 - Jan 19',   emoji: '\uD83C\uDF0D' },
  aquarius:    { symbol: '\u2652', element: 'Angin', dates: 'Jan 20 - Feb 18',   emoji: '\uD83D\uDCA8' },
  pisces:      { symbol: '\u2653', element: 'Air',   dates: 'Feb 19 - Mac 20',   emoji: '\uD83D\uDCA7' },
};

const ZODIAC_RANGES = [
  { month: 1, day: 20, sign: 'aquarius' },
  { month: 2, day: 19, sign: 'pisces' },
  { month: 3, day: 21, sign: 'aries' },
  { month: 4, day: 20, sign: 'taurus' },
  { month: 5, day: 21, sign: 'gemini' },
  { month: 6, day: 21, sign: 'cancer' },
  { month: 7, day: 23, sign: 'leo' },
  { month: 8, day: 23, sign: 'virgo' },
  { month: 9, day: 23, sign: 'libra' },
  { month: 10, day: 23, sign: 'scorpio' },
  { month: 11, day: 22, sign: 'sagittarius' },
  { month: 12, day: 22, sign: 'capricorn' },
];

const MONTH_MAP = {
  'jan': 1, 'januari': 1, 'january': 1,
  'feb': 2, 'februari': 2, 'february': 2,
  'mac': 3, 'mar': 3, 'march': 3, 'maret': 3,
  'apr': 4, 'april': 4,
  'mei': 5, 'may': 5,
  'jun': 6, 'june': 6, 'juni': 6,
  'jul': 7, 'july': 7, 'julai': 7, 'juli': 7,
  'ogos': 8, 'aug': 8, 'august': 8, 'agustus': 8, 'agu': 8,
  'sep': 9, 'sept': 9, 'september': 9,
  'okt': 10, 'oct': 10, 'october': 10, 'oktober': 10,
  'nov': 11, 'november': 11, 'nop': 11, 'nopember': 11,
  'dis': 12, 'dec': 12, 'december': 12, 'disember': 12, 'desember': 12, 'des': 12,
};

function getZodiacFromDate(month, day) {
  for (let i = ZODIAC_RANGES.length - 1; i >= 0; i--) {
    const r = ZODIAC_RANGES[i];
    if (month > r.month || (month === r.month && day >= r.day)) return r.sign;
  }
  return 'capricorn'; // Dec 22 - Jan 19 wraps
}

function detectBirthday(msg) {
  const lower = msg.toLowerCase().trim().replace(/[,\.!]/g, '');

  // Direct zodiac name (anywhere in message)
  for (const z of Object.keys(ZODIAC_DATA)) {
    if (lower === z || lower.includes(z)) return { zodiac: z, date: '' };
  }

  let m, match;

  // "15 maret", "15 mac", "15 march", "15 maret 2000", "15maret"
  match = lower.match(/(\d{1,2})\s*([a-z]{3,})/);
  if (match) {
    const day = parseInt(match[1]);
    const monthStr = match[2];
    m = MONTH_MAP[monthStr];
    if (m && day >= 1 && day <= 31) {
      return { zodiac: getZodiacFromDate(m, day), date: `${day} ${match[2]}` };
    }
  }

  // "maret 15", "march 15"
  match = lower.match(/([a-z]{3,})\s+(\d{1,2})/);
  if (match) {
    const monthStr = match[1];
    const day = parseInt(match[2]);
    m = MONTH_MAP[monthStr];
    if (m && day >= 1 && day <= 31) {
      return { zodiac: getZodiacFromDate(m, day), date: `${day} ${match[1]}` };
    }
  }

  // dd/mm, dd-mm, dd.mm (with optional year: dd/mm/yyyy)
  match = lower.match(/(\d{1,2})[\/\-\.](\d{1,2})(?:[\/\-\.](\d{2,4}))?/);
  if (match) {
    const day = parseInt(match[1]);
    const month = parseInt(match[2]);
    if (month >= 1 && month <= 12 && day >= 1 && day <= 31) {
      return { zodiac: getZodiacFromDate(month, day), date: `${day}/${month}` };
    }
    // Maybe mm/dd format? Try swapped if first didn't work
    if (day >= 1 && day <= 12 && month >= 1 && month <= 31) {
      return { zodiac: getZodiacFromDate(day, month), date: `${month}/${day}` };
    }
  }

  // Just two numbers like "15 3" or "3 15"
  match = lower.match(/^(\d{1,2})\s+(\d{1,2})$/);
  if (match) {
    let a = parseInt(match[1]), b = parseInt(match[2]);
    // Assume dd mm
    if (b >= 1 && b <= 12 && a >= 1 && a <= 31) {
      return { zodiac: getZodiacFromDate(b, a), date: `${a}/${b}` };
    }
    // Try mm dd
    if (a >= 1 && a <= 12 && b >= 1 && b <= 31) {
      return { zodiac: getZodiacFromDate(a, b), date: `${b}/${a}` };
    }
  }

  // "lahir 15 maret" or "ultah 15/3" ‚Äî strip prefix words
  const stripped = lower.replace(/^(lahir|ultah|birthday|born|tanggal|tgl|dob)\s*/i, '');
  if (stripped !== lower) return detectBirthday(stripped);

  return null;
}

// ===== STATE =====
const viewers = new Map();
const viewerOrbs = new Map();
const readingQueue = [];
let crystalEnergy = 0;
let readingState = 'IDLE'; // IDLE, READING, REVEAL
let currentReading = null;
let fortuneDisplayTimer = null;
let readingWaitingForVoice = false;
let totalReadings = 0;
let autoPlay = false;
let autoPlayTimer = 0;
let autoCamEnabled = true;

// Rich context ‚Äî stream-level stats
const streamStartTime = Date.now();
let totalGiftsReceived = 0;
let totalVoiceCalls = 0;

// Flood control
let eventsPerMinute = 0;
let eventCounterTimer = 0;
const FLOOD_THRESHOLD = 30; // events/min before flood mode
let floodMode = false;
let readingCooldowns = new Map(); // uid ‚Üí timestamp, prevent spam per user
const PER_USER_COOLDOWN = 30000; // 30s between readings for same person

// Gift accumulation ‚Äî batch rapid small gifts into one reading
const giftAccumulators = new Map(); // uid ‚Üí { diamonds, timer, nick, pic, data }
const GIFT_ACCUMULATE_WINDOW = 8000; // 8 seconds to collect gifts before triggering

// Engagement prompts + idle chatter
let engageTimer = 30; // first prompt after 30s
let lastEngageTime = 0;
const ENGAGE_COOLDOWN = 40000; // 40s between voice prompts
let idleChatType = 0; // rotate through different idle chat types

// Free random readings ‚Äî keep viewers engaged
let freeReadingTimer = 60; // first free reading after 60s
const FREE_READING_INTERVAL = 90; // every 90s give a random viewer a free reading

// ===== PERSISTENCE STATE =====
let _savePending = false;
let _saveTimer = null;
const SAVE_INTERVAL = 120000; // 2 minutes
let _peakViewers = 0;
let _sessionSaved = false;
let autoReplyEnabled = false;
let _lastAutoReplyTime = 0;
const AUTO_REPLY_COOLDOWN = 15000; // 15s between auto-replies

// ===== THREE.JS SETUP =====
const canvas = document.getElementById('gameCanvas');
const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 0.8;
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x0a0015);
scene.fog = new THREE.FogExp2(0x1a0030, 0.025);

const camera = new THREE.PerspectiveCamera(50, 9 / 16, 0.1, 200);
camera.position.set(0, 3.5, 5);
camera.lookAt(0, 1, 0);

const controls = new OrbitControls(camera, canvas);
controls.target.set(0, 1, 0);
controls.enableDamping = true;
controls.dampingFactor = 0.05;
controls.enabled = false; // auto cam by default
let manualCamera = false;
canvas.addEventListener('pointerdown', () => { manualCamera = true; controls.enabled = true; });

// Unlock AudioContext on first user gesture (Chrome autoplay policy)
let audioUnlocked = false;
function unlockAudio() {
  if (audioUnlocked) return;
  audioUnlocked = true;
  try {
    const ctx = new (window.AudioContext || window.webkitAudioContext)();
    const buf = ctx.createBuffer(1, 1, 22050);
    const src = ctx.createBufferSource();
    src.buffer = buf; src.connect(ctx.destination); src.start();
  } catch(e) {}
}
document.addEventListener('click', unlockAudio, { once: true });
document.addEventListener('touchstart', unlockAudio, { once: true });
document.addEventListener('keydown', unlockAudio, { once: true });

function resize() {
  const frame = canvas.parentElement;
  renderer.setSize(frame.clientWidth, frame.clientHeight);
  camera.aspect = frame.clientWidth / frame.clientHeight;
  camera.updateProjectionMatrix();
}
window.addEventListener('resize', resize);
resize();

// ===== LIGHTING =====
const ambientLight = new THREE.AmbientLight(0x4422aa, 0.3);
scene.add(ambientLight);

const crystalLight = new THREE.PointLight(0x9b59b6, 2, 15);
crystalLight.position.set(0, 1.5, 0);
crystalLight.castShadow = true;
scene.add(crystalLight);

const spotLight = new THREE.SpotLight(0x6633cc, 3, 20, Math.PI / 6, 0.5);
spotLight.position.set(0, 8, 0);
spotLight.target.position.set(0, 1, 0);
scene.add(spotLight);
scene.add(spotLight.target);

// Candle lights (4)
const candlePositions = [
  new THREE.Vector3(-0.8, 0.45, -0.8),
  new THREE.Vector3(0.8, 0.45, -0.8),
  new THREE.Vector3(-0.8, 0.45, 0.8),
  new THREE.Vector3(0.8, 0.45, 0.8),
];
const candleLights = [];
candlePositions.forEach(pos => {
  const light = new THREE.PointLight(0xffaa33, 0.5, 3);
  light.position.copy(pos);
  scene.add(light);
  candleLights.push(light);
});

// ===== SCENE OBJECTS =====

// Floor
const floorGeo = new THREE.CircleGeometry(8, 32);
const floorMat = new THREE.MeshStandardMaterial({ color: 0x0a0020, metalness: 0.8, roughness: 0.2 });
const floor = new THREE.Mesh(floorGeo, floorMat);
floor.rotation.x = -Math.PI / 2;
floor.position.y = -0.5;
floor.receiveShadow = true;
scene.add(floor);

// Table
const tableGeo = new THREE.CylinderGeometry(1.8, 1.8, 0.15, 16);
const tableMat = new THREE.MeshStandardMaterial({ color: 0x1a0a2a, roughness: 0.3, metalness: 0.2 });
const table = new THREE.Mesh(tableGeo, tableMat);
table.position.y = 0.15;
table.receiveShadow = true;
scene.add(table);

// Table cloth
const clothGeo = new THREE.CylinderGeometry(2.0, 2.2, 0.6, 16, 1, true);
const clothMat = new THREE.MeshStandardMaterial({ color: 0x2c0a3e, roughness: 0.7, side: THREE.DoubleSide });
const cloth = new THREE.Mesh(clothGeo, clothMat);
cloth.position.y = -0.08;
scene.add(cloth);

// Crystal ball - outer
const crystalOuterGeo = new THREE.SphereGeometry(0.6, 32, 32);
const crystalOuterMat = new THREE.MeshPhysicalMaterial({
  color: 0xaabbff, transparent: true, opacity: 0.25,
  metalness: 0.1, roughness: 0, transmission: 0.9,
  thickness: 0.5, envMapIntensity: 1,
});
const crystalOuter = new THREE.Mesh(crystalOuterGeo, crystalOuterMat);
crystalOuter.position.y = 1.0;
scene.add(crystalOuter);

// Crystal ball - inner glow
const crystalInnerGeo = new THREE.SphereGeometry(0.45, 16, 16);
const crystalInnerMat = new THREE.MeshBasicMaterial({ color: 0x7744cc, transparent: true, opacity: 0.15 });
const crystalInner = new THREE.Mesh(crystalInnerGeo, crystalInnerMat);
crystalInner.position.y = 1.0;
scene.add(crystalInner);

// Crystal ball - base pedestal
const baseGeo = new THREE.CylinderGeometry(0.35, 0.45, 0.2, 8);
const baseMat = new THREE.MeshStandardMaterial({ color: 0x2a1a0a, metalness: 0.8, roughness: 0.3 });
const base = new THREE.Mesh(baseGeo, baseMat);
base.position.y = 0.32;
scene.add(base);

// Candles (4)
const candles = [];
candlePositions.forEach(pos => {
  const group = new THREE.Group();
  // Body
  const bodyGeo = new THREE.CylinderGeometry(0.04, 0.05, 0.25, 8);
  const bodyMat = new THREE.MeshStandardMaterial({ color: 0xfff5e0 });
  const body = new THREE.Mesh(bodyGeo, bodyMat);
  body.position.y = 0.125;
  group.add(body);
  // Flame
  const flameGeo = new THREE.SphereGeometry(0.025, 8, 6);
  const flameMat = new THREE.MeshBasicMaterial({ color: 0xffcc00 });
  const flame = new THREE.Mesh(flameGeo, flameMat);
  flame.position.y = 0.27;
  group.add(flame);
  group.position.copy(pos);
  group.position.y = 0.22;
  scene.add(group);
  candles.push({ group, flame, flameMat });
});

// ===== FULL 78-CARD TAROT DECK =====
// 22 Major Arcana (shown in ring) + 56 Minor Arcana (drawn from deck)
const MAJOR_ARCANA = [
  { num: 0,  name: 'The Fool',          symbol: '0',     mood: 'positive', suit: 'major' },
  { num: 1,  name: 'The Magician',      symbol: 'I',     mood: 'positive', suit: 'major' },
  { num: 2,  name: 'High Priestess',    symbol: 'II',    mood: 'neutral',  suit: 'major' },
  { num: 3,  name: 'The Empress',       symbol: 'III',   mood: 'positive', suit: 'major' },
  { num: 4,  name: 'The Emperor',       symbol: 'IV',    mood: 'positive', suit: 'major' },
  { num: 5,  name: 'Hierophant',        symbol: 'V',     mood: 'neutral',  suit: 'major' },
  { num: 6,  name: 'The Lovers',        symbol: 'VI',    mood: 'positive', suit: 'major' },
  { num: 7,  name: 'The Chariot',       symbol: 'VII',   mood: 'positive', suit: 'major' },
  { num: 8,  name: 'Strength',          symbol: 'VIII',  mood: 'positive', suit: 'major' },
  { num: 9,  name: 'The Hermit',        symbol: 'IX',    mood: 'neutral',  suit: 'major' },
  { num: 10, name: 'Wheel of Fortune',  symbol: 'X',     mood: 'positive', suit: 'major' },
  { num: 11, name: 'Justice',           symbol: 'XI',    mood: 'neutral',  suit: 'major' },
  { num: 12, name: 'The Hanged Man',    symbol: 'XII',   mood: 'warning',  suit: 'major' },
  { num: 13, name: 'Death',             symbol: 'XIII',  mood: 'dark',     suit: 'major' },
  { num: 14, name: 'Temperance',        symbol: 'XIV',   mood: 'positive', suit: 'major' },
  { num: 15, name: 'The Devil',         symbol: 'XV',    mood: 'dark',     suit: 'major' },
  { num: 16, name: 'The Tower',         symbol: 'XVI',   mood: 'dark',     suit: 'major' },
  { num: 17, name: 'The Star',          symbol: 'XVII',  mood: 'positive', suit: 'major' },
  { num: 18, name: 'The Moon',          symbol: 'XVIII', mood: 'warning',  suit: 'major' },
  { num: 19, name: 'The Sun',           symbol: 'XIX',   mood: 'positive', suit: 'major' },
  { num: 20, name: 'Judgement',         symbol: 'XX',    mood: 'warning',  suit: 'major' },
  { num: 21, name: 'The World',         symbol: 'XXI',   mood: 'positive', suit: 'major' },
];

// Minor Arcana: 4 suits √ó 14 cards
const MINOR_SUITS = {
  wands:     { icon: 'üî•', color: '#ff6600', element: 'Api' },
  cups:      { icon: 'üíß', color: '#3399ff', element: 'Air' },
  swords:    { icon: '‚öîÔ∏è', color: '#ccccff', element: 'Angin' },
  pentacles: { icon: 'ü™ô', color: '#33cc33', element: 'Tanah' },
};
const MINOR_RANKS = [
  { rank: 'Ace',    val: 1,  mood: 'positive' },
  { rank: 'Two',    val: 2,  mood: 'positive' },
  { rank: 'Three',  val: 3,  mood: 'positive' },
  { rank: 'Four',   val: 4,  mood: 'neutral' },
  { rank: 'Five',   val: 5,  mood: 'warning' },
  { rank: 'Six',    val: 6,  mood: 'positive' },
  { rank: 'Seven',  val: 7,  mood: 'neutral' },
  { rank: 'Eight',  val: 8,  mood: 'neutral' },
  { rank: 'Nine',   val: 9,  mood: 'positive' },
  { rank: 'Ten',    val: 10, mood: 'neutral' },
  { rank: 'Page',   val: 11, mood: 'positive' },
  { rank: 'Knight', val: 12, mood: 'positive' },
  { rank: 'Queen',  val: 13, mood: 'positive' },
  { rank: 'King',   val: 14, mood: 'positive' },
];
// Override moods for specific tricky cards
const MINOR_MOOD_OVERRIDES = {
  'Five of Swords': 'dark', 'Three of Swords': 'dark', 'Ten of Swords': 'dark',
  'Eight of Swords': 'warning', 'Nine of Swords': 'dark', 'Seven of Swords': 'warning',
  'Five of Cups': 'warning', 'Five of Wands': 'warning', 'Five of Pentacles': 'warning',
  'Seven of Cups': 'warning', 'Eight of Cups': 'warning',
};
const MINOR_ARCANA = [];
for (const [suitName, suitData] of Object.entries(MINOR_SUITS)) {
  for (const r of MINOR_RANKS) {
    const name = `${r.rank} of ${suitName.charAt(0).toUpperCase() + suitName.slice(1)}`;
    MINOR_ARCANA.push({
      num: 22 + MINOR_ARCANA.length,
      name,
      symbol: `${r.rank === 'Ace' ? 'A' : r.val <= 10 ? r.val : r.rank[0]}`,
      mood: MINOR_MOOD_OVERRIDES[name] || r.mood,
      suit: suitName,
      suitIcon: suitData.icon,
      suitColor: suitData.color,
    });
  }
}

// Full 78-card deck
const TAROT_CARDS = [...MAJOR_ARCANA, ...MINOR_ARCANA];

// ===== TAROT UPRIGHT / REVERSED MEANINGS =====
// Used for readings and idle card explanations
const TAROT_MEANINGS = {
  0:  { upright: 'Permulaan baru, spontan, potensi tak terbatas', reversed: 'Ceroboh, takut memulai, salah langkah' },
  1:  { upright: 'Manifestasi, kemampuan, kekuatan untuk mewujudkan', reversed: 'Manipulasi, bakat terpendam, kurang fokus' },
  2:  { upright: 'Intuisi, misteri, kebijaksanaan tersembunyi', reversed: 'Rahasia, ilmu terpendam, abaikan firasat' },
  3:  { upright: 'Kelimpahan, kesuburan, kasih sayang ibu', reversed: 'Ketergantungan, kurang percaya diri, kreatif terhambat' },
  4:  { upright: 'Otoritas, struktur, kepemimpinan, stabilitas', reversed: 'Dominasi berlebihan, kaku, tiran' },
  5:  { upright: 'Tradisi, kebijaksanaan, bimbingan spiritual', reversed: 'Pemberontakan, cara baru, pecah dari tradisi' },
  6:  { upright: 'Cinta, harmoni, pilihan hati, koneksi jiwa', reversed: 'Hubungan tak seimbang, pilihan sulit, konflik batin' },
  7:  { upright: 'Kemenangan, determinasi, maju terus pantang mundur', reversed: 'Arah tak jelas, kehilangan kendali, agresif' },
  8:  { upright: 'Kekuatan batin, keberanian, kesabaran', reversed: 'Keraguan, kelemahan, kurang percaya diri' },
  9:  { upright: 'Pencarian jiwa, refleksi, kebijaksanaan dalam', reversed: 'Terlalu tertutup, isolasi, takut berubah' },
  10: { upright: 'Takdir berputar, keberuntungan, perubahan besar', reversed: 'Nasib buruk sementara, tolak perubahan, siklus negatif' },
  11: { upright: 'Keadilan, kebenaran, keputusan adil', reversed: 'Ketidakadilan, bias, konsekuensi karma' },
  12: { upright: 'Pengorbanan, perspektif baru, lepaskan ego', reversed: 'Menolak berubah, korban sia-sia, keras kepala' },
  13: { upright: 'Transformasi besar, akhir satu bab, awal baru', reversed: 'Takut perubahan, menahan yang perlu dilepas' },
  14: { upright: 'Keseimbangan, kesabaran, harmoni hidup', reversed: 'Berlebihan, tidak seimbang, terburu-buru' },
  15: { upright: 'Godaan, keterikatan, bayangan diri', reversed: 'Pembebasan, lepas dari belenggu, sadar diri' },
  16: { upright: 'Kejutan, perubahan mendadak, fondasi runtuh', reversed: 'Hindari bencana, belajar dari krisis, bangkit' },
  17: { upright: 'Harapan, inspirasi, ketenangan jiwa', reversed: 'Putus asa, kehilangan iman, gelap sementara' },
  18: { upright: 'Ilusi, intuisi kuat, rahasia terungkap', reversed: 'Kebingungan, ketakutan, tertipu penampilan' },
  19: { upright: 'Kebahagiaan, sukses, vitalitas, kejelasan', reversed: 'Terlalu optimis, kelelahan, ego berlebihan' },
  20: { upright: 'Kebangkitan, panggilan jiwa, evaluasi hidup', reversed: 'Menolak evaluasi, takut dihakimi, menyesal' },
  21: { upright: 'Pencapaian total, keutuhan, siklus lengkap', reversed: 'Belum selesai, takut penutupan, kurang puas' },
};

const tarotSprites = [];
let drawnCard = null; // { sprite, targetPos, startPos, animProgress, card }
let drawnCardTimer = 0;

// ===== PROPER TAROT-ZODIAC CORRESPONDENCE =====
// Traditional zodiac ‚Üí Major Arcana mapping (real tarot astrology)
const ZODIAC_TAROT = {
  aries:       { major: 4,  suit: 'wands' },    // The Emperor + Wands (Fire)
  taurus:      { major: 5,  suit: 'pentacles' }, // Hierophant + Pentacles (Earth)
  gemini:      { major: 6,  suit: 'swords' },    // The Lovers + Swords (Air)
  cancer:      { major: 7,  suit: 'cups' },       // The Chariot + Cups (Water)
  leo:         { major: 8,  suit: 'wands' },      // Strength + Wands (Fire)
  virgo:       { major: 9,  suit: 'pentacles' },  // The Hermit + Pentacles (Earth)
  libra:       { major: 11, suit: 'swords' },     // Justice + Swords (Air)
  scorpio:     { major: 13, suit: 'cups' },       // Death + Cups (Water)
  sagittarius: { major: 14, suit: 'wands' },      // Temperance + Wands (Fire)
  capricorn:   { major: 15, suit: 'pentacles' },  // The Devil + Pentacles (Earth)
  aquarius:    { major: 17, suit: 'swords' },     // The Star + Swords (Air)
  pisces:      { major: 18, suit: 'cups' },       // The Moon + Cups (Water)
};

// Element ‚Üí Minor Arcana suit offset (each suit = 14 cards, starting at index 22)
const SUIT_OFFSET = { wands: 22, cups: 36, swords: 50, pentacles: 64 };

// Hash viewer ID for consistent secondary card within their suit
function hashViewerId(viewerId) {
  let hash = 0;
  for (let i = 0; i < viewerId.length; i++) {
    hash = ((hash << 5) - hash) + viewerId.charCodeAt(i);
    hash |= 0;
  }
  return Math.abs(hash);
}

// ===== SMART TAROT CARD SELECTION =====
// Contextual card picking: avoids repeats, gift-tier weighting, mood balance, zodiac affinity

// Themed card pools for specific reading types
const LOVE_CARDS = [6, 2, 3, 9, 17, 19, 21]; // Lovers, Priestess, Empress, Hermit, Star, Sun, World
const VIP_POWER_CARDS = [1, 10, 19, 20, 21, 8, 7]; // Magician, Wheel, Sun, Judgement, World, Strength, Chariot
const WISDOM_CARDS = [2, 9, 12, 18, 5, 11, 14]; // Priestess, Hermit, Hanged Man, Moon, Hierophant, Justice, Temperance
const DRAMATIC_MAJOR = [13, 15, 16, 18, 20]; // Death, Devil, Tower, Moon, Judgement ‚Äî intense readings
const POSITIVE_MAJOR = [0, 1, 3, 6, 8, 17, 19, 21]; // Fool, Magician, Empress, Lovers, Strength, Star, Sun, World

function pickTarotForReading(readingType, zodiac, viewerId, diamonds) {
  const viewer = viewerId ? viewers.get(viewerId) : null;
  const zt = zodiac ? ZODIAC_TAROT[zodiac] : null;
  const history = viewer?.readingHistory || [];
  const drawnBefore = new Set(history.map(h => h.tarotCardIndex).filter(x => x !== undefined));
  const lastMood = history.length > 0 ? (TAROT_CARDS[history[history.length - 1]?.tarotCardIndex] || {}).mood : null;
  const readingsCount = viewer?.readingsCount || 0;
  diamonds = diamonds || 0;

  // Helper: pick from a card pool, avoiding repeats & balancing mood
  function pickFromPool(pool) {
    let available = pool.filter(i => !drawnBefore.has(i));
    if (available.length === 0) available = [...pool]; // all drawn before, allow repeats
    // Mood balance: if last reading was dark/warning, favor positive cards
    if ((lastMood === 'dark' || lastMood === 'warning') && available.length > 2) {
      const positive = available.filter(i => TAROT_CARDS[i]?.mood === 'positive');
      if (positive.length > 0) available = positive;
    }
    // Time + viewer seeded pick for variety
    const timeSeed = Math.floor(Date.now() / 1000) % 997; // changes every second
    const viewerSeed = viewerId ? hashViewerId(viewerId + readingsCount) : 0;
    return available[(timeSeed + viewerSeed) % available.length];
  }

  switch (readingType) {
    case 'jodoh': {
      // Love reading ‚Äî rotate through love-themed cards, not always The Lovers
      const lovePool = [...LOVE_CARDS];
      // Add their zodiac's major if available (personal touch)
      if (zt && !lovePool.includes(zt.major)) lovePool.push(zt.major);
      // Add cups court cards (Page/Queen of Cups = romance)
      lovePool.push(SUIT_OFFSET.cups + 10, SUIT_OFFSET.cups + 12); // Page & Queen of Cups
      return pickFromPool(lovePool);
    }

    case 'vip_vision': {
      // VIP ‚Äî cycle through the most powerful & dramatic cards
      const vipPool = [...VIP_POWER_CARDS, ...DRAMATIC_MAJOR];
      // Deduplicate
      const uniqueVip = [...new Set(vipPool)];
      return pickFromPool(uniqueVip);
    }

    case 'zodiac':
      // Zodiac reading ‚Äî their zodiac's Major Arcana + related cards
      if (zt) {
        const pool = [zt.major];
        // Add Minor Arcana ace from their suit (new energy)
        pool.push(SUIT_OFFSET[zt.suit]); // Ace
        // Add a court card from their suit
        pool.push(SUIT_OFFSET[zt.suit] + 10 + (readingsCount % 4)); // rotate Page‚ÜíKing
        return pickFromPool(pool);
      }
      return pickFromPool(POSITIVE_MAJOR);

    case 'fortune':
      // Fortune ‚Äî varies by gift tier
      if (diamonds >= 100 && zt) {
        // Big gift fortune: Major Arcana from their zodiac + powerful majors
        const pool = [zt.major, ...POSITIVE_MAJOR.filter(c => c !== zt.major)];
        return pickFromPool(pool);
      }
      if (zt) {
        // Standard fortune: Minor Arcana from their element's suit
        const suitStart = SUIT_OFFSET[zt.suit];
        const pool = [];
        for (let i = 0; i < 14; i++) pool.push(suitStart + i);
        return pickFromPool(pool);
      }
      return pickFromPool(POSITIVE_MAJOR);

    case 'gift_reading': {
      // Gift reading ‚Äî card power scales with diamond value
      if (diamonds >= 100) {
        // Big gift: powerful Major Arcana (never minor)
        const pool = zt ? [zt.major, ...VIP_POWER_CARDS] : [...VIP_POWER_CARDS];
        return pickFromPool([...new Set(pool)]);
      }
      if (diamonds >= 11) {
        // Medium gift: Major Arcana or court cards from their suit
        if (zt) {
          const pool = [zt.major];
          // Court cards (Page, Knight, Queen, King) from their suit
          for (let i = 10; i < 14; i++) pool.push(SUIT_OFFSET[zt.suit] + i);
          // Add a couple of positive majors
          pool.push(...POSITIVE_MAJOR.slice(0, 3));
          return pickFromPool([...new Set(pool)]);
        }
        return pickFromPool(POSITIVE_MAJOR);
      }
      // Small gift: Minor Arcana from their suit (personal touch)
      if (zt) {
        const suitStart = SUIT_OFFSET[zt.suit];
        const pool = [];
        for (let i = 0; i < 10; i++) pool.push(suitStart + i); // Ace through 10
        return pickFromPool(pool);
      }
      return pickFromPool(POSITIVE_MAJOR);
    }

    case 'question':
      // Questions ‚Üí expanded wisdom card pool
      return pickFromPool(WISDOM_CARDS);

    case 'welcome':
      // Welcome ‚Äî The Fool (beginning) weighted heavily, but can vary
      if (readingsCount > 0) {
        // Returning viewer gets The World or positive card
        return pickFromPool([21, 19, 17, 8]); // World, Sun, Star, Strength
      }
      return pickFromPool([0, 0, 0, 21]); // 75% Fool, 25% World

    default:
      return zt ? pickFromPool([zt.major]) : pickFromPool(POSITIVE_MAJOR);
  }
}

// Map card to its real image path
function getTarotImagePath(card) {
  if (card.suit === 'major') {
    return `/fortuneteller-assets/tarot/major_${String(card.num).padStart(2, '0')}.jpg`;
  }
  const suitNum = card.num - 22; // minor arcana start at 22
  const suitNames = { wands: 0, cups: 14, swords: 28, pentacles: 42 };
  const suitOffset = suitNames[card.suit] || 0;
  const cardInSuit = suitNum - suitOffset + 1;
  return `/fortuneteller-assets/tarot/${card.suit}_${String(cardInSuit).padStart(2, '0')}.jpg`;
}

function createTarotSprite(card, index, totalInRing) {
  const w = 120, h = 200;
  const cvs = document.createElement('canvas');
  cvs.width = w; cvs.height = h;
  const ctx = cvs.getContext('2d');

  const isMinor = card.suit !== 'major';
  const suitColor = isMinor ? card.suitColor : null;

  // Draw placeholder card back (will be replaced by real image when loaded)
  const grad = ctx.createLinearGradient(0, 0, 0, h);
  grad.addColorStop(0, isMinor ? '#0a1a2a' : '#1a0a3a');
  grad.addColorStop(1, '#0a0020');
  ctx.fillStyle = grad;
  ctx.roundRect(2, 2, w - 4, h - 4, 6);
  ctx.fill();

  // Border
  const borderColor = isMinor ? suitColor :
    card.mood === 'dark' ? '#aa3333' : card.mood === 'warning' ? '#cc8800' : '#f1c40f';
  ctx.strokeStyle = borderColor;
  ctx.lineWidth = 2;
  ctx.roundRect(2, 2, w - 4, h - 4, 6);
  ctx.stroke();

  // Symbol placeholder
  ctx.font = 'bold 22px serif';
  ctx.textAlign = 'center';
  ctx.fillStyle = isMinor ? suitColor : '#f1c40f';
  ctx.fillText(card.symbol, w / 2, h / 2);

  const tex = new THREE.CanvasTexture(cvs);
  const mat = new THREE.SpriteMaterial({ map: tex, transparent: true, opacity: 0.5 });
  const sprite = new THREE.Sprite(mat);
  sprite.scale.set(0.4, 0.66, 1);
  const angle = (index / (totalInRing || 22)) * Math.PI * 2;
  sprite.userData = { baseAngle: angle, index, card, originalOpacity: 0.5 };
  scene.add(sprite);

  // Load real tarot card image
  const img = new Image();
  img.crossOrigin = 'anonymous';
  img.onload = () => {
    const c2 = document.createElement('canvas');
    c2.width = w; c2.height = h;
    const g2 = c2.getContext('2d');
    // Draw image with rounded corners
    g2.roundRect(2, 2, w - 4, h - 4, 6);
    g2.clip();
    g2.drawImage(img, 2, 2, w - 4, h - 4);
    // Mystical border glow
    g2.strokeStyle = borderColor;
    g2.lineWidth = 2;
    g2.roundRect(2, 2, w - 4, h - 4, 6);
    g2.stroke();
    // Update texture
    sprite.material.map = new THREE.CanvasTexture(c2);
    sprite.material.needsUpdate = true;
  };
  img.src = getTarotImagePath(card);

  return sprite;
}

// Only Major Arcana (22) in the visual ring
MAJOR_ARCANA.forEach((card, i) => {
  tarotSprites.push(createTarotSprite(card, i, 22));
});
// Pre-create Minor Arcana sprites (hidden off-screen until drawn)
MINOR_ARCANA.forEach((card, i) => {
  const sprite = createTarotSprite(card, i, 56);
  sprite.visible = false; // hidden until drawn
  sprite.position.set(0, -5, 0); // below scene
  tarotSprites.push(sprite);
});

// Draw a tarot card ‚Äî flies from ring/deck to center
// forcePosition: 'upright' | 'reversed' | null (random ~30% reversed)
function drawTarotCard(cardIndex, forcePosition) {
  if (cardIndex === undefined || cardIndex === null) {
    cardIndex = Math.floor(Math.random() * TAROT_CARDS.length);
  }
  const sprite = tarotSprites[cardIndex];
  const card = TAROT_CARDS[cardIndex];
  const isMinor = card.suit !== 'major';

  // Determine upright or reversed (~30% chance reversed unless forced)
  const isReversed = forcePosition === 'reversed' ? true :
    forcePosition === 'upright' ? false :
    Math.random() < 0.3;

  // Minor Arcana: make visible and start from below
  if (isMinor) {
    sprite.visible = true;
    sprite.position.set(0, -2, 2);
    sprite.scale.set(0.35, 0.52, 1);
  }

  // Use rotation instead of negative scale for reversed cards
  sprite.material.rotation = isReversed ? Math.PI : 0;

  drawnCard = {
    sprite,
    card,
    startPos: sprite.position.clone(),
    targetPos: new THREE.Vector3(0, 2.0, 2.0),
    animProgress: 0,
    startScale: sprite.scale.clone(),
    targetScale: new THREE.Vector3(0.7, 1.05, 1),
    isMinor,
    isReversed,
  };
  drawnCardTimer = 6;

  // Highlight the card
  sprite.material.opacity = 1.0;

  // Return card with position info
  return { ...card, isReversed, position: isReversed ? 'Terbalik (Reversed)' : 'Tegak (Upright)' };
}

// Multi-card spread ‚Äî draw multiple cards for richer readings
// spreadType: '1-card', '3-card' (past/present/future), '5-card' (cross)
let drawnSpread = []; // array of drawnCard objects

function drawTarotSpread(cardIndices, spreadType) {
  dismissDrawnCard(); // clear any existing
  const cards = [];
  const positions = {
    '1-card': [new THREE.Vector3(0, 2.0, 2.0)],
    '3-card': [
      new THREE.Vector3(-0.55, 2.0, 2.0),  // Past (left)
      new THREE.Vector3(0, 2.0, 2.0),       // Present (center)
      new THREE.Vector3(0.55, 2.0, 2.0),    // Future (right)
    ],
    '5-card': [
      new THREE.Vector3(-0.55, 2.0, 2.0),   // Past
      new THREE.Vector3(0, 2.0, 2.0),        // Present
      new THREE.Vector3(0.55, 2.0, 2.0),     // Future
      new THREE.Vector3(0, 2.55, 2.0),       // Above (advice)
      new THREE.Vector3(0, 1.45, 2.0),       // Below (foundation)
    ],
  };
  const targets = positions[spreadType] || positions['1-card'];
  const spreadLabels = {
    '3-card': ['Masa Lalu', 'Sekarang', 'Masa Depan'],
    '5-card': ['Masa Lalu', 'Sekarang', 'Masa Depan', 'Nasihat', 'Fondasi'],
  };

  for (let i = 0; i < cardIndices.length && i < targets.length; i++) {
    const result = drawTarotCard(cardIndices[i]);
    // Override target position for multi-card layout
    if (drawnCard && cardIndices.length > 1) {
      drawnCard.targetPos = targets[i];
      drawnCard.targetScale = new THREE.Vector3(0.5, 0.75, 1);
    }
    if (drawnCard) {
      drawnCard.spreadLabel = spreadLabels[spreadType]?.[i] || '';
      drawnSpread.push(drawnCard);
    }
    cards.push(result);
  }
  // Keep drawnCard pointing to center card for compatibility
  drawnCard = drawnSpread.length > 0 ? drawnSpread[Math.floor(drawnSpread.length / 2)] : null;
  drawnCardTimer = cardIndices.length > 1 ? 10 : 6; // longer display for spreads
  return cards;
}

function dismissDrawnCard() {
  // Dismiss all cards in spread
  for (const dc of drawnSpread) {
    if (!dc) continue;
    dc.sprite.material.opacity = dc.sprite.userData.originalOpacity;
    dc.sprite.scale.copy(dc.startScale);
    dc.sprite.material.rotation = 0;
    if (dc.isMinor) {
      dc.sprite.visible = false;
      dc.sprite.position.set(0, -5, 0);
    }
  }
  drawnSpread = [];
  if (drawnCard && !drawnSpread.includes(drawnCard)) {
    drawnCard.sprite.material.opacity = drawnCard.sprite.userData.originalOpacity;
    drawnCard.sprite.scale.copy(drawnCard.startScale);
    drawnCard.sprite.material.rotation = 0;
    if (drawnCard.isMinor) {
      drawnCard.sprite.visible = false;
      drawnCard.sprite.position.set(0, -5, 0);
    }
  }
  drawnCard = null;
}

// Stars / galaxy background
const starCount = 500;
const starGeo = new THREE.BufferGeometry();
const starPositions = new Float32Array(starCount * 3);
const starSizes = new Float32Array(starCount);
for (let i = 0; i < starCount; i++) {
  const r = 30 + Math.random() * 40;
  const theta = Math.random() * Math.PI * 2;
  const phi = Math.random() * Math.PI;
  starPositions[i * 3] = r * Math.sin(phi) * Math.cos(theta);
  starPositions[i * 3 + 1] = r * Math.cos(phi);
  starPositions[i * 3 + 2] = r * Math.sin(phi) * Math.sin(theta);
  starSizes[i] = 0.05 + Math.random() * 0.15;
}
starGeo.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
starGeo.setAttribute('size', new THREE.BufferAttribute(starSizes, 1));
const starMat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.15, sizeAttenuation: true, transparent: true, opacity: 0.6 });
const stars = new THREE.Points(starGeo, starMat);
scene.add(stars);

// Particle system - mystic dust
const particleCount = 100;
const particleGeo = new THREE.BufferGeometry();
const particlePos = new Float32Array(particleCount * 3);
const particleVel = new Float32Array(particleCount * 3);
const particleColors = new Float32Array(particleCount * 3);
for (let i = 0; i < particleCount; i++) {
  const angle = Math.random() * Math.PI * 2;
  const r = 0.3 + Math.random() * 1.0;
  particlePos[i * 3] = Math.cos(angle) * r;
  particlePos[i * 3 + 1] = 0.5 + Math.random() * 2.0;
  particlePos[i * 3 + 2] = Math.sin(angle) * r;
  particleVel[i * 3] = (Math.random() - 0.5) * 0.1;
  particleVel[i * 3 + 1] = 0.1 + Math.random() * 0.2;
  particleVel[i * 3 + 2] = (Math.random() - 0.5) * 0.1;
  // Purple or gold
  if (Math.random() > 0.5) {
    particleColors[i * 3] = 0.6; particleColors[i * 3 + 1] = 0.27; particleColors[i * 3 + 2] = 0.71;
  } else {
    particleColors[i * 3] = 0.95; particleColors[i * 3 + 1] = 0.77; particleColors[i * 3 + 2] = 0.06;
  }
}
particleGeo.setAttribute('position', new THREE.BufferAttribute(particlePos, 3));
particleGeo.setAttribute('color', new THREE.BufferAttribute(particleColors, 3));
const particleMat = new THREE.PointsMaterial({ size: 0.04, vertexColors: true, transparent: true, opacity: 0.5, sizeAttenuation: true });
const particles = new THREE.Points(particleGeo, particleMat);
scene.add(particles);

// ===== 3D SKULL MODEL =====
let skullModel = null;
let skullMixer = null;
let skullAnimations = {};
let skullVisible = false;
let skullFadeTimer = 0;

const gltfLoader = new GLTFLoader();
gltfLoader.load('/fortuneteller-assets/skull.glb', (gltf) => {
  skullModel = gltf.scene;
  // Meshy model has armature at 0.01 scale, mesh bounds ~1.7 units tall
  // At scale 1.0 model is ~1.7 units. We want it ~2 units tall above crystal ball
  skullModel.scale.set(1.2, 1.2, 1.2);
  skullModel.position.set(0, 1.5, 0); // feet on table level, head above crystal ball
  skullModel.visible = false;

  // Dark purple emissive tint
  skullModel.traverse(child => {
    if (child.isMesh) {
      child.material = child.material.clone();
      child.material.emissive = new THREE.Color(0x6622aa);
      child.material.emissiveIntensity = 0.5;
      child.material.transparent = true;
      child.material.opacity = 0.9;
    }
  });

  scene.add(skullModel);

  // Setup animations
  skullMixer = new THREE.AnimationMixer(skullModel);
  gltf.animations.forEach(clip => {
    skullAnimations[clip.name] = skullMixer.clipAction(clip);
    skullAnimations[clip.name].setLoop(THREE.LoopRepeat);
  });

  console.log('Skull loaded:', Object.keys(skullAnimations).join(', '));
}, undefined, (err) => console.warn('Skull load failed:', err));

let skullElapsed = 0;
let skullDuration = 4;

function showSkull(duration = 4000) {
  if (!skullModel) { console.warn('Skull not loaded yet'); return; }
  skullModel.visible = true;
  skullVisible = true;
  skullElapsed = 0;
  skullDuration = duration / 1000;
  skullModel.position.set(0, 0.3, 0); // center on table
  skullModel.rotation.set(0, -Math.PI / 2, 0); // face camera (adjust from left-facing)
  skullModel.scale.set(0.01, 0.01, 0.01); // start tiny, scale up to 1.2

  // Hide crystal ball
  crystalOuter.visible = false;
  crystalInner.visible = false;
  base.visible = false;

  // Play Hip_Hop_Dance_3 if available, else first animation
  const anim = skullAnimations['Hip_Hop_Dance_3'] || Object.values(skullAnimations)[0];
  if (anim) {
    anim.reset().play();
  }

  // Purple skull light
  crystalLight.color.set(0xaa00ff);
  crystalLight.intensity = 5;
}

function hideSkull() {
  if (!skullModel) return;
  skullModel.visible = false;
  skullVisible = false;
  // Stop all animations
  Object.values(skullAnimations).forEach(a => a.stop());
  // Restore crystal ball
  crystalOuter.visible = true;
  crystalInner.visible = true;
  base.visible = true;
  // Restore crystal light
  crystalLight.color.set(0x9b59b6);
  crystalLight.intensity = 2;
}

// ===== VIEWER ORB SYSTEM =====
function hashColor(id) {
  let hash = 0;
  for (let i = 0; i < id.length; i++) hash = (hash * 31 + id.charCodeAt(i)) & 0xffffff;
  return CHAR_COLORS[Math.abs(hash) % CHAR_COLORS.length];
}

function createNameSprite(name, color) {
  const cvs = document.createElement('canvas');
  cvs.width = 128; cvs.height = 32;
  const ctx = cvs.getContext('2d');
  ctx.font = 'bold 14px Segoe UI';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillStyle = '#fff';
  ctx.fillText(name.slice(0, 12), 64, 16);
  const tex = new THREE.CanvasTexture(cvs);
  const mat = new THREE.SpriteMaterial({ map: tex, transparent: true, opacity: 0.8 });
  const sprite = new THREE.Sprite(mat);
  sprite.scale.set(0.8, 0.2, 1);
  return sprite;
}

function createPhotoOrb(nickname, profilePic, color) {
  // Create circular photo sprite or colored fallback
  const size = 128;
  const cvs = document.createElement('canvas');
  cvs.width = size; cvs.height = size;
  const ctx = cvs.getContext('2d');

  // Draw circular border glow
  ctx.beginPath();
  ctx.arc(size/2, size/2, size/2 - 2, 0, Math.PI * 2);
  ctx.fillStyle = `#${color.toString(16).padStart(6, '0')}`;
  ctx.fill();

  // Inner circle (dark bg)
  ctx.beginPath();
  ctx.arc(size/2, size/2, size/2 - 6, 0, Math.PI * 2);
  ctx.fillStyle = '#1a0a3a';
  ctx.fill();

  // Initial letter as fallback
  ctx.font = 'bold 48px sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillStyle = `#${color.toString(16).padStart(6, '0')}`;
  ctx.fillText(nickname.charAt(0).toUpperCase(), size/2, size/2);

  const tex = new THREE.CanvasTexture(cvs);
  const mat = new THREE.SpriteMaterial({ map: tex, transparent: true, opacity: 0.9 });
  const sprite = new THREE.Sprite(mat);
  sprite.scale.set(0.35, 0.35, 1);

  // Try loading profile photo
  if (profilePic) {
    const img = new Image();
    img.crossOrigin = 'anonymous';
    img.onload = () => {
      // Redraw canvas with photo in circle
      ctx.clearRect(0, 0, size, size);
      // Border glow
      ctx.beginPath();
      ctx.arc(size/2, size/2, size/2 - 2, 0, Math.PI * 2);
      ctx.fillStyle = `#${color.toString(16).padStart(6, '0')}`;
      ctx.fill();
      // Clip circle for photo
      ctx.save();
      ctx.beginPath();
      ctx.arc(size/2, size/2, size/2 - 6, 0, Math.PI * 2);
      ctx.clip();
      ctx.drawImage(img, 4, 4, size - 8, size - 8);
      ctx.restore();
      tex.needsUpdate = true;
    };
    img.onerror = () => {}; // keep letter fallback
    img.src = profilePic;
  }

  return { sprite, mat, tex };
}

function addViewerOrb(uniqueId, nickname) {
  if (viewerOrbs.has(uniqueId)) return;
  if (viewerOrbs.size >= MAX_ORBS) return;

  const viewer = viewers.get(uniqueId);
  const profilePic = viewer?.profilePic || '';
  const color = hashColor(uniqueId);

  // Photo orb (circular sprite with profile pic)
  const { sprite: photoSprite, mat: orbMat } = createPhotoOrb(nickname, profilePic, color);

  // Container group
  const mesh = new THREE.Group();
  mesh.add(photoSprite);

  const nameSprite = createNameSprite(nickname, color);
  nameSprite.position.y = -0.25;
  mesh.add(nameSprite);

  const angle = (viewerOrbs.size / MAX_ORBS) * Math.PI * 2;
  const radius = 2.5;
  mesh.position.set(Math.cos(angle) * radius, 1.6, Math.sin(angle) * radius);
  scene.add(mesh);

  viewerOrbs.set(uniqueId, { mesh, nameSprite, orbMat, angle, bobOffset: Math.random() * Math.PI * 2, photoSprite });
}

function removeViewerOrb(uniqueId) {
  const orb = viewerOrbs.get(uniqueId);
  if (!orb) return;
  scene.remove(orb.mesh);
  viewerOrbs.delete(uniqueId);
}

function refreshOrbs() {
  // Top 20 by score get orbs
  const sorted = Array.from(viewers.values()).sort((a, b) => b.score - a.score).slice(0, MAX_ORBS);
  const topIds = new Set(sorted.map(v => v.uniqueId));

  // Remove orbs not in top
  for (const [id] of viewerOrbs) {
    if (!topIds.has(id)) removeViewerOrb(id);
  }
  // Add new
  sorted.forEach(v => addViewerOrb(v.uniqueId, v.nickname));

  // Reposition
  let idx = 0;
  for (const [, orb] of viewerOrbs) {
    orb.angle = (idx / Math.max(viewerOrbs.size, 1)) * Math.PI * 2;
    idx++;
  }
}

// ===== READING QUEUE =====
function queueReading(type, viewerId, nickname, data = {}, priority = 1) {
  readingQueue.push({ type, viewerId, nickname, data, priority });
  processReadingQueue();
}

function processReadingQueue() {
  if (readingState !== 'IDLE') return;
  if (readingQueue.length === 0) return;

  // Update flood status
  if (floodMode) {
    document.getElementById('floodPill').textContent = `Ramai! ${readingQueue.length} antri...`;
  }

  readingQueue.sort((a, b) => b.priority - a.priority);
  const reading = readingQueue.shift();
  currentReading = reading;
  readingState = 'READING';

  // Visual: crystal ball brightens
  crystalInnerMat.opacity = 0.5;
  crystalLight.intensity = 4;

  // Show viewer focus with profile photo
  const readingLabels = {
    welcome: 'Sambutan', zodiac: 'Zodiak Reading', fortune: 'Ramalan',
    jodoh: 'Cek Jodoh', question: 'Pertanyaan', gift_reading: 'Gift Reading', vip_vision: 'VIP PROPHECY'
  };
  showViewerFocus(reading.viewerId, reading.nickname, readingLabels[reading.type] || 'Reading');

  // Determine voice event
  let eventType, eventData;
  const viewerZodiac = reading.data.zodiac || viewers.get(reading.viewerId)?.zodiac || null;

  // Helper: build card info for eventData
  function cardInfo(card) {
    const meaning = TAROT_MEANINGS[card.num];
    return {
      tarotCard: card.name,
      tarotCardIndex: card.num,
      tarotPosition: card.position,
      tarotMeaning: meaning ? (card.isReversed ? meaning.reversed : meaning.upright) : '',
    };
  }

  switch (reading.type) {
    case 'welcome':
      eventType = 'mystic_welcome';
      eventData = { name: reading.nickname };
      break;
    case 'zodiac': {
      const zCard = drawTarotCard(pickTarotForReading('zodiac', reading.data.zodiac, reading.viewerId));
      eventType = 'mystic_zodiac';
      eventData = { name: reading.nickname, zodiac: reading.data.zodiac, date: reading.data.date || '', ...cardInfo(zCard) };
      showZodiacBadge(reading.data.zodiac);
      const elem = getElementForZodiac(reading.data.zodiac);
      if (elem) setTimeout(() => triggerDramaticEffect(elem, 3000), 1500);
      if (zCard.mood === 'dark' || zCard.isReversed) setTimeout(() => triggerDramaticEffect('skull', 3500), 1000);
      break;
    }
    case 'fortune': {
      const fCard = drawTarotCard(pickTarotForReading('fortune', viewerZodiac, reading.viewerId, reading.data.diamonds));
      eventType = 'mystic_fortune';
      eventData = { name: reading.nickname, zodiac: viewerZodiac, ...cardInfo(fCard) };
      if (fCard.mood === 'dark' || fCard.isReversed) setTimeout(() => triggerDramaticEffect('skull', 3500), 1000);
      else if (viewerZodiac) {
        const e = getElementForZodiac(viewerZodiac);
        if (e) setTimeout(() => triggerDramaticEffect(e, 2500), 1500);
      }
      break;
    }
    case 'jodoh': {
      const jCard = drawTarotCard(pickTarotForReading('jodoh', null, reading.viewerId));
      eventType = 'mystic_jodoh';
      eventData = { name1: reading.nickname, zodiac1: reading.data.zodiac1 || 'unknown', name2: reading.data.partner, zodiac2: reading.data.zodiac2 || 'unknown', ...cardInfo(jCard) };
      break;
    }
    case 'question': {
      const qCard = drawTarotCard(pickTarotForReading('question', null, reading.viewerId));
      eventType = 'mystic_question';
      eventData = { name: reading.nickname, question: reading.data.question || '', ...cardInfo(qCard) };
      if (qCard.mood === 'dark' || qCard.isReversed) setTimeout(() => triggerDramaticEffect('skull', 3500), 1000);
      break;
    }
    case 'gift_reading': {
      const diamonds = reading.data.diamonds || 0;
      if (diamonds >= 100) {
        // Big gift: 3-card spread (Past, Present, Future)
        const indices = [
          pickTarotForReading('gift_reading', viewerZodiac, reading.viewerId, diamonds),
          pickTarotForReading('fortune', viewerZodiac, reading.viewerId, diamonds),
          pickTarotForReading('gift_reading', viewerZodiac, reading.viewerId, diamonds),
        ];
        const gCards = drawTarotSpread(indices, '3-card');
        eventType = 'mystic_gift_reading';
        eventData = {
          name: reading.nickname, diamonds, zodiac: viewerZodiac,
          spreadType: '3-card',
          tarotSpread: gCards.map((c, i) => `${['Masa Lalu', 'Sekarang', 'Masa Depan'][i]}: ${c.name} (${c.position})`).join(' | '),
          ...cardInfo(gCards[1]), // center card as primary
        };
        const hasDark = gCards.some(c => c.mood === 'dark' || c.isReversed);
        if (hasDark) setTimeout(() => triggerDramaticEffect('skull', 3500), 1000);
        else {
          const e = viewerZodiac ? getElementForZodiac(viewerZodiac) : null;
          if (e) setTimeout(() => triggerDramaticEffect(e, 3000), 1000);
        }
      } else {
        // Small/medium gift: 1 card
        const gCard = drawTarotCard(pickTarotForReading('gift_reading', viewerZodiac, reading.viewerId, diamonds));
        eventType = 'mystic_gift_reading';
        eventData = { name: reading.nickname, diamonds, zodiac: viewerZodiac, spreadType: '1-card', ...cardInfo(gCard) };
        if (gCard.mood === 'dark' || gCard.isReversed) {
          setTimeout(() => triggerDramaticEffect('skull', 3500), 1000);
        } else if (viewerZodiac) {
          const e = getElementForZodiac(viewerZodiac);
          if (e) setTimeout(() => triggerDramaticEffect(e, 3000), 1000);
        } else {
          const randomElements = ['fire', 'water', 'lightning'];
          setTimeout(() => triggerDramaticEffect(randomElements[Math.floor(Math.random() * randomElements.length)], 2500), 1000);
        }
      }
      break;
    }
    case 'vip_vision': {
      // VIP: 5-card cross spread (Past, Present, Future, Advice, Foundation)
      const indices = [
        pickTarotForReading('vip_vision', null, reading.viewerId, reading.data.diamonds),
        pickTarotForReading('gift_reading', viewerZodiac, reading.viewerId, reading.data.diamonds),
        pickTarotForReading('vip_vision', null, reading.viewerId, reading.data.diamonds),
        pickTarotForReading('fortune', viewerZodiac, reading.viewerId, reading.data.diamonds),
        pickTarotForReading('gift_reading', viewerZodiac, reading.viewerId, reading.data.diamonds),
      ];
      const vCards = drawTarotSpread(indices, '5-card');
      eventType = 'mystic_vip_vision';
      eventData = {
        name: reading.nickname, diamonds: reading.data.diamonds || 0, zodiac: viewerZodiac,
        spreadType: '5-card',
        tarotSpread: vCards.map((c, i) => `${['Masa Lalu', 'Sekarang', 'Masa Depan', 'Nasihat', 'Fondasi'][i]}: ${c.name} (${c.position})`).join(' | '),
        ...cardInfo(vCards[1]), // center card as primary
      };
      triggerVIPEffect();
      setTimeout(() => triggerDramaticEffect('fire', 2000), 500);
      setTimeout(() => triggerDramaticEffect('lightning', 2000), 3000);
      setTimeout(() => triggerDramaticEffect('skull', 3000), 5500);
      break;
    }
    default:
      eventType = 'mystic_fortune';
      eventData = { name: reading.nickname };
  }

  // Attach viewerId for rich context lookup
  eventData.viewerId = reading.viewerId;

  // Store tarot card info on reading so finishReading can track it
  if (eventData.tarotCard) {
    reading.data.tarotCard = eventData.tarotCard;
    reading.data.tarotCardIndex = eventData.tarotCardIndex;
  }

  // Queue voice
  queueVoiceEvent(eventType, eventData, reading.priority);

  // After brief delay, transition to REVEAL
  setTimeout(() => {
    readingState = 'REVEAL';
    totalReadings++;
    document.getElementById('readingCount').textContent = totalReadings;

    // Fortune display shows placeholder until voice text arrives
    showFortuneDisplay(reading);

    // Keep text visible until voice finishes ‚Äî use fallback timer as safety net
    if (fortuneDisplayTimer) clearTimeout(fortuneDisplayTimer);
    readingWaitingForVoice = true;
    const maxRevealTime = reading.priority >= 5 ? 60000 : reading.priority >= 4 ? 45000 : 35000;
    fortuneDisplayTimer = setTimeout(() => {
      finishReading();
    }, maxRevealTime);
  }, 2000);
}

function showFortuneDisplay(reading) {
  const el = document.getElementById('fortuneDisplay');
  const zodiacEl = document.getElementById('fortuneZodiac');
  const nameEl = document.getElementById('fortuneName');
  const textEl = document.getElementById('fortuneText');

  if (reading.data.zodiac && ZODIAC_DATA[reading.data.zodiac]) {
    zodiacEl.textContent = ZODIAC_DATA[reading.data.zodiac].symbol;
  } else {
    zodiacEl.textContent = '\uD83D\uDD2E';
  }
  nameEl.textContent = reading.nickname;
  textEl.textContent = 'Bola kristal sedang membaca...';
  el.classList.add('show');
  // Hide subtitle to avoid redundant text display
  document.getElementById('voiceSubtitle').style.display = 'none';
}

function hideFortuneDisplay() {
  document.getElementById('fortuneDisplay').classList.remove('show');
}

function finishReading() {
  if (readingState !== 'REVEAL') return;
  if (fortuneDisplayTimer) clearTimeout(fortuneDisplayTimer);
  readingWaitingForVoice = false;

  // Track reading completion in viewer profile
  if (currentReading) {
    const v = viewers.get(currentReading.viewerId);
    if (v) {
      v.readingsCount = (v.readingsCount || 0) + 1;
      const fortuneText = document.getElementById('fortuneText')?.textContent || '';
      v.lastReading = { type: currentReading.type, text: fortuneText, timestamp: Date.now() };
      v.readingHistory = v.readingHistory || [];
      v.readingHistory.push({ type: currentReading.type, tarotCard: currentReading.data?.tarotCard || '', tarotCardIndex: currentReading.data?.tarotCardIndex, timestamp: Date.now() });
      if (v.readingHistory.length > 5) v.readingHistory.shift();
    }
    conversationLog.push({ type: 'reading_done', name: currentReading.nickname, summary: `${currentReading.type} untuk ${currentReading.nickname}`, timestamp: Date.now() });
    if (conversationLog.length > MAX_CONVERSATION_LOG) conversationLog.shift();
  }

  // Debounced save after reading (5s delay to batch)
  scheduleSaveDebounced();

  // Keep text visible 5s after voice ends so viewers can read it
  setTimeout(() => {
    hideFortuneDisplay();
    hideViewerFocus();
    readingState = 'IDLE';
    currentReading = null;
    crystalInnerMat.opacity = 0.15;
    crystalLight.intensity = 2;
    hideZodiacBadge();
    if (drawnCard) dismissDrawnCard();
    processReadingQueue();
  }, 5000);
}

function showZodiacBadge(zodiac) {
  const badge = document.getElementById('zodiacBadge');
  const z = ZODIAC_DATA[zodiac];
  if (!z) return;
  document.getElementById('zodiacSymbol').textContent = z.symbol;
  document.getElementById('zodiacName').textContent = zodiac.toUpperCase() + ' ' + z.emoji;
  badge.classList.add('show');
  // Card is drawn in processReadingQueue, not here
}

function hideZodiacBadge() {
  document.getElementById('zodiacBadge').classList.remove('show');
  dismissDrawnCard();
}

// ===== VISUAL EFFECTS =====
function triggerPowerFlash() {
  const flash = document.getElementById('powerFlash');
  flash.classList.add('show');
  setTimeout(() => flash.classList.remove('show'), 300);
}

function triggerVIPEffect() {
  triggerPowerFlash();
  // Intensify everything
  candleLights.forEach(l => l.intensity = 2.0);
  crystalLight.intensity = 6;
  crystalInnerMat.opacity = 0.8;
  setTimeout(() => {
    candleLights.forEach(l => l.intensity = 0.5);
  }, 3000);
}

function triggerGiftEffect(tier) {
  if (tier === 'small') {
    // Candles flare
    candleLights.forEach(l => l.intensity = 1.2);
    setTimeout(() => candleLights.forEach(l => l.intensity = 0.5), 1000);
  } else if (tier === 'medium') {
    triggerPowerFlash();
    candleLights.forEach(l => l.intensity = 1.5);
    setTimeout(() => candleLights.forEach(l => l.intensity = 0.5), 1500);
  } else if (tier === 'big') {
    triggerPowerFlash();
    crystalLight.intensity = 5;
    candleLights.forEach(l => l.intensity = 2.0);
    setTimeout(() => {
      crystalLight.intensity = 2;
      candleLights.forEach(l => l.intensity = 0.5);
    }, 2000);
  }
}

// ===== NOTIFICATIONS =====
function addNotification(html, cls = '') {
  const container = document.getElementById('notifications');
  const el = document.createElement('div');
  el.className = `notif ${cls}`;
  el.innerHTML = html;
  container.appendChild(el);
  setTimeout(() => el.remove(), 5000);
  while (container.children.length > 8) container.removeChild(container.firstChild);
}

// ===== LEADERBOARD =====
function updateLeaderboard() {
  const sorted = Array.from(viewers.values()).sort((a, b) => b.score - a.score).slice(0, 8);
  const rows = document.getElementById('lbRows');
  rows.innerHTML = '';
  sorted.forEach((v, i) => {
    const row = document.createElement('div');
    row.className = 'lb-row';
    row.innerHTML = `<span class="lb-rank">${i + 1}</span><span class="lb-name">${v.nickname}</span><span class="lb-score">${v.score}</span>`;
    rows.appendChild(row);
  });
}

// ===== CRYSTAL ENERGY =====
function addCrystalEnergy(amount) {
  crystalEnergy = Math.min(ENERGY_THRESHOLD, crystalEnergy + amount);
  document.getElementById('energyFill').style.width = `${(crystalEnergy / ENERGY_THRESHOLD) * 100}%`;
  document.getElementById('energyValue').textContent = crystalEnergy;

  if (crystalEnergy >= ENERGY_THRESHOLD) {
    crystalEnergy = 0;
    document.getElementById('energyFill').style.width = '0%';
    document.getElementById('energyValue').textContent = '0';
    // Bonus fortune for random viewer
    const allViewers = Array.from(viewers.values());
    if (allViewers.length > 0) {
      const v = allViewers[Math.floor(Math.random() * allViewers.length)];
      addNotification(`<strong>Energi Kristal PENUH!</strong> Ramalan bonus untuk <strong>${v.nickname}</strong>!`, 'zodiac');
      queueReading('fortune', v.uniqueId, v.nickname, {}, 2);
    }
  }
}

// ===== FLOOD CONTROL =====
let lastFloodVoiceTime = 0;
function trackEvent() {
  eventsPerMinute++;
  const wasFlood = floodMode;
  floodMode = eventsPerMinute > FLOOD_THRESHOLD;
  const floodEl = document.getElementById('floodStatus');
  if (floodMode && !wasFlood) {
    floodEl.classList.add('show');
    document.getElementById('floodPill').textContent = `Ramai! ${readingQueue.length} antri...`;
    // Voice acknowledge flood (once per 90s)
    if (Date.now() - lastFloodVoiceTime > 90000) {
      lastFloodVoiceTime = Date.now();
      queueVoiceEvent('mystic_flood_acknowledge', {
        viewerCount: viewers.size,
        queueLength: readingQueue.length
      }, 2);
    }
  } else if (!floodMode && wasFlood) {
    floodEl.classList.remove('show');
  }
}

// ===== VIEWER FOCUS (profile photo during reading) =====
function showViewerFocus(viewerId, nickname, readingType) {
  const viewer = viewers.get(viewerId);
  const focusEl = document.getElementById('viewerFocus');
  const photoEl = document.getElementById('focusPhoto');
  const nameEl = document.getElementById('focusName');
  const typeEl = document.getElementById('focusType');

  // Set photo or placeholder ‚Äî keep the div, update content inside
  const pic = viewer?.profilePic;
  photoEl.innerHTML = '';
  photoEl.style.background = '';
  if (pic) {
    const img = document.createElement('img');
    img.src = pic;
    img.alt = nickname;
    img.style.width = '100%';
    img.style.height = '100%';
    img.style.objectFit = 'cover';
    img.style.borderRadius = 'inherit';
    img.onerror = () => {
      photoEl.innerHTML = '';
      photoEl.textContent = nickname.charAt(0).toUpperCase();
      photoEl.style.background = 'rgba(100, 50, 150, 0.6)';
    };
    photoEl.appendChild(img);
  } else {
    photoEl.textContent = nickname.charAt(0).toUpperCase();
    photoEl.style.background = 'rgba(100, 50, 150, 0.6)';
  }

  nameEl.textContent = nickname;
  typeEl.textContent = readingType;
  focusEl.classList.add('show');
}

function hideViewerFocus() {
  const focusEl = document.getElementById('viewerFocus');
  focusEl.classList.remove('show');
  const photoEl = document.getElementById('focusPhoto');
  if (photoEl) {
    photoEl.innerHTML = 'üîÆ';
    photoEl.style.background = '';
  }
}

// ===== DRAMATIC ELEMENT EFFECTS =====
function getElementForZodiac(zodiac) {
  if (!zodiac || !ZODIAC_DATA[zodiac]) return null;
  return ZODIAC_DATA[zodiac].element; // Api, Tanah, Angin, Air
}

function triggerDramaticEffect(element, duration = 3000) {
  const overlay = document.getElementById('dramaticOverlay');
  overlay.innerHTML = '';
  overlay.className = 'dramatic-overlay';

  switch (element) {
    case 'Api':
    case 'fire':
      overlay.classList.add('fire-effect');
      spawn3DElementParticles('fire', duration);
      break;
    case 'Air':
    case 'water':
      overlay.classList.add('water-effect');
      spawn3DElementParticles('water', duration);
      break;
    case 'skull':
    case 'dark': {
      overlay.classList.add('skull-effect');
      showSkull(duration);
      break;
    }
    case 'Angin':
    case 'lightning': {
      overlay.classList.add('lightning-effect');
      // Multiple lightning flashes
      for (let i = 0; i < 4; i++) {
        setTimeout(() => {
          const flash = document.createElement('div');
          flash.className = 'lightning-flash';
          overlay.appendChild(flash);
          setTimeout(() => flash.remove(), 150);
        }, i * 300);
      }
      const bolt = document.createElement('div');
      bolt.className = 'lightning-bolt';
      bolt.textContent = '\u26A1';
      overlay.appendChild(bolt);
      spawn3DElementParticles('lightning', duration);
      break;
    }
    case 'Tanah':
    default:
      // Earth rumble ‚Äî camera shake + 3D particles
      spawn3DElementParticles('earth', duration);
      if (!manualCamera) {
        const origY = camera.position.y;
        let shakeTime = 0;
        const shakeInterval = setInterval(() => {
          shakeTime += 50;
          camera.position.y = origY + (Math.random() - 0.5) * 0.15;
          if (shakeTime > 1200) { clearInterval(shakeInterval); camera.position.y = origY; }
        }, 50);
      }
      return;
  }

  overlay.classList.add('show');
  setTimeout(() => {
    overlay.classList.remove('show');
    setTimeout(() => { overlay.innerHTML = ''; overlay.className = 'dramatic-overlay'; }, 500);
  }, duration);
}

// 3D Element Particles ‚Äî dramatic particle burst in Three.js scene
let elementParticles = null;
let elementParticleData = null;

function spawn3DElementParticles(type, duration = 3000) {
  // Remove existing
  if (elementParticles) {
    scene.remove(elementParticles);
    elementParticles.geometry.dispose();
    elementParticles.material.dispose();
    elementParticles = null;
  }

  const count = type === 'lightning' ? 60 : 80;
  const geo = new THREE.BufferGeometry();
  const positions = new Float32Array(count * 3);
  const velocities = new Float32Array(count * 3);
  const colors = new Float32Array(count * 3);
  const sizes = new Float32Array(count);

  const colorSets = {
    fire: [[1, 0.3, 0], [1, 0.6, 0], [1, 0.9, 0.2], [1, 0.15, 0]],
    water: [[0, 0.4, 1], [0.2, 0.6, 1], [0, 0.7, 0.9], [0.3, 0.8, 1]],
    lightning: [[0.7, 0.7, 1], [0.9, 0.9, 1], [0.5, 0.5, 1], [1, 1, 1]],
    earth: [[0.6, 0.4, 0.2], [0.4, 0.3, 0.1], [0.5, 0.5, 0.3], [0.3, 0.2, 0.1]],
  };
  const cs = colorSets[type] || colorSets.fire;

  for (let i = 0; i < count; i++) {
    // Start near crystal ball center
    const angle = Math.random() * Math.PI * 2;
    const radius = 0.2 + Math.random() * 0.3;
    positions[i * 3] = Math.cos(angle) * radius;
    positions[i * 3 + 1] = 1.5 + Math.random() * 0.5;
    positions[i * 3 + 2] = Math.sin(angle) * radius;

    // Velocities depend on element
    if (type === 'fire') {
      velocities[i * 3] = (Math.random() - 0.5) * 1.5;
      velocities[i * 3 + 1] = 2 + Math.random() * 3; // rise fast
      velocities[i * 3 + 2] = (Math.random() - 0.5) * 1.5;
    } else if (type === 'water') {
      velocities[i * 3] = (Math.random() - 0.5) * 2;
      velocities[i * 3 + 1] = -1 - Math.random() * 2; // fall like rain
      velocities[i * 3 + 2] = (Math.random() - 0.5) * 2;
    } else if (type === 'lightning') {
      velocities[i * 3] = (Math.random() - 0.5) * 4;
      velocities[i * 3 + 1] = (Math.random() - 0.5) * 4; // chaotic
      velocities[i * 3 + 2] = (Math.random() - 0.5) * 4;
    } else { // earth
      velocities[i * 3] = (Math.random() - 0.5) * 1;
      velocities[i * 3 + 1] = 0.5 + Math.random(); // gentle rise
      velocities[i * 3 + 2] = (Math.random() - 0.5) * 1;
    }

    const c = cs[Math.floor(Math.random() * cs.length)];
    colors[i * 3] = c[0];
    colors[i * 3 + 1] = c[1];
    colors[i * 3 + 2] = c[2];
    sizes[i] = type === 'lightning' ? 8 + Math.random() * 12 : 6 + Math.random() * 8;
  }

  geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
  geo.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

  const mat = new THREE.PointsMaterial({
    size: 0.12,
    vertexColors: true,
    transparent: true,
    opacity: 0.9,
    blending: THREE.AdditiveBlending,
    depthWrite: false,
    sizeAttenuation: true,
  });

  elementParticles = new THREE.Points(geo, mat);
  elementParticleData = { velocities, startTime: Date.now(), duration, type };
  scene.add(elementParticles);

  // Auto-cleanup
  setTimeout(() => {
    if (elementParticles) {
      scene.remove(elementParticles);
      elementParticles.geometry.dispose();
      elementParticles.material.dispose();
      elementParticles = null;
      elementParticleData = null;
    }
  }, duration + 500);
}

// ===== TIKTOK EVENT HANDLERS =====
function handleViewerJoin(data) {
  const uid = data.uniqueId || data.id || 'anon_' + Date.now();
  const nick = data.nickname || uid;
  const pic = data.profilePic || data.profilePictureUrl || '';
  if (!viewers.has(uid)) {
    viewers.set(uid, { uniqueId: uid, nickname: nick, zodiac: null, score: 0, readingsCount: 0, lastActive: Date.now(), profilePic: pic, firstSeen: Date.now(), readingHistory: [], chatCount: 0, lastReading: null, giftHistory: [], isFollower: data.isFollower || false, totalGifted: 0, _persistedReadings: 0, _persistedDiamonds: 0, _persistedSessions: 0, _isReturning: false });
    document.getElementById('viewerCount').textContent = viewers.size;
    addNotification(`<strong>${nick}</strong> memasuki dunia mistis`);
    viewers.get(uid).score += 1;
    updateLeaderboard();
    // Fire-and-forget: load persisted data from Supabase
    loadPersistedViewer(uid);
  } else {
    // Update profile pic if we didn't have it before
    const v = viewers.get(uid);
    if (!v.profilePic && pic) v.profilePic = pic;
  }
  refreshOrbs();
  trackEvent();

  // Voice greeting batch
  joinBatch.push({ nickname: nick, uniqueId: uid });
  if (joinBatchTimer) clearTimeout(joinBatchTimer);
  joinBatchTimer = setTimeout(flushJoinBatch, 8000);
}

function handleLike(data) {
  const uid = data.uniqueId || data.id || '';
  const count = Math.min(data.likeCount || 1, 3);
  if (viewers.has(uid)) {
    viewers.get(uid).score += count;
    viewers.get(uid).lastActive = Date.now();
  }
  addCrystalEnergy(count);
  updateLeaderboard();
  trackEvent();

  // Glow the viewer's orb
  const orb = viewerOrbs.get(uid);
  if (orb) {
    orb.orbMat.opacity = 1.0;
    orb.photoSprite.scale.set(0.42, 0.42, 1);
    setTimeout(() => { orb.orbMat.opacity = 0.9; orb.photoSprite.scale.set(0.35, 0.35, 1); }, 500);
  }
}

function handleChat(data) {
  const uid = data.uniqueId || data.id || '';
  const nick = data.nickname || uid;
  const pic = data.profilePic || data.profilePictureUrl || '';
  const comment = (data.comment || '').trim();
  if (!comment) return;

  // Ensure viewer exists
  if (!viewers.has(uid)) {
    viewers.set(uid, { uniqueId: uid, nickname: nick, zodiac: null, score: 0, readingsCount: 0, lastActive: Date.now(), profilePic: pic, firstSeen: Date.now(), readingHistory: [], chatCount: 0, lastReading: null, giftHistory: [], isFollower: false, totalGifted: 0 });
    document.getElementById('viewerCount').textContent = viewers.size;
  }
  const viewer = viewers.get(uid);
  viewer.lastActive = Date.now();
  viewer.chatCount = (viewer.chatCount || 0) + 1;
  if (!viewer.profilePic && pic) viewer.profilePic = pic;
  trackEvent();

  // Log chat to conversation log
  conversationLog.push({ type: 'viewer_chat', name: nick, summary: comment.slice(0, 80), timestamp: Date.now() });
  if (conversationLog.length > MAX_CONVERSATION_LOG) conversationLog.shift();

  // Check for birthday/zodiac ‚Äî store zodiac + Eyang gives short reading
  const bday = detectBirthday(comment);
  if (bday) {
    viewer.zodiac = bday.zodiac;
    viewer.score += 3;
    viewer.pendingRequest = { type: 'zodiac', comment, time: Date.now() };
    const zData = ZODIAC_DATA[bday.zodiac];
    addNotification(`<strong>${nick}</strong> zodiak ${zData?.symbol || ''} ${bday.zodiac.toUpperCase()}! Eyang melihat aura mu...`, 'zodiac');
    // Log zodiac set
    conversationLog.push({ type: 'viewer_zodiac', name: nick, summary: bday.zodiac, timestamp: Date.now() });
    if (conversationLog.length > MAX_CONVERSATION_LOG) conversationLog.shift();
    // Eyang gives short zodiac reading (free)
    queueVoiceEvent('mystic_zodiac_reply', {
      name: nick, viewerId: uid,
      zodiac: bday.zodiac,
      symbol: zData?.symbol || '',
      element: zData?.element || '',
      comment
    }, 2);
    showViewerFocus(uid, nick, `${zData?.symbol || ''} ${bday.zodiac.toUpperCase()}`);
    updateLeaderboard();
    refreshOrbs();
    return;
  }

  // Check for jodoh/love ‚Äî Eyang replies + store pending for in-depth tarot if gift
  const lower = comment.toLowerCase();
  if (lower.includes('jodoh') || lower.includes('love') || lower.includes('match') || lower.includes('cinta') || lower.includes('pasangan')) {
    viewer.score += 2;
    viewer.pendingRequest = { type: 'jodoh', comment, time: Date.now() };
    addNotification(`<strong>${nick}</strong> mau cek jodoh! Eyang lihat...`, 'zodiac');
    queueVoiceEvent('mystic_jodoh_reply', { name: nick, viewerId: uid, zodiac: viewer.zodiac || null, comment }, 2);
    showViewerFocus(uid, nick, 'üíï Jodoh');
    updateLeaderboard();
    return;
  }

  // Check for question ‚Äî Eyang answers + store pending for in-depth if gift
  if (comment.endsWith('?') || lower.startsWith('tanya') || lower.startsWith('soalan')
    || lower.includes('gimana') || lower.includes('kapan') || lower.includes('apakah')) {
    viewer.score += 1;
    viewer.pendingRequest = { type: 'question', comment, time: Date.now() };
    addNotification(`<strong>${nick}</strong> punya pertanyaan... Eyang jawab!`, 'zodiac');
    queueVoiceEvent('mystic_question_reply', { name: nick, viewerId: uid, question: comment }, 2);
    showViewerFocus(uid, nick, '‚ùì Pertanyaan');
    updateLeaderboard();
    return;
  }

  // Check for karir/career/rezeki ‚Äî Eyang replies + store pending for in-depth if gift
  if (lower.includes('karir') || lower.includes('career') || lower.includes('kerja') || lower.includes('rezeki') || lower.includes('bisnis') || lower.includes('usaha')) {
    viewer.score += 1;
    viewer.pendingRequest = { type: 'career', comment, time: Date.now() };
    addNotification(`<strong>${nick}</strong> mau tahu soal karir! Eyang lihat...`, 'zodiac');
    queueVoiceEvent('mystic_career_reply', { name: nick, viewerId: uid, question: comment }, 2);
    showViewerFocus(uid, nick, 'üíº Karir');
    updateLeaderboard();
    return;
  }

  // Regular chat ‚Äî gifters always get reply, others when host is free
  viewer.score += 1;
  addNotification(`<strong>${nick}</strong>: ${comment}`);

  const isGifter = (viewer.totalGifted || 0) > 0;
  const hasQuestion = comment.includes('?') || lower.includes('gimana') || lower.includes('kenapa')
    || lower.includes('kapan') || lower.includes('siapa') || lower.includes('apa') || lower.includes('bagaimana')
    || lower.includes('berapa') || lower.includes('dimana') || lower.includes('boleh');

  if (isGifter) {
    // Gift givers ALWAYS get a voice reply to their comments
    queueVoiceEvent('mystic_chat_reply', {
      name: nick, viewerId: uid,
      comment,
      diamonds: viewer.totalGifted,
      zodiac: viewer.zodiac || null,
      isGifter: true
    }, 3);
    showViewerFocus(uid, nick, 'üíé VIP Chat');
  } else if (hasQuestion) {
    // Anyone with a question gets a reply (when host can fit it in)
    queueVoiceEvent('mystic_chat_reply', {
      name: nick, viewerId: uid,
      comment,
      diamonds: 0,
      zodiac: viewer.zodiac || null,
      isGifter: false
    }, 1);
    showViewerFocus(uid, nick, 'üí¨ Chat');
  }

  updateLeaderboard();
}

function handleGift(data) {
  const uid = data.uniqueId || data.id || '';
  const nick = data.nickname || uid;
  const pic = data.profilePic || data.profilePictureUrl || '';
  const diamonds = data.diamondCount || 0;

  if (!viewers.has(uid)) {
    viewers.set(uid, { uniqueId: uid, nickname: nick, zodiac: null, score: 0, readingsCount: 0, lastActive: Date.now(), profilePic: pic, firstSeen: Date.now(), readingHistory: [], chatCount: 0, lastReading: null, giftHistory: [], isFollower: false, totalGifted: 0 });
  }
  const viewer = viewers.get(uid);
  viewer.lastActive = Date.now();
  if (!viewer.profilePic && pic) viewer.profilePic = pic;
  viewer.totalGifted = (viewer.totalGifted || 0) + diamonds;
  totalGiftsReceived += diamonds;
  // Track gift history (last 3)
  viewer.giftHistory = viewer.giftHistory || [];
  viewer.giftHistory.push({ diamonds, timestamp: Date.now() });
  if (viewer.giftHistory.length > 3) viewer.giftHistory.shift();
  trackEvent();

  // Log gift to conversation log
  conversationLog.push({ type: 'viewer_gift', name: nick, summary: `gift ${diamonds}üíé`, timestamp: Date.now() });
  if (conversationLog.length > MAX_CONVERSATION_LOG) conversationLog.shift();

  // VIP gifts (500+) bypass accumulation ‚Äî trigger immediately
  if (diamonds >= 500) {
    viewer.score += 250;
    addNotification(`<strong>${nick}</strong> membuka VIP PROPHECY! (${diamonds} diamonds)`, 'gift');
    triggerGiftEffect('big');
    queueReading('vip_vision', uid, nick, { diamonds, zodiac: viewer.zodiac || null }, 5);
    updateLeaderboard();
    refreshOrbs();
    return;
  }

  // Gift accumulation ‚Äî collect small gifts over 8s window before triggering reading
  const existing = giftAccumulators.get(uid);
  if (existing) {
    // Add to existing accumulator
    existing.diamonds += diamonds;
    existing.nick = nick;
    existing.pic = pic;
    clearTimeout(existing.timer);
    // Show accumulation feedback
    addNotification(`<strong>${nick}</strong> +${diamonds}üíé (total: ${existing.diamonds}üíé)`, 'gift');
    triggerGiftEffect('small');
    viewer.score += Math.min(diamonds, 5);
    // Reset the window timer
    existing.timer = setTimeout(() => triggerAccumulatedGift(uid), GIFT_ACCUMULATE_WINDOW);
  } else {
    // Start new accumulator
    addNotification(`<strong>${nick}</strong> gift ${diamonds}üíé`, 'gift');
    triggerGiftEffect('small');
    viewer.score += Math.min(diamonds, 5);
    const acc = {
      diamonds,
      nick,
      pic,
      timer: setTimeout(() => triggerAccumulatedGift(uid), GIFT_ACCUMULATE_WINDOW),
    };
    giftAccumulators.set(uid, acc);
  }
  updateLeaderboard();
  refreshOrbs();
}

// Fire the accumulated gift as a single reading
function triggerAccumulatedGift(uid) {
  const acc = giftAccumulators.get(uid);
  if (!acc) return;
  giftAccumulators.delete(uid);

  const viewer = viewers.get(uid);
  if (!viewer) return;
  const nick = acc.nick;
  const diamonds = acc.diamonds;

  // Check per-user cooldown
  if (readingCooldowns.has(uid) && Date.now() - readingCooldowns.get(uid) < PER_USER_COOLDOWN) {
    addNotification(`<strong>${nick}</strong> terima kasih ${diamonds}üíé! Tunggu sebentar ya...`, 'gift');
    return;
  }
  readingCooldowns.set(uid, Date.now());

  // Check pending request from chat
  const pending = viewer.pendingRequest;
  const hasPending = pending && (Date.now() - pending.time < 300000);
  const readingData = { diamonds, zodiac: viewer.zodiac || null };

  if (hasPending) {
    readingData.pendingType = pending.type;
    readingData.pendingComment = pending.comment;
    viewer.pendingRequest = null;
  }

  // Determine tier based on ACCUMULATED total
  if (hasPending && pending.type === 'jodoh') {
    const allV = Array.from(viewers.values()).filter(v => v.uniqueId !== uid);
    const partner = allV.length > 0 ? allV[Math.floor(Math.random() * allV.length)] : null;
    viewer.score += Math.max(30, diamonds);
    const label = diamonds >= 100 ? 'VISI JODOH SPESIAL' : 'Cek Jodoh';
    addNotification(`<strong>${nick}</strong> ${label}! (${diamonds}üíé terkumpul)`, 'gift');
    if (diamonds >= 100) triggerGiftEffect('big');
    else if (diamonds >= 11) triggerGiftEffect('medium');
    queueReading('jodoh', uid, nick, {
      ...readingData,
      zodiac1: viewer.zodiac || 'unknown',
      partner: partner ? partner.nickname : 'seseorang misterius',
      zodiac2: partner?.zodiac || 'unknown',
    }, diamonds >= 100 ? 4 : 3);
  } else if (hasPending && pending.type === 'question') {
    viewer.score += Math.max(30, diamonds);
    addNotification(`<strong>${nick}</strong> Eyang jawab pertanyaanmu! (${diamonds}üíé terkumpul)`, 'gift');
    if (diamonds >= 100) triggerGiftEffect('big');
    else if (diamonds >= 11) triggerGiftEffect('medium');
    queueReading('question', uid, nick, { ...readingData, question: pending.comment }, diamonds >= 100 ? 4 : 3);
  } else if (hasPending && pending.type === 'career') {
    viewer.score += Math.max(30, diamonds);
    addNotification(`<strong>${nick}</strong> Ramalan karir! (${diamonds}üíé terkumpul)`, 'gift');
    if (diamonds >= 100) triggerGiftEffect('big');
    else if (diamonds >= 11) triggerGiftEffect('medium');
    queueReading('gift_reading', uid, nick, { ...readingData, focusTopic: 'karir dan rezeki', question: pending.comment }, diamonds >= 100 ? 4 : 3);
  } else if (diamonds >= 100) {
    viewer.score += 80;
    addNotification(`<strong>${nick}</strong> VISI SPESIAL! (${diamonds}üíé terkumpul)`, 'gift');
    triggerGiftEffect('big');
    queueReading('gift_reading', uid, nick, readingData, 4);
  } else if (diamonds >= 11) {
    viewer.score += 30;
    addNotification(`<strong>${nick}</strong> ramalan mendalam! (${diamonds}üíé terkumpul)`, 'gift');
    triggerGiftEffect('medium');
    queueReading('gift_reading', uid, nick, readingData, 3);
  } else {
    viewer.score += 10;
    addNotification(`<strong>${nick}</strong> ramalan pribadi! (${diamonds}üíé)`, 'gift');
    queueReading('fortune', uid, nick, readingData, 3);
  }
  updateLeaderboard();
}

function handleFollow(data) {
  const uid = data.uniqueId || data.id || '';
  const nick = data.nickname || uid;
  const pic = data.profilePic || data.profilePictureUrl || '';
  if (!viewers.has(uid)) {
    viewers.set(uid, { uniqueId: uid, nickname: nick, zodiac: null, score: 0, readingsCount: 0, lastActive: Date.now(), profilePic: pic, firstSeen: Date.now(), readingHistory: [], chatCount: 0, lastReading: null, giftHistory: [], isFollower: true, totalGifted: 0 });
  }
  const v = viewers.get(uid);
  if (!v.profilePic && pic) v.profilePic = pic;
  v.isFollower = true;
  v.score += 10;
  addNotification(`<strong>${nick}</strong> follow! Berkah mistis aktif!`, 'follow');
  updateLeaderboard();
  refreshOrbs();
  trackEvent();
}

function handleShare(data) {
  const uid = data.uniqueId || data.id || '';
  const nick = data.nickname || uid;
  const pic = data.profilePic || data.profilePictureUrl || '';
  if (!viewers.has(uid)) {
    viewers.set(uid, { uniqueId: uid, nickname: nick, zodiac: null, score: 0, readingsCount: 0, lastActive: Date.now(), profilePic: pic, firstSeen: Date.now(), readingHistory: [], chatCount: 0, lastReading: null, giftHistory: [], isFollower: false, totalGifted: 0 });
  }
  const v = viewers.get(uid);
  if (!v.profilePic && pic) v.profilePic = pic;
  v.score += 5;
  addNotification(`<strong>${nick}</strong> share! Ajak teman cek nasib bareng!`, 'follow');
  updateLeaderboard();
  trackEvent();
}

// ===== VOICE COMMENTARY SYSTEM =====
let voiceEnabled = true; // Auto-enabled for fortune reader
let voiceIsGenerating = false;
let voiceIsPlaying = false;
const voiceQueue = [];
const voiceAudioQueue = [];
const conversationLog = [];
const MAX_CONVERSATION_LOG = 20;
const MAX_VOICE_QUEUE = 4;
const VOICE_COOLDOWN = 3000;
let lastVoiceTime = 0;
let voiceSubtitleTimer = null;

function toggleVoiceCommentary() {
  voiceEnabled = !voiceEnabled;
  const btn = document.getElementById('voiceToggleBtn');
  const indicator = document.getElementById('voiceIndicator');
  btn.textContent = voiceEnabled ? 'Voice: ON' : 'Voice: OFF';
  btn.style.background = voiceEnabled ? '#9b59b6' : '#222';
  btn.style.color = voiceEnabled ? '#fff' : '#ccc';
  indicator.style.display = voiceEnabled ? 'block' : 'none';
  if (voiceEnabled) {
    unlockAudio();
    document.getElementById('voiceStatusText').textContent = 'Voice Ready';
  }
}

// ===== RICH CONTEXT HELPERS =====
function buildLiveContext() {
  const uptimeMinutes = Math.round((Date.now() - streamStartTime) / 60000);
  // Top 3 gifters
  const topGifters = Array.from(viewers.values())
    .filter(v => (v.totalGifted || 0) > 0)
    .sort((a, b) => (b.totalGifted || 0) - (a.totalGifted || 0))
    .slice(0, 3)
    .map(v => `${v.nickname}(${v.totalGifted}üíé)`);
  return {
    uptimeMinutes,
    viewerCount: viewers.size,
    totalReadings,
    totalGiftsReceived,
    crystalEnergy,
    readingQueueLength: readingQueue.length,
    readingState,
    topGifters,
  };
}

function buildViewerProfile(uid) {
  if (!uid) return null;
  const v = viewers.get(uid);
  if (!v) return null;
  const minutesInStream = Math.round((Date.now() - (v.firstSeen || Date.now())) / 60000);
  const lifetimeReadings = (v._persistedReadings || 0) + (v.readingsCount || 0);
  const lifetimeDiamonds = (v._persistedDiamonds || 0) + (v.totalGifted || 0);
  const profile = {
    name: v.nickname,
    zodiac: v.zodiac || null,
    totalGifted: v.totalGifted || 0,
    readingsCount: v.readingsCount || 0,
    chatCount: v.chatCount || 0,
    isFollower: v.isFollower || false,
    minutesInStream,
    isReturning: v._isReturning || (v.readingsCount || 0) > 0,
    lifetimeReadings,
    lifetimeDiamonds,
    sessionsAttended: (v._persistedSessions || 0) + 1,
  };
  if (v.lastReading) {
    profile.lastReading = {
      type: v.lastReading.type,
      text: (v.lastReading.text || '').slice(0, 60),
      minutesAgo: Math.round((Date.now() - v.lastReading.timestamp) / 60000),
      fromPreviousStream: !!v.lastReading._fromPreviousStream,
    };
  }
  return profile;
}

function buildConversationSummary(n) {
  const entries = conversationLog.slice(-n);
  return entries.map(e => {
    if (e.type === 'eyang_said') return `Eyang[${e.name}]: ${e.summary}`;
    if (e.type === 'viewer_chat') return `${e.name}: "${e.summary}"`;
    if (e.type === 'viewer_zodiac') return `${e.name} set zodiak ${e.summary}`;
    if (e.type === 'viewer_gift') return `${e.name} ${e.summary}`;
    if (e.type === 'reading_done') return `Reading selesai: ${e.summary}`;
    return `${e.name}: ${e.summary}`;
  });
}

function queueVoiceEvent(eventType, eventData, priority = 1) {
  if (!voiceEnabled) return;
  // During active reading (READING/REVEAL), only allow priority 3+ (gift/VIP)
  // This prevents chat replies from cutting off tarot readings
  if (readingState !== 'IDLE' && priority < 3) return;
  if (voiceQueue.length >= MAX_VOICE_QUEUE) {
    const lowIdx = voiceQueue.findIndex(q => q.priority < priority);
    if (lowIdx !== -1) voiceQueue.splice(lowIdx, 1);
    else return;
  }
  voiceQueue.push({ eventType, eventData, priority });
  processVoiceQueue();
}

async function processVoiceQueue() {
  if (voiceIsGenerating) return;
  if (voiceQueue.length === 0) return;
  if (Date.now() - lastVoiceTime < VOICE_COOLDOWN) {
    setTimeout(processVoiceQueue, VOICE_COOLDOWN - (Date.now() - lastVoiceTime));
    return;
  }

  voiceQueue.sort((a, b) => b.priority - a.priority);
  const event = voiceQueue.shift();
  voiceIsGenerating = true;
  document.getElementById('voiceStatusText').textContent = 'Generating...';

  try {
    const res = await fetch('/api/voice/generate', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        eventType: event.eventType,
        eventData: event.eventData,
        liveContext: buildLiveContext(),
        viewerProfile: buildViewerProfile(event.eventData?.viewerId),
        conversationLog: buildConversationSummary(15),
        recentContext: buildConversationSummary(5),
        room: ROOM,
        voiceId: MYSTIC_VOICE_ID
      }),
    });

    if (!res.ok) {
      console.error('Voice API error:', res.status);
      document.getElementById('voiceStatusText').textContent = 'API Error';
      // Still update fortune display with fallback text so reading doesn't get stuck
      if (readingState === 'REVEAL') {
        document.getElementById('fortuneText').textContent = 'üîÆ Energi mistis sedang kuat... bola kristal berbisik...';
        setTimeout(() => finishReading(), 8000);
      }
      return;
    }

    const text = decodeURIComponent(res.headers.get('X-Commentary-Text') || '');
    const blob = await res.blob();

    // Log Eyang's response to conversation log
    conversationLog.push({ type: 'eyang_said', name: event.eventType.replace('mystic_', ''), summary: text.slice(0, 80), timestamp: Date.now() });
    if (conversationLog.length > MAX_CONVERSATION_LOG) conversationLog.shift();
    totalVoiceCalls++;

    // Auto-reply in TikTok chat (toggle-controlled, priority 2+, rate-limited)
    sendAutoReply(text, event.priority, event.eventType);

    lastVoiceTime = Date.now();
    enqueueVoiceAudio(blob, text);

    // Update fortune display text if currently showing
    if (readingState === 'REVEAL' && text) {
      document.getElementById('fortuneText').textContent = text;

      // Detect bad/warning reading from AI response and trigger skull
      const lowerText = text.toLowerCase();
      const badKeywords = ['hati-hati', 'waspada', 'bahaya', 'peringatan', 'ancaman', 'jangan', 'hindari',
        'kelemahan', 'masalah', 'konflik', 'musuh', 'gelap', 'sial', 'buruk', 'gagal', 'kehilangan',
        'warning', 'danger', 'careful', 'avoid', 'enemy', 'dark', 'bad luck'];
      const isBadReading = badKeywords.some(kw => lowerText.includes(kw));
      if (isBadReading && !skullVisible) {
        triggerDramaticEffect('skull', 3500);
        // Don't draw a replacement card ‚Äî keep the one already drawn for consistency
      }
    }
  } catch (err) {
    console.error('Voice error:', err);
    document.getElementById('voiceStatusText').textContent = 'Error';
    // Gracefully finish reading on network/fetch errors
    if (readingState === 'REVEAL') {
      document.getElementById('fortuneText').textContent = 'üîÆ Energi mistis sedang kuat... bola kristal berbisik...';
      setTimeout(() => finishReading(), 3000);
    }
  } finally {
    voiceIsGenerating = false;
    if (voiceQueue.length > 0) setTimeout(processVoiceQueue, 500);
  }
}

function enqueueVoiceAudio(blob, text) {
  if (voiceAudioQueue.length >= 3) {
    const old = voiceAudioQueue.shift();
    URL.revokeObjectURL(old.url);
  }
  const url = URL.createObjectURL(blob);
  voiceAudioQueue.push({ url, text });
  if (!voiceIsPlaying) playNextVoice();
}

function playNextVoice() {
  if (voiceAudioQueue.length === 0) {
    voiceIsPlaying = false;
    document.getElementById('voiceStatusText').textContent = 'Voice Ready';
    document.getElementById('voiceSubtitle').style.display = 'none';
    return;
  }
  voiceIsPlaying = true;
  const item = voiceAudioQueue.shift();

  const subtitleEl = document.getElementById('voiceSubtitle');
  // Hide subtitle during readings ‚Äî fortuneDisplay already shows the text
  if (readingState === 'REVEAL') {
    subtitleEl.style.display = 'none';
  } else {
    subtitleEl.textContent = item.text;
    subtitleEl.style.display = 'block';
  }
  document.getElementById('voiceStatusText').textContent = 'Speaking...';
  document.getElementById('voiceSpeakerIcon').textContent = '\uD83D\uDD0A';

  const audio = new Audio(item.url);
  audio.volume = 0.85;
  audio.onended = () => {
    URL.revokeObjectURL(item.url);
    document.getElementById('voiceSpeakerIcon').textContent = '\uD83C\uDFA4';
    clearTimeout(voiceSubtitleTimer);
    voiceSubtitleTimer = setTimeout(() => subtitleEl.style.display = 'none', 1000);
    // If no more audio queued and reading is waiting, finish it
    if (voiceAudioQueue.length === 0 && readingWaitingForVoice) {
      finishReading();
    }
    playNextVoice();
  };
  audio.onerror = () => { URL.revokeObjectURL(item.url); playNextVoice(); };
  audio.play().catch(() => playNextVoice());
}

// ===== VIEWER JOIN BATCHING =====
const joinBatch = [];
let joinBatchTimer = null;
let lastJoinGreetTime = 0;
const JOIN_GREET_COOLDOWN = 45000; // 45s between welcome batches
// inviteTimer removed ‚Äî now part of idle chatter rotation

function flushJoinBatch() {
  if (joinBatch.length === 0) return;
  if (!voiceEnabled) { joinBatch.length = 0; return; }
  if (Date.now() - lastJoinGreetTime < JOIN_GREET_COOLDOWN) { joinBatch.length = 0; return; }
  // Skip welcome if there's an active reading or queue ‚Äî prioritize readings
  if (readingState !== 'IDLE' || readingQueue.length > 0) { joinBatch.length = 0; return; }
  // Skip if voice is busy generating/playing
  if (voiceIsGenerating || voiceIsPlaying) { joinBatch.length = 0; return; }

  const batch = joinBatch.splice(0);
  lastJoinGreetTime = Date.now();

  const names = batch.map(v => v.nickname);
  const nameStr = names.length <= 4 ? names.join(', ') : names.slice(0, 3).join(', ') + ` dan ${names.length - 3} lagi`;

  queueVoiceEvent('mystic_viewers_welcome', { count: batch.length, names: nameStr, queueLength: readingQueue.length }, 1);
}

// ===== ANIMATION LOOP =====
const clock = new THREE.Clock();
let elapsedTotal = 0;

function animate() {
  requestAnimationFrame(animate);
  const dt = Math.min(clock.getDelta(), 0.1);
  elapsedTotal += dt;

  // Auto camera sway
  if (autoCamEnabled && !manualCamera) {
    const t = elapsedTotal * 0.05;
    camera.position.x = Math.sin(t) * 0.5;
    camera.position.z = 5 + Math.cos(t) * 0.3;
    camera.lookAt(0, 1, 0);
  }
  controls.update();

  // Candle flicker
  candles.forEach((c, i) => {
    const flicker = 0.4 + Math.sin(elapsedTotal * 5 + i * 1.5) * 0.15;
    c.flame.scale.setScalar(flicker * 2);
    candleLights[i].intensity = 0.5 + Math.sin(elapsedTotal * 4 + i * 2) * 0.2;
  });

  // Crystal ball pulse
  if (readingState === 'READING' || readingState === 'REVEAL') {
    const p = Math.sin(elapsedTotal * 3) * 0.5 + 0.5;
    crystalInner.scale.setScalar(0.8 + p * 0.3);
    crystalLight.intensity = 3 + p * 2;
  } else {
    crystalInner.scale.setScalar(0.9 + Math.sin(elapsedTotal * 1.5) * 0.05);
  }

  // Tarot card ring rotation ‚Äî only Major Arcana (first 22) orbit
  const spreadSprites = new Set(drawnSpread.map(dc => dc?.sprite));
  for (let i = 0; i < 22; i++) {
    const s = tarotSprites[i];
    if (spreadSprites.has(s) || (drawnCard && drawnCard.sprite === s)) continue;
    const angle = s.userData.baseAngle + elapsedTotal * 0.08;
    const r = 3.0;
    s.position.set(Math.cos(angle) * r, 2.2 + Math.sin(elapsedTotal * 0.4 + i * 0.5) * 0.08, Math.sin(angle) * r);
  }

  // Drawn card(s) animation ‚Äî fly to position (supports spread)
  const cardsToAnimate = drawnSpread.length > 0 ? drawnSpread : (drawnCard ? [drawnCard] : []);
  for (const dc of cardsToAnimate) {
    if (!dc) continue;
    dc.animProgress = Math.min(1, dc.animProgress + dt * 1.5);
    const t = dc.animProgress;
    const ease = 1 - Math.pow(1 - t, 3);
    dc.sprite.position.lerpVectors(dc.startPos, dc.targetPos, ease);
    dc.sprite.scale.lerpVectors(dc.startScale, dc.targetScale, ease);
    if (t >= 1) {
      dc.sprite.position.y = dc.targetPos.y + Math.sin(elapsedTotal * 2) * 0.05;
    }
  }
  if (cardsToAnimate.length > 0) {
    // Auto dismiss ‚Äî but keep cards visible during reading
    if (readingState === 'IDLE') {
      drawnCardTimer -= dt;
      if (drawnCardTimer <= 0) {
        dismissDrawnCard();
      }
    }
  }

  // Stars rotation
  stars.rotation.y += dt * 0.005;
  stars.rotation.x += dt * 0.002;

  // Particles
  const posArr = particles.geometry.attributes.position.array;
  const speedMult = (readingState === 'READING') ? 2.0 : 1.0;
  for (let i = 0; i < particleCount; i++) {
    const angle = elapsedTotal * 0.3 + i * 0.5;
    posArr[i * 3] += Math.cos(angle) * 0.002 * speedMult;
    posArr[i * 3 + 1] += particleVel[i * 3 + 1] * dt * speedMult;
    posArr[i * 3 + 2] += Math.sin(angle) * 0.002 * speedMult;
    // Reset if too high
    if (posArr[i * 3 + 1] > 3.0) {
      const a = Math.random() * Math.PI * 2;
      const r = 0.3 + Math.random() * 1.0;
      posArr[i * 3] = Math.cos(a) * r;
      posArr[i * 3 + 1] = 0.5;
      posArr[i * 3 + 2] = Math.sin(a) * r;
    }
  }
  particles.geometry.attributes.position.needsUpdate = true;

  // Viewer orbs bob
  viewerOrbs.forEach((orb) => {
    const r = 2.5;
    orb.mesh.position.x = Math.cos(orb.angle + elapsedTotal * 0.08) * r;
    orb.mesh.position.z = Math.sin(orb.angle + elapsedTotal * 0.08) * r;
    orb.mesh.position.y = 1.6 + Math.sin(elapsedTotal * 2 + orb.bobOffset) * 0.1;
  });

  // 3D Element particles animation
  if (elementParticles && elementParticleData) {
    const pos = elementParticles.geometry.attributes.position.array;
    const vel = elementParticleData.velocities;
    const elapsed = (Date.now() - elementParticleData.startTime) / 1000;
    const progress = elapsed / (elementParticleData.duration / 1000);
    const fade = progress < 0.2 ? progress / 0.2 : progress > 0.7 ? (1 - progress) / 0.3 : 1;
    elementParticles.material.opacity = fade * 0.9;

    for (let i = 0; i < pos.length / 3; i++) {
      pos[i * 3] += vel[i * 3] * dt;
      pos[i * 3 + 1] += vel[i * 3 + 1] * dt;
      pos[i * 3 + 2] += vel[i * 3 + 2] * dt;

      if (elementParticleData.type === 'fire') {
        vel[i * 3] += (Math.random() - 0.5) * 2 * dt; // turbulence
        vel[i * 3 + 1] *= 0.995; // slow down rising
      } else if (elementParticleData.type === 'water') {
        vel[i * 3] *= 0.98; // slow horizontal
        pos[i * 3 + 1] = Math.max(0.5, pos[i * 3 + 1]); // floor
      } else if (elementParticleData.type === 'lightning') {
        vel[i * 3] = (Math.random() - 0.5) * 6; // chaotic jitter
        vel[i * 3 + 1] = (Math.random() - 0.5) * 6;
        vel[i * 3 + 2] = (Math.random() - 0.5) * 6;
      }
    }
    elementParticles.geometry.attributes.position.needsUpdate = true;
  }

  // 3D Skull animation
  if (skullMixer) skullMixer.update(dt);
  if (skullVisible && skullModel) {
    skullElapsed += dt;
    // Scale up in first 0.6s
    if (skullElapsed < 0.6) {
      const s = (skullElapsed / 0.6) * 1.2;
      skullModel.scale.setScalar(s);
    } else {
      skullModel.scale.setScalar(1.2);
    }
    // Slow rotation
    skullModel.rotation.y += dt * 0.8;
    // Gentle bob
    skullModel.position.y = 0.3 + Math.sin(elapsedTotal * 2) * 0.1;
    // Emissive pulse
    skullModel.traverse(child => {
      if (child.isMesh) {
        child.material.emissiveIntensity = 0.3 + Math.sin(elapsedTotal * 4) * 0.2;
      }
    });
    // Hide after duration
    if (skullElapsed >= skullDuration) {
      hideSkull();
    }
  }

  // Flood counter reset (every 60s, reset counter)
  eventCounterTimer += dt;
  if (eventCounterTimer >= 60) {
    eventCounterTimer = 0;
    eventsPerMinute = 0;
    if (floodMode) {
      floodMode = false;
      document.getElementById('floodStatus').classList.remove('show');
    }
  }

  // Idle chatter ‚Äî Eyang talks when room is quiet, rotates through different topics
  if (voiceEnabled) {
    engageTimer -= dt;
    if (engageTimer <= 0 && Date.now() - lastEngageTime > ENGAGE_COOLDOWN) {
      engageTimer = 35 + Math.random() * 20; // 35-55s between idle chats
      if (readingQueue.length === 0 && readingState === 'IDLE' && !voiceIsGenerating && !voiceIsPlaying) {
        lastEngageTime = Date.now();
        const viewerNames = Array.from(viewers.values()).slice(0, 5).map(v => v.nickname);
        const hasGifters = Array.from(viewers.values()).some(v => (v.totalGifted || 0) > 0);

        // Rotate through different idle chat types
        const chatTypes = [
          'mystic_idle_explain',    // explain how readings work
          'mystic_idle_tarot',      // explain a random tarot card (upright/reversed)
          'mystic_idle_atmosphere', // comment on crystal ball / mystical atmosphere
          'mystic_ask_engage',      // ask viewers to send gifts
          'mystic_idle_tarot',      // explain another tarot card
          'mystic_idle_wisdom',     // share mystic wisdom / life advice
          'mystic_idle_tease',      // tease a random viewer
          'mystic_invite_friends',  // invite friends
        ];
        const type = chatTypes[idleChatType % chatTypes.length];
        idleChatType++;

        const idleEventData = {
          viewerCount: viewers.size,
          queueLength: readingQueue.length,
          viewerNames: viewerNames.join(', '),
          hasGifters,
          totalReadings,
          crystalEnergy,
        };

        // For tarot explanation, pick a random Major Arcana and show it
        if (type === 'mystic_idle_tarot') {
          const cardIdx = Math.floor(Math.random() * 22); // Major Arcana only
          const card = TAROT_CARDS[cardIdx];
          const isReversed = Math.random() < 0.4;
          const meaning = TAROT_MEANINGS[cardIdx];
          idleEventData.tarotCard = card.name;
          idleEventData.tarotPosition = isReversed ? 'Terbalik (Reversed)' : 'Tegak (Upright)';
          idleEventData.tarotMeaning = meaning ? (isReversed ? meaning.reversed : meaning.upright) : '';
          idleEventData.tarotMeaningOpposite = meaning ? (isReversed ? meaning.upright : meaning.reversed) : '';
          // Draw the card visually
          drawTarotCard(cardIdx, isReversed ? 'reversed' : 'upright');
        }

        // For tease, pick a random viewer
        if (type === 'mystic_idle_tease' && viewers.size > 0) {
          const allV = Array.from(viewers.values());
          const v = allV[Math.floor(Math.random() * allV.length)];
          idleEventData.targetName = v.nickname;
          idleEventData.targetZodiac = v.zodiac || null;
        }

        queueVoiceEvent(type, idleEventData, 1);
      }
    }
  }

  // Free random readings ‚Äî pick a random viewer and give them a fortune
  if (voiceEnabled) {
    freeReadingTimer -= dt;
    if (freeReadingTimer <= 0) {
      freeReadingTimer = FREE_READING_INTERVAL + Math.random() * 30;
      if (viewers.size > 0 && readingState === 'IDLE' && readingQueue.length === 0 && !voiceIsGenerating && !voiceIsPlaying) {
        const allViewers = Array.from(viewers.values());
        const v = allViewers[Math.floor(Math.random() * allViewers.length)];
        const zodiac = v.zodiac || null;
        if (zodiac) {
          addNotification(`Eyang tertarik dengan aura <strong>${v.nickname}</strong>...`, 'zodiac');
          queueReading('zodiac', v.uniqueId, v.nickname, { zodiac }, 2);
        } else {
          addNotification(`Eyang merasakan sesuatu tentang <strong>${v.nickname}</strong>...`, 'zodiac');
          queueReading('fortune', v.uniqueId, v.nickname, {}, 2);
        }
      }
    }
  }

  // Auto-play
  if (autoPlay) {
    autoPlayTimer -= dt;
    if (autoPlayTimer <= 0) {
      autoPlayTimer = 3 + Math.random() * 5;
      simulateRandomEvent();
    }
  }

  renderer.render(scene, camera);
}

// ===== AUTO-PLAY SIMULATION =====
const TEST_NAMES = ['Aisyah', 'Haziq', 'Mei Ling', 'Arjun', 'Nurul', 'Danish', 'Siti', 'Yuki', 'Amir', 'Priya'];
const TEST_CHATS = [
  '15 mac', 'aries', 'jodoh?', 'what is my fortune?', 'hello!',
  'scorpio', '22 dis', 'love prediction?', 'lucky number?', '10 jul',
  'taurus', 'soalan: kerja apa sesuai?', 'gemini', '5 mei', 'cinta?',
];
let testIdx = 0;

function simulateRandomEvent() {
  const roll = Math.random();
  if (roll < 0.3) {
    // New viewer
    const id = 'test_' + (testIdx++);
    const nick = TEST_NAMES[Math.floor(Math.random() * TEST_NAMES.length)];
    handleViewerJoin({ uniqueId: id, nickname: nick + '_' + id.slice(-3) });
  } else if (roll < 0.55) {
    // Like
    const v = getRandomViewer();
    if (v) handleLike({ uniqueId: v.uniqueId, nickname: v.nickname, likeCount: 1 + Math.floor(Math.random() * 3) });
  } else if (roll < 0.8) {
    // Chat
    const v = getRandomViewer();
    if (v) {
      const chat = TEST_CHATS[Math.floor(Math.random() * TEST_CHATS.length)];
      handleChat({ uniqueId: v.uniqueId, nickname: v.nickname, comment: chat });
    }
  } else if (roll < 0.92) {
    // Gift
    const v = getRandomViewer();
    if (v) {
      const diamonds = [5, 10, 30, 50, 100, 200, 500][Math.floor(Math.random() * 7)];
      handleGift({ uniqueId: v.uniqueId, nickname: v.nickname, diamondCount: diamonds, giftName: 'Rose', repeatCount: 1 });
    }
  } else {
    // Follow
    const v = getRandomViewer();
    if (v) handleFollow({ uniqueId: v.uniqueId, nickname: v.nickname });
  }
}

function getRandomViewer() {
  const all = Array.from(viewers.values());
  return all.length > 0 ? all[Math.floor(Math.random() * all.length)] : null;
}

// ===== KEYBOARD DEBUG =====
document.addEventListener('keydown', (e) => {
  const key = e.key.toUpperCase();
  switch (key) {
    case 'T': window._debug('addViewer'); break;
    case 'D': window._debug('add10'); break;
    case 'L': window._debug('like'); break;
    case 'B': window._debug('gift'); break;
    case 'Z': window._debug('zodiac'); break;
    case 'J': window._debug('jodoh'); break;
    case 'Q': window._debug('question'); break;
    case 'V': window._debug('autocam'); break;
    case 'A': window._debug('auto'); break;
    case 'S': window._debug('skull'); break;
    case 'F': window._debug('fire'); break;
    case 'W': window._debug('water'); break;
    case 'E': window._debug('lightning'); break;
  }
});

window._debug = function(action) {
  switch (action) {
    case 'addViewer': {
      const id = 'test_' + (testIdx++);
      const nick = TEST_NAMES[Math.floor(Math.random() * TEST_NAMES.length)] + '_' + id.slice(-3);
      handleViewerJoin({ uniqueId: id, nickname: nick });
      break;
    }
    case 'add10': {
      for (let i = 0; i < 10; i++) {
        const id = 'test_' + (testIdx++);
        const nick = TEST_NAMES[Math.floor(Math.random() * TEST_NAMES.length)] + '_' + id.slice(-3);
        handleViewerJoin({ uniqueId: id, nickname: nick });
      }
      break;
    }
    case 'like': {
      const v = getRandomViewer();
      if (v) handleLike({ uniqueId: v.uniqueId, nickname: v.nickname, likeCount: 2 });
      break;
    }
    case 'gift': {
      if (!window._giftTier) window._giftTier = 0;
      const tiers = [5, 30, 150, 500];
      const diamonds = tiers[window._giftTier % tiers.length];
      window._giftTier++;
      const v = getRandomViewer();
      if (v) handleGift({ uniqueId: v.uniqueId, nickname: v.nickname, diamondCount: diamonds, giftName: 'Gift', repeatCount: 1 });
      break;
    }
    case 'zodiac': {
      const v = getRandomViewer();
      const signs = Object.keys(ZODIAC_DATA);
      const sign = signs[Math.floor(Math.random() * signs.length)];
      if (v) {
        v.zodiac = sign;
        queueReading('zodiac', v.uniqueId, v.nickname, { zodiac: sign, date: '15 Mac' }, 3);
        addNotification(`[DEBUG] Zodiac reading: ${v.nickname} = ${sign}`, 'zodiac');
      }
      break;
    }
    case 'jodoh': {
      const all = Array.from(viewers.values());
      if (all.length >= 2) {
        const a = all[0], b = all[1];
        queueReading('jodoh', a.uniqueId, a.nickname, {
          partner: b.nickname, zodiac1: a.zodiac || 'aries', zodiac2: b.zodiac || 'pisces'
        }, 3);
        addNotification(`[DEBUG] Jodoh: ${a.nickname} + ${b.nickname}`, 'zodiac');
      }
      break;
    }
    case 'question': {
      const v = getRandomViewer();
      if (v) {
        queueReading('question', v.uniqueId, v.nickname, { question: 'Apa nasib saya hari ini?' }, 2);
        addNotification(`[DEBUG] Question from ${v.nickname}`, 'zodiac');
      }
      break;
    }
    case 'autocam': {
      autoCamEnabled = !autoCamEnabled;
      manualCamera = !autoCamEnabled;
      controls.enabled = !autoCamEnabled;
      addNotification(autoCamEnabled ? 'Auto Camera ON' : 'Auto Camera OFF');
      break;
    }
    case 'auto': {
      autoPlay = !autoPlay;
      autoPlayTimer = 0;
      addNotification(autoPlay ? 'Auto-play ON' : 'Auto-play OFF');
      break;
    }
    case 'skull': {
      triggerDramaticEffect('skull', 4000);
      addNotification('[DEBUG] Skull effect!');
      break;
    }
    case 'fire': {
      triggerDramaticEffect('fire', 3000);
      addNotification('[DEBUG] Fire effect!');
      break;
    }
    case 'water': {
      triggerDramaticEffect('water', 3000);
      addNotification('[DEBUG] Water effect!');
      break;
    }
    case 'lightning': {
      triggerDramaticEffect('lightning', 3000);
      addNotification('[DEBUG] Lightning effect!');
      break;
    }
  }
};

window._toggleVoice = toggleVoiceCommentary;

// ===== SOCKET.IO =====
const params = new URLSearchParams(window.location.search);
const ROOM = params.get('room') || '';

let socket = null;
function connectSocket() {
  const ioScript = document.createElement('script');
  ioScript.src = '/socket.io/socket.io.js';
  ioScript.onload = () => {
    socket = io({ query: { room: ROOM } });

    socket.on('like', (data) => handleLike(data));
    socket.on('chat', (data) => handleChat(data));
    socket.on('gift', (data) => handleGift(data));
    socket.on('follow', (data) => handleFollow(data));
    socket.on('share', (data) => handleShare(data));
    socket.on('viewer-join', (data) => handleViewerJoin(data));
    socket.on('room-stats', (data) => {
      const vc = data.viewerCount || viewers.size;
      document.getElementById('viewerCount').textContent = vc;
      if (vc > _peakViewers) _peakViewers = vc;
    });

    console.log('Socket connected, room:', ROOM || '(default)');
  };
  document.head.appendChild(ioScript);
}

// ===== INIT =====
function init() {
  // Loading progress
  const progress = document.getElementById('progressFill');
  const loadText = document.getElementById('loadingText');
  let pct = 0;

  const steps = [
    { text: 'Membangunkan bola kristal...', pct: 20 },
    { text: 'Menyusun simbol zodiak...', pct: 40 },
    { text: 'Mengalirkan energi mistis...', pct: 60 },
    { text: 'Memanggil Nurin...', pct: 80 },
    { text: 'Siap!', pct: 100 },
  ];

  let stepIdx = 0;
  const loadInterval = setInterval(() => {
    if (stepIdx >= steps.length) {
      clearInterval(loadInterval);
      setTimeout(() => {
        document.getElementById('loadingScreen').classList.add('hidden');
        // Enable voice indicator
        document.getElementById('voiceIndicator').style.display = 'block';
        document.getElementById('voiceToggleBtn').textContent = 'Voice: ON';
        document.getElementById('voiceToggleBtn').style.background = '#9b59b6';
        document.getElementById('voiceToggleBtn').style.color = '#fff';
      }, 500);
      return;
    }
    const step = steps[stepIdx++];
    loadText.textContent = step.text;
    progress.style.width = step.pct + '%';
  }, 400);

  connectSocket();
  animate();
  scheduleSave();
}

// ===== PERSISTENCE FUNCTIONS =====

// Load persisted viewer data from Supabase (fire-and-forget)
async function loadPersistedViewer(uid) {
  try {
    const res = await fetch('/api/fortuneteller/viewer/load', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ uniqueId: uid }),
    });
    const { viewer: pv } = await res.json();
    if (!pv) return; // New viewer, no persisted data

    const v = viewers.get(uid);
    if (!v) return;

    // Restore persisted fields
    if (pv.zodiac && !v.zodiac) v.zodiac = pv.zodiac;
    if (pv.is_follower) v.isFollower = true;
    v._persistedReadings = pv.total_readings || 0;
    v._persistedDiamonds = pv.total_diamonds || 0;
    v._persistedSessions = pv.total_sessions || 0;
    v._isReturning = (pv.total_sessions || 0) > 0;

    // Merge reading history from DB (older first, cap at 5)
    if (Array.isArray(pv.reading_history) && pv.reading_history.length > 0) {
      const dbHistory = pv.reading_history.slice(-5).map(r => ({ ...r, _fromPreviousStream: true }));
      v.readingHistory = [...dbHistory, ...v.readingHistory].slice(-5);
    }

    // Restore last reading from previous stream
    if (pv.last_reading && !v.lastReading) {
      v.lastReading = { ...pv.last_reading, _fromPreviousStream: true };
    }

    if (v._isReturning) {
      console.log(`üîÆ Returning viewer: ${v.nickname} (${v._persistedReadings} readings, ${v._persistedSessions} sessions)`);
    }
  } catch (err) {
    // Graceful fallback ‚Äî persistence is best-effort
    console.warn('FT load viewer failed:', err.message);
  }
}

// Batch save viewers to Supabase
async function batchSaveViewers() {
  const toSave = [];
  for (const [uid, v] of viewers) {
    // Only save viewers with meaningful activity
    if ((v.score || 0) <= 0 && (v.readingsCount || 0) <= 0 && (v.totalGifted || 0) <= 0) continue;

    const lifetimeReadings = (v._persistedReadings || 0) + (v.readingsCount || 0);
    const lifetimeDiamonds = (v._persistedDiamonds || 0) + (v.totalGifted || 0);

    toSave.push({
      unique_id: uid,
      nickname: v.nickname || uid,
      profile_pic: v.profilePic || '',
      zodiac: v.zodiac || null,
      total_diamonds: lifetimeDiamonds,
      total_readings: lifetimeReadings,
      total_chats: (v.chatCount || 0),
      total_sessions: (v._persistedSessions || 0) + 1,
      is_follower: v.isFollower || false,
      last_reading: v.lastReading ? { type: v.lastReading.type, text: (v.lastReading.text || '').slice(0, 200), timestamp: v.lastReading.timestamp } : null,
      reading_history: (v.readingHistory || []).filter(r => !r._fromPreviousStream).slice(-5),
      gift_history: (v.giftHistory || []).slice(-10),
      last_seen_at: new Date().toISOString(),
    });
  }

  if (toSave.length === 0) return;

  try {
    const res = await fetch('/api/fortuneteller/viewer/save', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ viewers: toSave }),
    });
    if (res.ok) {
      console.log(`üíæ Saved ${toSave.length} viewer(s) to Supabase`);
    }
  } catch (err) {
    console.warn('FT save viewers failed:', err.message);
  }
}

// Save session summary
async function saveSessionSummary() {
  if (_sessionSaved) return;
  _sessionSaved = true;

  const durationMins = Math.round((Date.now() - streamStartTime) / 60000);
  const topViewers = Array.from(viewers.values())
    .sort((a, b) => (b.totalGifted || 0) - (a.totalGifted || 0))
    .slice(0, 5)
    .map(v => ({ nickname: v.nickname, uniqueId: v.uniqueId, diamonds: v.totalGifted || 0, readings: v.readingsCount || 0 }));

  const recentConvo = conversationLog.slice(-15).map(c => `${c.name || ''}: ${c.summary || c.text || ''}`).join('\n').slice(0, 2000);

  const snapshot = {};
  for (const [uid, v] of viewers) {
    snapshot[uid] = { nickname: v.nickname, score: v.score, readings: v.readingsCount, diamonds: v.totalGifted || 0 };
  }

  const sessionData = {
    room: ROOM || 'default',
    started_at: new Date(streamStartTime).toISOString(),
    ended_at: new Date().toISOString(),
    duration_mins: durationMins,
    peak_viewers: _peakViewers,
    total_viewers: viewers.size,
    total_readings: totalReadings,
    total_gifts: Math.round(totalGiftsReceived),
    total_voice: totalVoiceCalls,
    top_viewers: topViewers,
    conversation_summary: recentConvo,
    viewer_snapshot: snapshot,
  };

  try {
    const res = await fetch('/api/fortuneteller/session/save', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ session: sessionData }),
    });
    if (res.ok) console.log('üíæ Session summary saved');
  } catch (err) {
    // Fallback: try sendBeacon
    try {
      navigator.sendBeacon('/api/fortuneteller/session/save', JSON.stringify({ session: sessionData }));
    } catch (e) { /* best effort */ }
  }
}

// Schedule periodic save (every 2 minutes)
function scheduleSave() {
  _saveTimer = setInterval(() => {
    batchSaveViewers();
  }, SAVE_INTERVAL);
}

// Debounced save after reading (5s delay)
let _saveDebounceTimer = null;
function scheduleSaveDebounced() {
  if (_saveDebounceTimer) clearTimeout(_saveDebounceTimer);
  _saveDebounceTimer = setTimeout(() => batchSaveViewers(), 5000);
}

// Save on page close
window.addEventListener('beforeunload', () => {
  // Save viewers via sendBeacon
  const toSave = [];
  for (const [uid, v] of viewers) {
    if ((v.score || 0) <= 0 && (v.readingsCount || 0) <= 0 && (v.totalGifted || 0) <= 0) continue;
    toSave.push({
      unique_id: uid,
      nickname: v.nickname || uid,
      profile_pic: v.profilePic || '',
      zodiac: v.zodiac || null,
      total_diamonds: (v._persistedDiamonds || 0) + (v.totalGifted || 0),
      total_readings: (v._persistedReadings || 0) + (v.readingsCount || 0),
      total_chats: (v.chatCount || 0),
      total_sessions: (v._persistedSessions || 0) + 1,
      is_follower: v.isFollower || false,
      last_reading: v.lastReading ? { type: v.lastReading.type, text: (v.lastReading.text || '').slice(0, 200), timestamp: v.lastReading.timestamp } : null,
      reading_history: (v.readingHistory || []).filter(r => !r._fromPreviousStream).slice(-5),
      gift_history: (v.giftHistory || []).slice(-10),
      last_seen_at: new Date().toISOString(),
    });
  }
  if (toSave.length > 0) {
    navigator.sendBeacon('/api/fortuneteller/viewer/save', new Blob([JSON.stringify({ viewers: toSave })], { type: 'application/json' }));
  }
  // Save session summary
  saveSessionSummary();
});

// ===== AUTO-REPLY FUNCTION =====
function sendAutoReply(text, priority, eventType) {
  if (!autoReplyEnabled) return;
  if (priority < 2) return;
  // Skip idle/invite events
  const skipEvents = ['mystic_idle_explain', 'mystic_idle_tarot', 'mystic_idle_atmosphere', 'mystic_idle_wisdom', 'mystic_idle_tease', 'mystic_invite_friends', 'mystic_viewers_welcome', 'mystic_flood_acknowledge'];
  if (skipEvents.includes(eventType)) return;
  if (!text || text.length > 150) return;
  // Rate limit
  const now = Date.now();
  if (now - _lastAutoReplyTime < AUTO_REPLY_COOLDOWN) return;
  _lastAutoReplyTime = now;
  // Prefix + truncate
  let msg = '\u{1F52E} ' + text;
  if (msg.length > 145) msg = msg.slice(0, 142) + '...';
  // Fire-and-forget POST
  fetch('/api/chat/send', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ message: msg, room: ROOM }),
  }).catch(() => {}); // ignore errors
}

function toggleAutoReply() {
  autoReplyEnabled = !autoReplyEnabled;
  const btn = document.getElementById('autoReplyToggleBtn');
  btn.textContent = autoReplyEnabled ? 'Chat Reply: ON' : 'Chat Reply: OFF';
  btn.style.background = autoReplyEnabled ? '#27ae60' : '#222';
  btn.style.color = autoReplyEnabled ? '#fff' : '#ccc';
  console.log('Chat auto-reply:', autoReplyEnabled ? 'ON' : 'OFF');
}
window._toggleAutoReply = toggleAutoReply;

init();

</script>
</body>
</html>
