<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>TikTok Live Marathon 3D</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { background: #000; overflow: hidden; width: 100vw; height: 100vh; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; }
    #game-canvas { display: block; width: 100%; height: 100%; }

    /* Forced portrait mode (?portrait) ‚Äî centers a 9:16 frame */
    body.portrait-mode { display: flex; justify-content: center; align-items: center; }
    body.portrait-mode .game-frame { position: relative; width: min(100vw, calc(100vh * 9 / 16)); height: 100vh; overflow: hidden; }
    body.portrait-mode #game-canvas { width: 100%; height: 100%; }
    body.portrait-mode .hud { left: 0; right: 0; }
    body.portrait-mode .env-badge { left: 50%; }
    body.portrait-mode .banner-area { left: 0; right: 0; }
    body.portrait-mode .host-dashboard { width: 260px; }
    body.portrait-mode .host-dash-toggle.shifted { right: 260px; }
    body.portrait-mode .host-controls { left: 50%; }
    body.portrait-mode .game-guide { left: 0; right: 0; }
    body.portrait-mode .guide-show-btn { right: 8px; }
    body.portrait-mode .gift-flash { position: absolute; }
    body.portrait-mode .powerup-notif { left: 50%; }
    body.portrait-mode .event-notif { left: 50%; }
    body.portrait-mode .modal-overlay { position: absolute; }

    /* HUD Overlay */
    .hud { position: absolute; top: 0; left: 0; right: 0; padding: 12px 20px; display: flex; justify-content: space-between; align-items: flex-start; z-index: 100; pointer-events: none; }
    .hud-left, .hud-right { pointer-events: auto; }
    .hud-badge { padding: 6px 14px; background: rgba(0,0,0,0.7); backdrop-filter: blur(10px); border-radius: 20px; color: #fff; font-size: 14px; font-weight: 600; display: flex; align-items: center; gap: 6px; margin-bottom: 6px; }
    .live-dot { width: 8px; height: 8px; background: #fe2c55; border-radius: 50%; animation: pulse 1.5s infinite; }
    @keyframes pulse { 0%,100% { opacity: 1; } 50% { opacity: 0.4; } }

    /* Environment badge */
    .env-badge { position: absolute; top: 12px; left: 50%; transform: translateX(-50%); z-index: 100; padding: 6px 18px; background: rgba(37,244,238,0.15); border: 1px solid rgba(37,244,238,0.4); backdrop-filter: blur(10px); border-radius: 20px; color: #25f4ee; font-size: 13px; font-weight: 700; letter-spacing: 1px; text-transform: uppercase; pointer-events: none; }

    /* Podium */
    .podium { min-width: 170px; }
    .podium-title { font-size: 11px; font-weight: 700; color: #ffd700; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 6px; text-align: center; padding: 4px 12px; background: rgba(0,0,0,0.7); backdrop-filter: blur(10px); border-radius: 12px; }
    .podium-row { display: flex; align-items: center; gap: 8px; padding: 4px 12px; font-size: 12px; color: #fff; background: rgba(0,0,0,0.5); border-radius: 10px; margin-bottom: 3px; }
    .podium-medal { font-size: 16px; }
    .podium-name { flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    .podium-avatar { width: 24px; height: 24px; border-radius: 50%; object-fit: cover; border: 1px solid #fff; flex-shrink: 0; }
    .podium-dist { font-weight: 700; color: #25f4ee; font-variant-numeric: tabular-nums; }

    /* Full-width banner notification ‚Äî center of screen */
    .banner-area { position: absolute; top: 50%; left: 0; right: 0; z-index: 150; pointer-events: none; display: flex; flex-direction: column; align-items: center; gap: 6px; transform: translateY(-50%); }
    .banner { width: 90%; max-width: 500px; padding: 14px 24px; background: rgba(0,0,0,0.88); backdrop-filter: blur(14px); border-radius: 14px; color: #fff; font-size: 18px; font-weight: 700; text-align: center; line-height: 1.4; animation: bannerIn 0.35s ease-out, bannerOut 0.5s ease-in 3.2s forwards; border: 1px solid rgba(255,255,255,0.15); text-shadow: 0 1px 4px rgba(0,0,0,0.6); }
    .banner strong { color: #25f4ee; }
    .banner.gift { border-color: rgba(254,44,85,0.5); background: rgba(254,44,85,0.25); }
    .banner.gift strong { color: #fe2c55; }
    .banner.tip { border-color: rgba(37,244,238,0.4); background: rgba(37,244,238,0.15); animation: bannerIn 0.35s ease-out, bannerOut 0.5s ease-in 5.5s forwards; }
    .banner.tip strong { color: #ffd700; }
    .banner.event { border-color: rgba(255,200,0,0.5); background: rgba(255,200,0,0.2); font-size: 20px; }
    .banner.event strong { color: #ffd700; }
    @keyframes bannerIn { from { opacity: 0; transform: scale(0.9); } to { opacity: 1; transform: scale(1); } }
    @keyframes bannerOut { to { opacity: 0; transform: scale(0.95); } }

    /* Host Dashboard Panel */
    .host-dashboard { position: absolute; top: 0; right: 0; bottom: 0; width: 280px; z-index: 300; background: rgba(10,10,30,0.95); backdrop-filter: blur(16px); border-left: 1px solid rgba(255,255,255,0.1); transform: translateX(100%); transition: transform 0.3s ease; overflow-y: auto; pointer-events: auto; }
    .host-dashboard.open { transform: translateX(0); }
    body.viewer-mode .host-dashboard, body.viewer-mode .host-dash-toggle { display: none; }
    .host-dash-toggle { position: absolute; top: 50%; right: 0; z-index: 301; transform: translateY(-50%); width: 36px; height: 72px; background: rgba(0,0,0,0.8); border: 1px solid #444; border-right: none; border-radius: 10px 0 0 10px; color: #fff; font-size: 16px; cursor: pointer; display: flex; align-items: center; justify-content: center; pointer-events: auto; transition: right 0.3s ease; }
    .host-dash-toggle.shifted { right: 280px; }
    .dash-header { padding: 14px 16px; border-bottom: 1px solid rgba(255,255,255,0.1); display: flex; align-items: center; justify-content: space-between; }
    .dash-header h3 { color: #fff; font-size: 14px; margin: 0; }
    .dash-close { background: none; border: none; color: #888; font-size: 18px; cursor: pointer; }
    .dash-section { padding: 12px 16px; border-bottom: 1px solid rgba(255,255,255,0.06); }
    .dash-section h4 { color: #25f4ee; font-size: 11px; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 8px; }
    .dash-mount-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 6px; }
    .dash-mount-btn { padding: 8px 4px; background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.1); border-radius: 8px; color: #fff; font-size: 11px; cursor: pointer; text-align: center; transition: all 0.2s; }
    .dash-mount-btn:hover { background: rgba(37,244,238,0.15); border-color: #25f4ee; }
    .dash-mount-btn:active { transform: scale(0.95); }
    .dash-mount-btn .mount-icon { font-size: 22px; display: block; margin-bottom: 2px; }
    .dash-action-list { display: flex; flex-direction: column; gap: 6px; }
    .dash-action-btn { padding: 10px 12px; background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.1); border-radius: 8px; color: #fff; font-size: 12px; font-weight: 600; cursor: pointer; text-align: left; transition: all 0.2s; display: flex; align-items: center; gap: 8px; }
    .dash-action-btn:hover { background: rgba(37,244,238,0.15); border-color: #25f4ee; }
    .dash-action-btn:active { transform: scale(0.97); }
    .dash-action-btn .action-icon { font-size: 18px; }
    .dash-action-btn.danger { border-color: rgba(254,44,85,0.3); }
    .dash-action-btn.danger:hover { background: rgba(254,44,85,0.2); border-color: #fe2c55; }

    /* Game guide bar - auto-hides after 8s, tap to toggle */
    .game-guide { position: absolute; bottom: 0; left: 0; right: 0; z-index: 100; pointer-events: auto; transition: transform 0.4s ease, opacity 0.4s ease; }
    .game-guide.hidden { transform: translateY(100%); opacity: 0; pointer-events: none; }
    .guide-bar { display: flex; gap: 0; background: rgba(0,0,0,0.85); backdrop-filter: blur(12px); border-top: 1px solid rgba(255,255,255,0.1); padding: 6px 8px; justify-content: center; flex-wrap: wrap; }
    .guide-section { display: flex; align-items: center; gap: 4px; padding: 3px 10px; border-right: 1px solid rgba(255,255,255,0.08); white-space: nowrap; }
    .guide-section:last-child { border-right: none; }
    .guide-section .g-emoji { font-size: 16px; }
    .guide-section .g-label { font-size: 11px; color: #fff; font-weight: 600; }
    .guide-section .g-sub { font-size: 9px; color: #888; display: none; }
    @media (min-width: 640px) { .guide-section .g-sub { display: inline; } .guide-section .g-emoji { font-size: 20px; } .guide-section .g-label { font-size: 12px; } }
    .guide-section.guide-highlight { background: linear-gradient(135deg, rgba(254,44,85,0.25), rgba(37,244,238,0.15)); border-radius: 12px; border-right: none; margin: 0 2px; }
    .guide-show-btn { position: absolute; bottom: 8px; right: 8px; z-index: 101; width: 32px; height: 32px; border-radius: 50%; background: rgba(0,0,0,0.6); border: 1px solid #444; color: #fff; font-size: 14px; cursor: pointer; display: none; align-items: center; justify-content: center; pointer-events: auto; }
    .guide-show-btn.visible { display: flex; }

    /* Host controls - hidden for viewers via ?view param */
    .host-controls { position: absolute; bottom: 45px; left: 50%; transform: translateX(-50%); z-index: 100; display: flex; gap: 6px; flex-wrap: wrap; justify-content: center; }
    body.viewer-mode .host-controls { display: none; }
    body.viewer-mode .game-guide.hidden + .guide-show-btn { bottom: 8px; }

    /* Power-up notification */
    .powerup-notif { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 100; pointer-events: none; font-size: 28px; font-weight: 900; color: #fff; text-shadow: 0 0 20px rgba(255,200,0,0.8), 0 2px 4px rgba(0,0,0,0.5); opacity: 0; transition: opacity 0.2s; }
    .powerup-notif.show { opacity: 1; animation: powerPop 1.2s ease-out forwards; }
    @keyframes powerPop { 0% { transform: translate(-50%,-50%) scale(0.5); opacity: 0; } 15% { transform: translate(-50%,-50%) scale(1.2); opacity: 1; } 30% { transform: translate(-50%,-50%) scale(1); } 100% { transform: translate(-50%,-70%) scale(1); opacity: 0; } }

    /* Random event notification */
    .event-notif { position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%); z-index: 200; pointer-events: none; text-align: center; opacity: 0; }
    .event-notif.show { opacity: 1; animation: eventPop 2.5s ease-out forwards; }
    .event-icon { font-size: 64px; display: block; filter: drop-shadow(0 0 20px rgba(255,100,0,0.8)); }
    .event-label { font-size: 24px; font-weight: 900; color: #fff; text-shadow: 0 0 30px currentColor, 0 2px 6px rgba(0,0,0,0.8); text-transform: uppercase; letter-spacing: 2px; margin-top: 4px; }
    .event-credit { font-size: 13px; color: #ffd700; margin-top: 4px; text-shadow: 0 1px 4px rgba(0,0,0,0.6); }
    @keyframes eventPop { 0% { transform: translate(-50%,-50%) scale(0.3); opacity: 0; } 10% { transform: translate(-50%,-50%) scale(1.3); opacity: 1; } 20% { transform: translate(-50%,-50%) scale(1); } 80% { opacity: 1; } 100% { transform: translate(-50%,-60%) scale(1); opacity: 0; } }

    /* Gift burst overlay flash */
    .gift-flash { position: fixed; inset: 0; pointer-events: none; z-index: 50; opacity: 0; transition: opacity 0.1s; }
    .gift-flash.active { opacity: 1; animation: flashOut 0.6s ease-out forwards; }
    @keyframes flashOut { from { opacity: 0.3; } to { opacity: 0; } }
    .host-btn { padding: 8px 18px; background: rgba(0,0,0,0.8); backdrop-filter: blur(10px); border: 1px solid #444; border-radius: 20px; color: #fff; font-size: 12px; font-weight: 600; cursor: pointer; transition: all 0.2s; }
    .host-btn:hover { background: rgba(37,244,238,0.2); border-color: #25f4ee; }
    .host-btn.active { background: rgba(254,44,85,0.3); border-color: #fe2c55; }

    /* Portrait mode (TikTok Live 9:16) */
    @media (max-aspect-ratio: 3/4) {
      .hud { padding: 8px 10px; }
      .hud-badge { font-size: 12px; padding: 5px 10px; }
      .podium { min-width: 130px; }
      .podium-row { padding: 3px 8px; font-size: 11px; }
      .podium-title { font-size: 10px; padding: 3px 8px; }
      .env-badge { font-size: 11px; padding: 4px 12px; top: 8px; }
      .banner { font-size: 16px; padding: 12px 18px; }
      .host-dashboard { width: 240px; }
      .host-dash-toggle.shifted { right: 240px; }
      .host-controls { bottom: 55px; gap: 4px; }
      .host-btn { padding: 6px 12px; font-size: 11px; }
      .guide-bar { flex-direction: column; align-items: center; padding: 4px 6px; }
      .guide-section { border-right: none; border-bottom: 1px solid rgba(255,255,255,0.08); padding: 2px 8px; }
      .guide-section:last-child { border-bottom: none; }
      .powerup-notif { font-size: 22px; }
    }

    /* TikTok connect modal */
    .modal-overlay { display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.7); z-index: 500; align-items: center; justify-content: center; }
    .modal-overlay.visible { display: flex; }
    .modal { background: #1a1a2e; border: 1px solid #333; border-radius: 16px; padding: 24px; min-width: 320px; }
    .modal h3 { color: #fff; margin-bottom: 12px; }
    .modal input { width: 100%; padding: 10px 14px; background: #0a0a1a; border: 1px solid #444; border-radius: 10px; color: #fff; font-size: 14px; margin-bottom: 12px; outline: none; }
    .modal input:focus { border-color: #25f4ee; }
    .modal-btns { display: flex; gap: 8px; justify-content: flex-end; }
    .modal-btn { padding: 8px 20px; border-radius: 10px; border: none; font-weight: 600; cursor: pointer; font-size: 13px; }
    .modal-btn.primary { background: #25f4ee; color: #000; }
    .modal-btn.secondary { background: #333; color: #fff; }
  </style>
</head>
<body>
  <div class="game-frame" id="gameFrame">
    <canvas id="game-canvas"></canvas>
    <div class="gift-flash" id="giftFlash"></div>

    <!-- HUD -->
    <div class="hud">
      <div class="hud-left">
        <div class="hud-badge"><div class="live-dot"></div> <span id="runnerCount">0</span> runners</div>
        <div class="hud-badge">Leader: <span id="leaderDist">0</span>m</div>
      </div>
      <div class="hud-right podium">
        <div class="podium-title">Top 3</div>
        <div id="podiumList"></div>
      </div>
    </div>

    <div class="env-badge" id="envBadge">Grasslands</div>

    <div class="banner-area" id="bannerArea"></div>

    <!-- Host controls -->
    <div class="host-controls">
      <button class="host-btn" id="btnDemo" onclick="toggleDemo()">Demo Mode</button>
      <button class="host-btn" onclick="nextEnvironment()">Change Env</button>
      <button class="host-btn" onclick="showConnectModal()">Connect TikTok</button>
    </div>

    <!-- Host Dashboard (side panel) -->
    <button class="host-dash-toggle" id="dashToggle" onclick="toggleDashboard()">&#9776;</button>
    <div class="host-dashboard" id="hostDashboard">
      <div class="dash-header">
        <h3>Host Dashboard</h3>
        <button class="dash-close" onclick="toggleDashboard()">&times;</button>
      </div>
      <div class="dash-section">
        <h4>Change ALL Mounts</h4>
        <div class="dash-mount-grid" id="dashMountGrid"></div>
      </div>
      <div class="dash-section">
        <h4>Random Mount</h4>
        <div class="dash-action-list">
          <button class="dash-action-btn" onclick="dashRandomMountAll()"><span class="action-icon">üé≤</span> Random Mount for ALL</button>
          <button class="dash-action-btn" onclick="dashRandomMountLeader()"><span class="action-icon">üèÜ</span> Random Mount for Leader</button>
        </div>
      </div>
      <div class="dash-section">
        <h4>Game Events</h4>
        <div class="dash-action-list">
          <button class="dash-action-btn" onclick="dashTriggerEvent('dragon')"><span class="action-icon">üêâ</span> Dragon Attack</button>
          <button class="dash-action-btn" onclick="dashTriggerEvent('meteor')"><span class="action-icon">‚òÑÔ∏è</span> Meteor Shower</button>
          <button class="dash-action-btn" onclick="dashTriggerEvent('speed')"><span class="action-icon">üåä</span> Speed Wave</button>
          <button class="dash-action-btn" onclick="dashTriggerEvent('quake')"><span class="action-icon">üåã</span> Earthquake</button>
        </div>
      </div>
      <div class="dash-section">
        <h4>Game Controls</h4>
        <div class="dash-action-list">
          <button class="dash-action-btn" onclick="dashBoostAll()"><span class="action-icon">‚ö°</span> Boost ALL +10 tiles</button>
          <button class="dash-action-btn" onclick="dashShuffleAll()"><span class="action-icon">üîÄ</span> Shuffle All Lanes</button>
          <button class="dash-action-btn" onclick="toggleDemo()"><span class="action-icon">ü§ñ</span> Toggle Demo Mode</button>
          <button class="dash-action-btn" onclick="nextEnvironment()"><span class="action-icon">üåç</span> Change Environment</button>
          <button class="dash-action-btn danger" onclick="dashResetPositions()"><span class="action-icon">üîÑ</span> Reset All Positions</button>
        </div>
      </div>
    </div>

    <!-- Guide bar -->
    <div class="game-guide" id="gameGuide">
      <div class="guide-bar">
        <div class="guide-section guide-highlight"><span class="g-emoji">‚ù§Ô∏è</span><span class="g-label">Like = Run</span><span class="g-sub">1 tile</span></div>
        <div class="guide-section"><span class="g-emoji">üí¨</span><span class="g-label">Chat: jump/left/right</span><span class="g-sub">dodge & move</span></div>
        <div class="guide-section"><span class="g-emoji">üéÅ</span><span class="g-label">Gift = Mount + Power</span><span class="g-sub">random ride!</span></div>
        <div class="guide-section"><span class="g-emoji">‚≠ê</span><span class="g-label">Follow = +3</span><span class="g-sub">boost</span></div>
      </div>
    </div>
    <button class="guide-show-btn" id="guideShowBtn" onclick="toggleGuide()">?</button>
  <div class="powerup-notif" id="powerupNotif"></div>
  <div class="event-notif" id="eventNotif"></div>

    <!-- Connect Modal -->
    <div class="modal-overlay" id="connectModal">
      <div class="modal">
        <h3>Connect TikTok Live</h3>
        <input type="text" id="tiktokUsername" placeholder="@username" />
        <div class="modal-btns">
          <button class="modal-btn secondary" onclick="hideConnectModal()">Cancel</button>
          <button class="modal-btn primary" onclick="connectTikTok()">Connect</button>
        </div>
      </div>
    </div>
  </div><!-- end game-frame -->

  <script src="/socket.io/socket.io.js"></script>
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/"
    }
  }
  </script>
  <script type="module">
    import * as THREE from 'three';

    // ===== CONSTANTS =====
    const TILE = 2; // world units per tile
    const LANE_COUNT = 5;
    const LANE_WIDTH = 2;
    const ROAD_WIDTH = LANE_COUNT * LANE_WIDTH;
    const CHUNK_LENGTH = 40;
    const CHUNK_COUNT = 8;
    const FOG_NEAR = 80;
    const FOG_FAR = 200;
    const JUMP_DURATION = 600;
    const STUN_DURATION = 1500;
    const ENV_INTERVAL = 100; // tiles per environment change
    const OBSTACLE_CHANCE = 0.25;
    const MAX_VISIBLE_OBSTACLES = 40;
    const MAX_SCENERY = 60;

    // ===== COLOR PALETTE =====
    const PLAYER_COLORS = [
      0xff4444, 0x44aaff, 0x44ff44, 0xff44ff, 0xffaa00,
      0x00ffcc, 0xff6600, 0xaa44ff, 0xffff00, 0xff2266,
      0x00aaff, 0x66ff66, 0xff8888, 0x8888ff, 0xaaffaa
    ];

    // ===== ENVIRONMENT THEMES =====
    const ENVIRONMENTS = [
      { name: 'Grasslands', sky: 0x87ceeb, fog: 0xa8d4f0, ground: 0x3a8a35, groundAlt: 0x2d7a2a, road: 0x555555, roadAlt: 0x4a4a4a, rumble: 0xee2222, rumbleAlt: 0xffffff, mountain: 0x4a6a9a, sun: 0xffee88, sceneryColors: [0x2d6b2d, 0x1a5c1a, 0x888888] },
      { name: 'Desert', sky: 0xf0d8a0, fog: 0xe8c890, ground: 0xd4b060, groundAlt: 0xc0a050, road: 0xb8a070, roadAlt: 0xa89060, rumble: 0xe8a020, rumbleAlt: 0xffffff, mountain: 0xc4956a, sun: 0xffdd44, sceneryColors: [0xc4a050, 0x8b7340, 0xaa8855] },
      { name: 'Snow', sky: 0xc8dae8, fog: 0xd8e8f0, ground: 0xe0e8f0, groundAlt: 0xd0d8e8, road: 0x8a8a9a, roadAlt: 0x7a7a8a, rumble: 0x44aaff, rumbleAlt: 0xffffff, mountain: 0x8aa8c8, sun: 0xeeeeff, sceneryColors: [0x2d6b2d, 0xd0e0f0, 0xaabbcc] },
      { name: 'Volcano', sky: 0x3a1a0a, fog: 0x5a2a0a, ground: 0x3a2a1a, groundAlt: 0x2a1a0a, road: 0x4a3a2a, roadAlt: 0x3a2a1a, rumble: 0xff4400, rumbleAlt: 0xffaa00, mountain: 0x5a2a1a, sun: 0xff6633, sceneryColors: [0x2a1a0a, 0x444444, 0x666666] },
      { name: 'Ocean', sky: 0x70c0e8, fog: 0x88d0f0, ground: 0x2a7aaa, groundAlt: 0x1a6a9a, road: 0x5a8aaa, roadAlt: 0x4a7a9a, rumble: 0x00aaff, rumbleAlt: 0xffffff, mountain: 0x2a5a9a, sun: 0xffee88, sceneryColors: [0x2a6a9a, 0x3388aa, 0x558899] },
      { name: 'Space', sky: 0x000015, fog: 0x0a0a2a, ground: 0x2a1a3a, groundAlt: 0x1a0a2a, road: 0x3a2a4a, roadAlt: 0x2a1a3a, rumble: 0xaa00ff, rumbleAlt: 0x5500ff, mountain: 0x1a1a3a, sun: 0xccccff, sceneryColors: [0x3a2a5a, 0x2a1a4a, 0x5544aa] },
      { name: 'Candy', sky: 0xffc0e0, fog: 0xffd0e8, ground: 0xffb0d0, groundAlt: 0xffa0c0, road: 0xe890b8, roadAlt: 0xd880a8, rumble: 0xff00ff, rumbleAlt: 0xffff00, mountain: 0xe080b0, sun: 0xffaacc, sceneryColors: [0xff88aa, 0xffaa88, 0xdd66aa] },
      { name: 'Jungle', sky: 0x6aaa40, fog: 0x4a8a30, ground: 0x1a6a15, groundAlt: 0x0a5a0a, road: 0x5a4a2a, roadAlt: 0x4a3a1a, rumble: 0x00aa00, rumbleAlt: 0x88ff44, mountain: 0x2a5a2a, sun: 0xddff88, sceneryColors: [0x1a5a1a, 0x2a7a2a, 0x4a3a1a] },
    ];

    // ===== OBSTACLE TYPES =====
    const OBSTACLE_TYPES = [
      { name: 'rock', color: 0x888888, height: 0.8, width: 0.7 },
      { name: 'tree', color: 0x2d6b2d, height: 1.5, width: 0.5 },
      { name: 'water', color: 0x4488ff, height: 0.3, width: 1.5 },
      { name: 'wall', color: 0xaa6633, height: 1.2, width: 1.8 },
      { name: 'fire', color: 0xff4400, height: 1.0, width: 0.6 },
      { name: 'bomb', color: 0x333333, height: 0.5, width: 0.5 },
    ];

    // ===== VIEWER MODE =====
    // ?view=1 hides host controls so viewers see a clean game
    const params = new URLSearchParams(window.location.search);
    const isViewerMode = params.has('view');
    if (isViewerMode) document.body.classList.add('viewer-mode');

    // ?portrait forces 9:16 portrait layout for TikTok Live screen capture
    const isPortraitForced = params.has('portrait');
    if (isPortraitForced) document.body.classList.add('portrait-mode');

    // ===== STATE =====
    const players = new Map();
    let envIndex = 0;
    let lastObstacleTile = 0;
    let demoActive = false;
    const obstacles = []; // { tile, lane, type, mesh }
    const obstaclePool = [];
    const sceneryPool = [];
    const roadChunks = [];
    let cameraTargetZ = 0;

    // ===== RANDOM EVENTS =====
    const RANDOM_EVENTS = [
      { name: 'Dragon Attack', icon: 'üêâ', color: 0xff2200, duration: 2000 },
      { name: 'Meteor Shower', icon: '‚òÑÔ∏è', color: 0xff8800, duration: 2500 },
      { name: 'Speed Wave', icon: 'üåä', color: 0x00ff88, duration: 1500 },
      { name: 'Earthquake', icon: 'üåã', color: 0xaa6633, duration: 2000 },
    ];
    const EVENT_INTERVAL = 80; // tiles between random events
    let lastEventTile = 0;
    let activeEvent = null; // { type, startTime, duration }
    let cameraShakeAmount = 0;

    // ===== PARTICLE SYSTEM =====
    const MAX_PARTICLES = 200;
    const particlePositions = new Float32Array(MAX_PARTICLES * 3);
    const particleColors = new Float32Array(MAX_PARTICLES * 3);
    const particleSizes = new Float32Array(MAX_PARTICLES);
    const particleVelocities = []; // { vx, vy, vz, life, maxLife }
    for (let i = 0; i < MAX_PARTICLES; i++) {
      particlePositions[i * 3] = 0;
      particlePositions[i * 3 + 1] = -100; // hidden below
      particlePositions[i * 3 + 2] = 0;
      particleColors[i * 3] = 1;
      particleColors[i * 3 + 1] = 1;
      particleColors[i * 3 + 2] = 1;
      particleSizes[i] = 0;
      particleVelocities.push({ vx: 0, vy: 0, vz: 0, life: 0, maxLife: 0 });
    }
    let nextParticle = 0;

    // ===== TRAIL SYSTEM =====
    const MAX_TRAILS = 600;
    const trailPositions = new Float32Array(MAX_TRAILS * 3);
    const trailColors = new Float32Array(MAX_TRAILS * 3);
    const trailSizes = new Float32Array(MAX_TRAILS);
    const trailMeta = []; // { life, maxLife }
    for (let i = 0; i < MAX_TRAILS; i++) {
      trailPositions[i * 3] = 0;
      trailPositions[i * 3 + 1] = -100;
      trailPositions[i * 3 + 2] = 0;
      trailColors[i * 3] = 1;
      trailColors[i * 3 + 1] = 1;
      trailColors[i * 3 + 2] = 1;
      trailSizes[i] = 0;
      trailMeta.push({ life: 0, maxLife: 0 });
    }
    let nextTrail = 0;

    // ===== SOUND ENGINE (Web Audio API, no files) =====
    let audioCtx = null;
    function getAudio() {
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      return audioCtx;
    }
    // Unlock audio on first interaction
    document.addEventListener('click', () => { getAudio(); }, { once: true });

    function playTone(freq, duration, type = 'sine', vol = 0.15) {
      try {
        const ctx = getAudio();
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, ctx.currentTime);
        gain.gain.setValueAtTime(vol, ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + duration);
        osc.connect(gain);
        gain.connect(ctx.destination);
        osc.start();
        osc.stop(ctx.currentTime + duration);
      } catch(e) {}
    }

    function sfxGift(diamonds) {
      // Rising arpeggio, higher notes for bigger gifts
      const base = 400 + Math.min(diamonds, 100) * 3;
      playTone(base, 0.12, 'sine', 0.12);
      setTimeout(() => playTone(base * 1.25, 0.12, 'sine', 0.10), 60);
      setTimeout(() => playTone(base * 1.5, 0.15, 'sine', 0.10), 120);
      if (diamonds > 20) setTimeout(() => playTone(base * 2, 0.2, 'triangle', 0.08), 180);
    }

    function sfxJump() {
      playTone(300, 0.08, 'sine', 0.10);
      setTimeout(() => playTone(500, 0.1, 'sine', 0.08), 50);
    }

    function sfxHit() {
      playTone(150, 0.15, 'sawtooth', 0.12);
      setTimeout(() => playTone(100, 0.2, 'sawtooth', 0.10), 80);
    }

    function sfxFollow() {
      playTone(500, 0.1, 'sine', 0.10);
      setTimeout(() => playTone(600, 0.1, 'sine', 0.10), 80);
      setTimeout(() => playTone(800, 0.15, 'triangle', 0.08), 160);
    }

    function sfxPowerup() {
      playTone(600, 0.08, 'sine', 0.12);
      setTimeout(() => playTone(800, 0.08, 'sine', 0.10), 70);
      setTimeout(() => playTone(1000, 0.08, 'sine', 0.10), 140);
      setTimeout(() => playTone(1200, 0.15, 'triangle', 0.08), 210);
    }

    function sfxJoin() {
      playTone(440, 0.1, 'sine', 0.06);
      setTimeout(() => playTone(550, 0.12, 'sine', 0.05), 100);
    }

    // ===== POWER-UP SYSTEM =====
    // Road pickup powers (first 4, collectible on track)
    // Gift-exclusive powers (last 2, only from gifts)
    const POWERUP_TYPES = [
      { name: 'Speed Boost', icon: '‚ö°', color: 0xffaa00, effect: 'speed' },
      { name: 'Shield', icon: 'üõ°', color: 0x44aaff, effect: 'shield' },
      { name: 'Lightning', icon: 'üîÆ', color: 0xaa44ff, effect: 'lightning' },
      { name: 'Magnet', icon: 'üß≤', color: 0xff44aa, effect: 'magnet' },
      // Gift-exclusive (cannot be picked up on road)
      { name: 'Mega Kick', icon: 'ü¶µ', color: 0xff2222, effect: 'kick' },
      { name: 'Push Out', icon: 'üí®', color: 0xff8800, effect: 'pushout' },
    ];
    const ROAD_POWERUP_COUNT = 4; // only first 4 spawn on road
    const MAX_INVENTORY = 3;
    const MAX_POWERUPS = 15;
    const activePowerups = []; // { tile, lane, typeIndex, mesh }

    // ===== MOUNT / RIDE SYSTEM =====
    const DEFAULT_MOUNT_INDEX = 0;

    // Shared geometries (cached for performance)
    const _legGeo = new THREE.CylinderGeometry(0.08, 0.08, 0.55, 5);
    const _thickLegGeo = new THREE.CylinderGeometry(0.1, 0.1, 0.5, 5);

    function buildHorse(accent) {
      const g = new THREE.Group();
      const mat = new THREE.MeshLambertMaterial({ color: 0x8B4513, flatShading: true });
      const sMat = new THREE.MeshLambertMaterial({ color: accent, flatShading: true });
      // Body
      const body = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.5, 0.5), mat);
      body.position.set(0, 0.8, 0); g.add(body);
      // Neck
      const neck = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.45, 0.25), mat);
      neck.position.set(0, 1.05, -0.45); neck.rotation.x = -0.3; g.add(neck);
      // Head
      const head = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.25, 0.35), mat);
      head.position.set(0, 1.2, -0.65); g.add(head);
      // Saddle
      const saddle = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.1, 0.35), sMat);
      saddle.position.set(0, 1.1, 0); g.add(saddle);
      // Legs
      const fl = new THREE.Mesh(_legGeo, mat); fl.position.set(-0.18, 0.3, -0.35); g.add(fl);
      const fr = new THREE.Mesh(_legGeo, mat); fr.position.set(0.18, 0.3, -0.35); g.add(fr);
      const bl = new THREE.Mesh(_legGeo, mat); bl.position.set(-0.18, 0.3, 0.35); g.add(bl);
      const br = new THREE.Mesh(_legGeo, mat); br.position.set(0.18, 0.3, 0.35); g.add(br);
      // Tail
      const tail = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.02, 0.4, 4), mat);
      tail.position.set(0, 0.85, 0.65); tail.rotation.x = 0.5; g.add(tail);
      return { mountGroup: g, animParts: { frontLeftLeg: fl, frontRightLeg: fr, backLeftLeg: bl, backRightLeg: br, tail, head } };
    }

    function buildMotorcycle(accent) {
      const g = new THREE.Group();
      const mat = new THREE.MeshLambertMaterial({ color: 0x333333, flatShading: true });
      const sMat = new THREE.MeshLambertMaterial({ color: accent, flatShading: true });
      // Frame
      const frame = new THREE.Mesh(new THREE.BoxGeometry(0.9, 0.2, 0.35), mat);
      frame.position.set(0, 0.45, 0); g.add(frame);
      // Seat
      const seat = new THREE.Mesh(new THREE.BoxGeometry(0.35, 0.12, 0.3), sMat);
      seat.position.set(0, 0.6, 0.05); g.add(seat);
      // Handlebars
      const hbar = new THREE.Mesh(new THREE.CylinderGeometry(0.025, 0.025, 0.5, 5), mat);
      hbar.position.set(0, 0.7, -0.4); hbar.rotation.z = Math.PI / 2; g.add(hbar);
      // Front wheel
      const fwGeo = new THREE.TorusGeometry(0.2, 0.05, 6, 12);
      const fw = new THREE.Mesh(fwGeo, mat); fw.position.set(0, 0.22, -0.45); fw.rotation.y = Math.PI / 2; g.add(fw);
      // Back wheel
      const bw = new THREE.Mesh(fwGeo, mat); bw.position.set(0, 0.22, 0.35); bw.rotation.y = Math.PI / 2; g.add(bw);
      // Engine
      const eng = new THREE.Mesh(new THREE.SphereGeometry(0.12, 6, 4), new THREE.MeshLambertMaterial({ color: 0x666666, flatShading: true }));
      eng.position.set(0, 0.35, 0); g.add(eng);
      return { mountGroup: g, animParts: { frontWheel: fw, backWheel: bw } };
    }

    function buildWhale(accent) {
      const g = new THREE.Group();
      const mat = new THREE.MeshLambertMaterial({ color: 0x4477CC, flatShading: true });
      const bellyMat = new THREE.MeshLambertMaterial({ color: 0x88bbee, flatShading: true });
      // Body
      const bodyGeo = new THREE.SphereGeometry(0.7, 8, 6);
      const body = new THREE.Mesh(bodyGeo, mat);
      body.scale.set(1.5, 0.75, 0.85); body.position.set(0, 0.7, 0); g.add(body);
      // Belly
      const belly = new THREE.Mesh(new THREE.SphereGeometry(0.6, 8, 6), bellyMat);
      belly.scale.set(1.3, 0.5, 0.75); belly.position.set(0, 0.55, 0); g.add(belly);
      // Tail
      const tail = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.08, 0.35), mat);
      tail.position.set(0, 0.65, 0.8); g.add(tail);
      // Eyes
      const eyeMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
      const e1 = new THREE.Mesh(new THREE.SphereGeometry(0.06, 5, 4), eyeMat);
      e1.position.set(-0.35, 0.8, -0.4); g.add(e1);
      const e2 = e1.clone(); e2.position.set(0.35, 0.8, -0.4); g.add(e2);
      // Saddle area
      const sMat = new THREE.MeshLambertMaterial({ color: accent, flatShading: true });
      const saddle = new THREE.Mesh(new THREE.BoxGeometry(0.35, 0.08, 0.3), sMat);
      saddle.position.set(0, 1.0, 0); g.add(saddle);
      return { mountGroup: g, animParts: { tail, body } };
    }

    function buildPanda(accent) {
      const g = new THREE.Group();
      const wMat = new THREE.MeshLambertMaterial({ color: 0xeeeeee, flatShading: true });
      const bMat = new THREE.MeshLambertMaterial({ color: 0x222222, flatShading: true });
      // Body
      const body = new THREE.Mesh(new THREE.SphereGeometry(0.45, 7, 5), wMat);
      body.position.set(0, 0.7, 0); g.add(body);
      // Head
      const head = new THREE.Mesh(new THREE.SphereGeometry(0.3, 7, 5), wMat);
      head.position.set(0, 1.15, -0.3); g.add(head);
      // Eye patches
      const ep1 = new THREE.Mesh(new THREE.SphereGeometry(0.1, 5, 4), bMat);
      ep1.position.set(-0.12, 1.18, -0.52); g.add(ep1);
      const ep2 = ep1.clone(); ep2.position.set(0.12, 1.18, -0.52); g.add(ep2);
      // Ears
      const ear1 = new THREE.Mesh(new THREE.SphereGeometry(0.08, 5, 4), bMat);
      ear1.position.set(-0.22, 1.38, -0.25); g.add(ear1);
      const ear2 = ear1.clone(); ear2.position.set(0.22, 1.38, -0.25); g.add(ear2);
      // Legs
      const fl = new THREE.Mesh(_thickLegGeo, bMat); fl.position.set(-0.22, 0.25, -0.2); g.add(fl);
      const fr = new THREE.Mesh(_thickLegGeo, bMat); fr.position.set(0.22, 0.25, -0.2); g.add(fr);
      const bl = new THREE.Mesh(_thickLegGeo, bMat); bl.position.set(-0.22, 0.25, 0.2); g.add(bl);
      const br = new THREE.Mesh(_thickLegGeo, bMat); br.position.set(0.22, 0.25, 0.2); g.add(br);
      // Saddle
      const sMat = new THREE.MeshLambertMaterial({ color: accent, flatShading: true });
      const saddle = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.08, 0.25), sMat);
      saddle.position.set(0, 1.0, 0); g.add(saddle);
      return { mountGroup: g, animParts: { frontLeftLeg: fl, frontRightLeg: fr, backLeftLeg: bl, backRightLeg: br, head } };
    }

    function buildBear(accent) {
      const g = new THREE.Group();
      const mat = new THREE.MeshLambertMaterial({ color: 0x8B6914, flatShading: true });
      const dMat = new THREE.MeshLambertMaterial({ color: 0x6B4914, flatShading: true });
      // Body
      const body = new THREE.Mesh(new THREE.SphereGeometry(0.5, 7, 5), mat);
      body.position.set(0, 0.75, 0); g.add(body);
      // Head
      const head = new THREE.Mesh(new THREE.SphereGeometry(0.32, 7, 5), mat);
      head.position.set(0, 1.2, -0.3); g.add(head);
      // Snout
      const snout = new THREE.Mesh(new THREE.SphereGeometry(0.12, 5, 4), dMat);
      snout.position.set(0, 1.12, -0.55); g.add(snout);
      // Ears
      const ear1 = new THREE.Mesh(new THREE.SphereGeometry(0.08, 5, 4), dMat);
      ear1.position.set(-0.22, 1.42, -0.22); g.add(ear1);
      const ear2 = ear1.clone(); ear2.position.set(0.22, 1.42, -0.22); g.add(ear2);
      // Legs
      const fl = new THREE.Mesh(_thickLegGeo, dMat); fl.position.set(-0.25, 0.25, -0.22); g.add(fl);
      const fr = new THREE.Mesh(_thickLegGeo, dMat); fr.position.set(0.25, 0.25, -0.22); g.add(fr);
      const bl = new THREE.Mesh(_thickLegGeo, dMat); bl.position.set(-0.25, 0.25, 0.22); g.add(bl);
      const br = new THREE.Mesh(_thickLegGeo, dMat); br.position.set(0.25, 0.25, 0.22); g.add(br);
      // Saddle
      const sMat = new THREE.MeshLambertMaterial({ color: accent, flatShading: true });
      const saddle = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.08, 0.25), sMat);
      saddle.position.set(0, 1.08, 0); g.add(saddle);
      return { mountGroup: g, animParts: { frontLeftLeg: fl, frontRightLeg: fr, backLeftLeg: bl, backRightLeg: br, head } };
    }

    function buildDragon(accent) {
      const g = new THREE.Group();
      const mat = new THREE.MeshLambertMaterial({ color: 0x22AA44, flatShading: true });
      const dMat = new THREE.MeshLambertMaterial({ color: 0x118833, flatShading: true });
      // Body
      const body = new THREE.Mesh(new THREE.BoxGeometry(1.0, 0.45, 0.5), mat);
      body.position.set(0, 0.85, 0); g.add(body);
      // Neck
      const neck = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.16, 0.4, 5), mat);
      neck.position.set(0, 1.05, -0.45); neck.rotation.x = -0.4; g.add(neck);
      // Head
      const head = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.22, 0.3), mat);
      head.position.set(0, 1.2, -0.65); g.add(head);
      // Wings
      const wingMat = new THREE.MeshLambertMaterial({ color: 0x33cc55, flatShading: true, side: THREE.DoubleSide });
      const wingGeo = new THREE.BoxGeometry(0.7, 0.04, 0.5);
      const lw = new THREE.Mesh(wingGeo, wingMat); lw.position.set(-0.6, 1.1, 0); g.add(lw);
      const rw = new THREE.Mesh(wingGeo, wingMat); rw.position.set(0.6, 1.1, 0); g.add(rw);
      // Tail
      const tail = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.03, 0.7, 5), dMat);
      tail.position.set(0, 0.75, 0.7); tail.rotation.x = 0.4; g.add(tail);
      // Spines
      for (let i = 0; i < 3; i++) {
        const spine = new THREE.Mesh(new THREE.ConeGeometry(0.05, 0.15, 4), dMat);
        spine.position.set(0, 1.15, -0.2 + i * 0.25); g.add(spine);
      }
      // Legs
      const fl = new THREE.Mesh(_legGeo, dMat); fl.position.set(-0.2, 0.35, -0.3); g.add(fl);
      const fr = new THREE.Mesh(_legGeo, dMat); fr.position.set(0.2, 0.35, -0.3); g.add(fr);
      const bl = new THREE.Mesh(_legGeo, dMat); bl.position.set(-0.2, 0.35, 0.3); g.add(bl);
      const br = new THREE.Mesh(_legGeo, dMat); br.position.set(0.2, 0.35, 0.3); g.add(br);
      // Saddle
      const sMat = new THREE.MeshLambertMaterial({ color: accent, flatShading: true });
      const saddle = new THREE.Mesh(new THREE.BoxGeometry(0.35, 0.08, 0.3), sMat);
      saddle.position.set(0, 1.12, 0); g.add(saddle);
      return { mountGroup: g, animParts: { leftWing: lw, rightWing: rw, tail, head } };
    }

    function buildUnicorn(accent) {
      const g = new THREE.Group();
      const mat = new THREE.MeshLambertMaterial({ color: 0xffeeff, flatShading: true });
      const pMat = new THREE.MeshLambertMaterial({ color: 0xffaaff, flatShading: true });
      // Body
      const body = new THREE.Mesh(new THREE.BoxGeometry(1.1, 0.48, 0.48), mat);
      body.position.set(0, 0.8, 0); g.add(body);
      // Neck
      const neck = new THREE.Mesh(new THREE.BoxGeometry(0.22, 0.4, 0.22), mat);
      neck.position.set(0, 1.02, -0.42); neck.rotation.x = -0.3; g.add(neck);
      // Head
      const head = new THREE.Mesh(new THREE.BoxGeometry(0.22, 0.22, 0.3), mat);
      head.position.set(0, 1.18, -0.6); g.add(head);
      // Horn
      const horn = new THREE.Mesh(new THREE.ConeGeometry(0.05, 0.3, 5), new THREE.MeshLambertMaterial({ color: 0xffd700, flatShading: true }));
      horn.position.set(0, 1.42, -0.6); g.add(horn);
      // Mane (rainbow blocks)
      const rainbow = [0xff0000, 0xff8800, 0xffff00, 0x00ff00, 0x0088ff, 0x8800ff];
      rainbow.forEach((c, i) => {
        const m = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.12, 0.06), new THREE.MeshLambertMaterial({ color: c, flatShading: true }));
        m.position.set(0, 1.15 - i * 0.06, -0.35 + i * 0.08); g.add(m);
      });
      // Legs
      const fl = new THREE.Mesh(_legGeo, pMat); fl.position.set(-0.17, 0.28, -0.32); g.add(fl);
      const fr = new THREE.Mesh(_legGeo, pMat); fr.position.set(0.17, 0.28, -0.32); g.add(fr);
      const bl = new THREE.Mesh(_legGeo, pMat); bl.position.set(-0.17, 0.28, 0.32); g.add(bl);
      const br = new THREE.Mesh(_legGeo, pMat); br.position.set(0.17, 0.28, 0.32); g.add(br);
      // Tail
      const tail = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.02, 0.35, 4), pMat);
      tail.position.set(0, 0.82, 0.6); tail.rotation.x = 0.5; g.add(tail);
      // Saddle
      const sMat = new THREE.MeshLambertMaterial({ color: accent, flatShading: true });
      const saddle = new THREE.Mesh(new THREE.BoxGeometry(0.35, 0.08, 0.28), sMat);
      saddle.position.set(0, 1.08, 0); g.add(saddle);
      return { mountGroup: g, animParts: { frontLeftLeg: fl, frontRightLeg: fr, backLeftLeg: bl, backRightLeg: br, tail, head } };
    }

    function buildTiger(accent) {
      const g = new THREE.Group();
      const mat = new THREE.MeshLambertMaterial({ color: 0xFF8800, flatShading: true });
      const sMat2 = new THREE.MeshLambertMaterial({ color: 0x332200, flatShading: true });
      // Body
      const body = new THREE.Mesh(new THREE.BoxGeometry(1.1, 0.4, 0.45), mat);
      body.position.set(0, 0.7, 0); g.add(body);
      // Stripes
      for (let i = 0; i < 4; i++) {
        const stripe = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.42, 0.46), sMat2);
        stripe.position.set(0, 0.7, -0.3 + i * 0.2); g.add(stripe);
      }
      // Head
      const head = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.28, 0.3), mat);
      head.position.set(0, 0.85, -0.6); g.add(head);
      // Ears
      const ear1 = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.1, 0.06), mat);
      ear1.position.set(-0.12, 1.02, -0.58); g.add(ear1);
      const ear2 = ear1.clone(); ear2.position.set(0.12, 1.02, -0.58); g.add(ear2);
      // Legs
      const fl = new THREE.Mesh(_legGeo, mat); fl.position.set(-0.18, 0.22, -0.32); g.add(fl);
      const fr = new THREE.Mesh(_legGeo, mat); fr.position.set(0.18, 0.22, -0.32); g.add(fr);
      const bl = new THREE.Mesh(_legGeo, mat); bl.position.set(-0.18, 0.22, 0.32); g.add(bl);
      const br = new THREE.Mesh(_legGeo, mat); br.position.set(0.18, 0.22, 0.32); g.add(br);
      // Tail
      const tail = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.02, 0.5, 4), mat);
      tail.position.set(0, 0.7, 0.7); tail.rotation.x = 0.3; g.add(tail);
      // Saddle
      const saMat = new THREE.MeshLambertMaterial({ color: accent, flatShading: true });
      const saddle = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.08, 0.25), saMat);
      saddle.position.set(0, 0.95, 0); g.add(saddle);
      return { mountGroup: g, animParts: { frontLeftLeg: fl, frontRightLeg: fr, backLeftLeg: bl, backRightLeg: br, tail } };
    }

    function buildBull(accent) {
      const g = new THREE.Group();
      const mat = new THREE.MeshLambertMaterial({ color: 0x553311, flatShading: true });
      const dMat = new THREE.MeshLambertMaterial({ color: 0x3a2208, flatShading: true });
      // Body (wider)
      const body = new THREE.Mesh(new THREE.BoxGeometry(1.15, 0.55, 0.6), mat);
      body.position.set(0, 0.8, 0); g.add(body);
      // Head (thick)
      const head = new THREE.Mesh(new THREE.BoxGeometry(0.35, 0.3, 0.35), mat);
      head.position.set(0, 0.95, -0.6); g.add(head);
      // Horns
      const hornMat = new THREE.MeshLambertMaterial({ color: 0xccbb88, flatShading: true });
      const h1 = new THREE.Mesh(new THREE.ConeGeometry(0.04, 0.25, 5), hornMat);
      h1.position.set(-0.22, 1.12, -0.55); h1.rotation.z = 0.5; g.add(h1);
      const h2 = h1.clone(); h2.position.set(0.22, 1.12, -0.55); h2.rotation.z = -0.5; g.add(h2);
      // Legs
      const fl = new THREE.Mesh(_thickLegGeo, dMat); fl.position.set(-0.22, 0.28, -0.32); g.add(fl);
      const fr = new THREE.Mesh(_thickLegGeo, dMat); fr.position.set(0.22, 0.28, -0.32); g.add(fr);
      const bl = new THREE.Mesh(_thickLegGeo, dMat); bl.position.set(-0.22, 0.28, 0.32); g.add(bl);
      const br = new THREE.Mesh(_thickLegGeo, dMat); br.position.set(0.22, 0.28, 0.32); g.add(br);
      // Tail
      const tail = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.02, 0.4, 4), dMat);
      tail.position.set(0, 0.85, 0.65); tail.rotation.x = 0.4; g.add(tail);
      // Saddle
      const sMat = new THREE.MeshLambertMaterial({ color: accent, flatShading: true });
      const saddle = new THREE.Mesh(new THREE.BoxGeometry(0.35, 0.08, 0.3), sMat);
      saddle.position.set(0, 1.12, 0); g.add(saddle);
      return { mountGroup: g, animParts: { frontLeftLeg: fl, frontRightLeg: fr, backLeftLeg: bl, backRightLeg: br, tail, head } };
    }

    function buildPhoenix(accent) {
      const g = new THREE.Group();
      const mat = new THREE.MeshBasicMaterial({ color: 0xFF4400 });
      const gMat = new THREE.MeshBasicMaterial({ color: 0xFFAA00 });
      // Body
      const body = new THREE.Mesh(new THREE.SphereGeometry(0.4, 7, 5), mat);
      body.scale.set(1.3, 0.8, 0.9); body.position.set(0, 0.9, 0); g.add(body);
      // Head
      const head = new THREE.Mesh(new THREE.SphereGeometry(0.2, 6, 5), gMat);
      head.position.set(0, 1.15, -0.4); g.add(head);
      // Beak
      const beak = new THREE.Mesh(new THREE.ConeGeometry(0.06, 0.15, 4), new THREE.MeshBasicMaterial({ color: 0xffcc00 }));
      beak.position.set(0, 1.1, -0.58); beak.rotation.x = Math.PI / 2; g.add(beak);
      // Wings
      const wingGeo = new THREE.BoxGeometry(0.7, 0.04, 0.45);
      const lw = new THREE.Mesh(wingGeo, mat); lw.position.set(-0.6, 1.05, 0); g.add(lw);
      const rw = new THREE.Mesh(wingGeo, mat); rw.position.set(0.6, 1.05, 0); g.add(rw);
      // Tail feathers
      for (let i = 0; i < 3; i++) {
        const f = new THREE.Mesh(new THREE.BoxGeometry(0.08 + i * 0.03, 0.03, 0.4 - i * 0.05), i % 2 === 0 ? mat : gMat);
        f.position.set((i - 1) * 0.12, 0.85, 0.6 + i * 0.1); g.add(f);
      }
      // Saddle
      const sMat = new THREE.MeshLambertMaterial({ color: accent, flatShading: true });
      const saddle = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.08, 0.25), sMat);
      saddle.position.set(0, 1.15, 0); g.add(saddle);
      return { mountGroup: g, animParts: { leftWing: lw, rightWing: rw, tail: g.children[g.children.length - 4], head } };
    }

    const MOUNT_TYPES = [
      { name: 'Horse',      icon: 'üê¥', color: 0x8B4513, riderY: 1.4, animType: 'gallop', build: buildHorse },
      { name: 'Motorcycle',  icon: 'üèçÔ∏è', color: 0x333333, riderY: 1.0, animType: 'wheels', build: buildMotorcycle },
      { name: 'Whale',      icon: 'üêã', color: 0x4477CC, riderY: 1.5, animType: 'bob',    build: buildWhale },
      { name: 'Panda',      icon: 'üêº', color: 0xEEEEEE, riderY: 1.4, animType: 'waddle', build: buildPanda },
      { name: 'Bear',       icon: 'üêª', color: 0x8B6914, riderY: 1.4, animType: 'waddle', build: buildBear },
      { name: 'Dragon',     icon: 'üêâ', color: 0x22AA44, riderY: 1.6, animType: 'fly',    build: buildDragon },
      { name: 'Unicorn',    icon: 'ü¶Ñ', color: 0xFFAAFF, riderY: 1.4, animType: 'gallop', build: buildUnicorn },
      { name: 'Tiger',      icon: 'üêØ', color: 0xFF8800, riderY: 1.2, animType: 'prowl',  build: buildTiger },
      { name: 'Bull',       icon: 'üêÇ', color: 0x553311, riderY: 1.4, animType: 'gallop', build: buildBull },
      { name: 'Phoenix',    icon: 'üî•', color: 0xFF4400, riderY: 1.5, animType: 'fly',    build: buildPhoenix },
    ];

    // Mount animation dispatcher
    function animateMount(ud, phase, swing, dt) {
      const mountDef = MOUNT_TYPES[ud.mountTypeIndex];
      const ap = ud.mountAnimParts;
      if (!ap || !mountDef) return;
      switch (mountDef.animType) {
        case 'gallop':
          if (ap.frontLeftLeg) ap.frontLeftLeg.rotation.x = swing;
          if (ap.frontRightLeg) ap.frontRightLeg.rotation.x = -swing;
          if (ap.backLeftLeg) ap.backLeftLeg.rotation.x = -swing * 0.8;
          if (ap.backRightLeg) ap.backRightLeg.rotation.x = swing * 0.8;
          if (ap.tail) ap.tail.rotation.x = 0.5 + Math.sin(phase * 1.5) * 0.2;
          if (ap.head) ap.head.rotation.x = Math.sin(phase * 0.7) * 0.05;
          if (ud.mountGroup) ud.mountGroup.position.y = Math.abs(Math.sin(phase)) * 0.08;
          break;
        case 'wheels':
          if (ap.frontWheel) ap.frontWheel.rotation.x += dt * 15;
          if (ap.backWheel) ap.backWheel.rotation.x += dt * 15;
          if (ud.mountGroup) ud.mountGroup.rotation.z = Math.sin(phase * 0.3) * 0.03;
          break;
        case 'bob':
          if (ud.mountGroup) ud.mountGroup.position.y = Math.sin(phase * 0.8) * 0.15;
          if (ap.tail) ap.tail.rotation.z = Math.sin(phase) * 0.3;
          break;
        case 'waddle':
          if (ud.mountGroup) ud.mountGroup.rotation.z = Math.sin(phase) * 0.06;
          if (ap.frontLeftLeg) ap.frontLeftLeg.rotation.x = swing * 0.6;
          if (ap.frontRightLeg) ap.frontRightLeg.rotation.x = -swing * 0.6;
          if (ap.backLeftLeg) ap.backLeftLeg.rotation.x = -swing * 0.5;
          if (ap.backRightLeg) ap.backRightLeg.rotation.x = swing * 0.5;
          if (ap.head) ap.head.rotation.y = Math.sin(phase * 0.4) * 0.1;
          break;
        case 'fly':
          if (ud.mountGroup) ud.mountGroup.position.y = 0.3 + Math.sin(phase * 0.6) * 0.2;
          if (ap.leftWing) ap.leftWing.rotation.z = Math.sin(phase * 2) * 0.4;
          if (ap.rightWing) ap.rightWing.rotation.z = -Math.sin(phase * 2) * 0.4;
          if (ap.tail) ap.tail.rotation.y = Math.sin(phase) * 0.2;
          break;
        case 'prowl':
          if (ap.frontLeftLeg) ap.frontLeftLeg.rotation.x = swing * 1.2;
          if (ap.frontRightLeg) ap.frontRightLeg.rotation.x = -swing * 1.2;
          if (ap.backLeftLeg) ap.backLeftLeg.rotation.x = -swing;
          if (ap.backRightLeg) ap.backRightLeg.rotation.x = swing;
          if (ap.tail) ap.tail.rotation.y = Math.sin(phase * 1.5) * 0.3;
          if (ud.mountGroup) ud.mountGroup.position.y = Math.abs(Math.sin(phase * 1.5)) * 0.05;
          break;
      }
    }

    // Swap mount on gift
    function swapMount(p, newTypeIndex) {
      const ud = p.mesh.userData;
      if (newTypeIndex === ud.mountTypeIndex) {
        newTypeIndex = (newTypeIndex + 1 + Math.floor(Math.random() * (MOUNT_TYPES.length - 1))) % MOUNT_TYPES.length;
      }
      // Remove old mount
      if (ud.mountGroup) {
        p.mesh.remove(ud.mountGroup);
        ud.mountGroup.traverse(child => {
          if (child.geometry) child.geometry.dispose();
          if (child.material) child.material.dispose();
        });
      }
      // Build new mount
      const color = hashColor(p.id);
      const mountDef = MOUNT_TYPES[newTypeIndex];
      const { mountGroup, animParts } = mountDef.build(color);
      p.mesh.add(mountGroup);
      // Reposition rider
      ud.riderGroup.position.y = mountDef.riderY;
      ud.mountGroup = mountGroup;
      ud.mountAnimParts = animParts;
      ud.mountTypeIndex = newTypeIndex;
      p.mountType = newTypeIndex;
      // Particles
      spawnGiftParticles(p.mesh.position.x, p.mesh.position.y + 1, p.mesh.position.z, mountDef.color, 20);
      return newTypeIndex;
    }
    const powerupMeshPool = [];
    let lastPowerupTile = 10;

    // ===== GUIDE (always visible, host can toggle) =====
    let guideVisible = true;

    window.toggleGuide = function() {
      guideVisible = !guideVisible;
      document.getElementById('gameGuide').classList.toggle('hidden', !guideVisible);
      document.getElementById('guideShowBtn').classList.toggle('visible', !guideVisible);
    };

    // ===== HOST DASHBOARD =====
    let dashOpen = false;
    window.toggleDashboard = function() {
      dashOpen = !dashOpen;
      document.getElementById('hostDashboard').classList.toggle('open', dashOpen);
      document.getElementById('dashToggle').classList.toggle('shifted', dashOpen);
      document.getElementById('dashToggle').innerHTML = dashOpen ? '&times;' : '&#9776;';
    };

    // Populate mount grid buttons
    (function buildMountGrid() {
      const grid = document.getElementById('dashMountGrid');
      if (!grid) return;
      MOUNT_TYPES.forEach((mt, idx) => {
        const btn = document.createElement('button');
        btn.className = 'dash-mount-btn';
        btn.innerHTML = `<span class="mount-icon">${mt.icon}</span>${mt.name}`;
        btn.onclick = () => dashSetMountAll(idx);
        grid.appendChild(btn);
      });
    })();

    // Dashboard actions ‚Äî emit via socket so ALL tabs sync
    let _hostSocket = null; // set after socket.io connects
    function emitHostCmd(action, data) {
      if (_hostSocket) _hostSocket.emit('host-command', { action, data });
    }

    window.dashSetMountAll = function(mountIdx) { emitHostCmd('mount-all', { mountIdx }); };
    window.dashRandomMountAll = function() { emitHostCmd('mount-random-all', {}); };
    window.dashRandomMountLeader = function() { emitHostCmd('mount-random-leader', {}); };
    window.dashTriggerEvent = function(evtKey) { emitHostCmd('trigger-event', { evtKey }); };
    window.dashBoostAll = function() { emitHostCmd('boost-all', { amount: 10 }); };
    window.dashShuffleAll = function() { emitHostCmd('shuffle-all', {}); };
    window.dashResetPositions = function() { emitHostCmd('reset-positions', {}); };

    // Execute host commands locally (called by socket listener for ALL clients)
    function executeHostCommand(cmd) {
      const { action, data } = cmd;
      switch (action) {
        case 'mount-all': {
          let count = 0;
          players.forEach(p => { if (p.mesh) { swapMount(p, data.mountIdx); count++; } });
          const mt = MOUNT_TYPES[data.mountIdx];
          showNotif(`${mt.icon} Host changed ALL ${count} riders to <strong>${mt.name}</strong>!`, 'event');
          break;
        }
        case 'mount-random-all': {
          let count = 0;
          players.forEach(p => { if (p.mesh) { swapMount(p, Math.floor(Math.random() * MOUNT_TYPES.length)); count++; } });
          showNotif(`üé≤ Host gave <strong>${count} riders</strong> random mounts!`, 'event');
          break;
        }
        case 'mount-random-leader': {
          let leader = null, best = -1;
          players.forEach(p => { if (p.tilePos > best) { best = p.tilePos; leader = p; } });
          if (leader && leader.mesh) {
            const idx = swapMount(leader, Math.floor(Math.random() * MOUNT_TYPES.length));
            const mt = MOUNT_TYPES[idx];
            showNotif(`üèÜ Host gave leader <strong>${leader.nickname}</strong> a ${mt.icon} <strong>${mt.name}</strong>!`, 'event');
          }
          break;
        }
        case 'trigger-event': {
          const map = { dragon: 0, meteor: 1, speed: 2, quake: 3 };
          const evt = RANDOM_EVENTS[map[data.evtKey] || 0];
          triggerRandomEvent(evt, 'Host');
          break;
        }
        case 'boost-all': {
          let count = 0;
          players.forEach(p => { p.tilePos += (data.amount || 10); count++; });
          showNotif(`‚ö° Host boosted ALL <strong>${count} runners</strong> +${data.amount || 10} tiles!`, 'event');
          break;
        }
        case 'shuffle-all': {
          players.forEach(p => {
            if (p.mesh) {
              const lane = Math.floor(Math.random() * LANE_COUNT);
              p.lane = lane;
              p.mesh.position.x = getLaneX(lane);
            }
          });
          showNotif(`üîÄ Host shuffled all runners to random lanes!`, 'event');
          break;
        }
        case 'reset-positions': {
          players.forEach(p => { p.tilePos = 0; });
          showNotif(`üîÑ Host <strong>reset</strong> all positions to 0!`, 'gift');
          break;
        }
        case 'change-env': {
          applyEnvironment(data.envIdx);
          showNotif(`üåç Environment changed to <strong>${ENVIRONMENTS[envIndex].name}</strong>!`, 'event');
          break;
        }
      }
    }

    // ===== THREE.JS SETUP =====
    const canvas = document.getElementById('game-canvas');
    const gameFrame = document.getElementById('gameFrame');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: false });
    renderer.setPixelRatio(1);
    const initSize = getGameSize();
    renderer.setSize(initSize.width, initSize.height);
    renderer.sortObjects = true;

    const scene = new THREE.Scene();
    const env = ENVIRONMENTS[envIndex];
    scene.background = new THREE.Color(env.sky);
    scene.fog = new THREE.Fog(env.fog, FOG_NEAR, FOG_FAR);

    // Portrait-aware camera: higher FOV and closer for narrow screens
    function isPortrait() { return isPortraitForced || window.innerHeight > window.innerWidth * 1.2; }
    function getCameraFOV() { return isPortrait() ? 75 : 60; }
    function getCameraOffset() { return isPortrait() ? { y: 10, z: -8, lookY: 0.5, lookZ: 18 } : { y: 8, z: -12, lookY: 1, lookZ: 25 }; }
    function getGameSize() {
      if (isPortraitForced) {
        const h = window.innerHeight;
        const w = Math.floor(h * 9 / 16);
        return { width: Math.min(w, window.innerWidth), height: h };
      }
      return { width: window.innerWidth, height: window.innerHeight };
    }

    const gs = getGameSize();
    const camera = new THREE.PerspectiveCamera(getCameraFOV(), gs.width / gs.height, 0.5, 300);
    const camOff = getCameraOffset();
    camera.position.set(0, camOff.y, camOff.z);
    camera.lookAt(0, camOff.lookY, camOff.lookZ);

    // ===== LIGHTS =====
    const ambientLight = new THREE.AmbientLight(0x666666);
    scene.add(ambientLight);
    const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
    dirLight.position.set(5, 15, 10);
    scene.add(dirLight);
    const hemiLight = new THREE.HemisphereLight(0x88aaff, 0x445522, 0.5);
    scene.add(hemiLight);

    // ===== PARTICLE POINTS =====
    const particleGeo = new THREE.BufferGeometry();
    particleGeo.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
    particleGeo.setAttribute('color', new THREE.BufferAttribute(particleColors, 3));
    particleGeo.setAttribute('size', new THREE.BufferAttribute(particleSizes, 1));
    const particleMat = new THREE.PointsMaterial({
      size: 0.3, vertexColors: true, transparent: true, opacity: 0.9,
      depthWrite: false, blending: THREE.AdditiveBlending, sizeAttenuation: true
    });
    const particlePoints = new THREE.Points(particleGeo, particleMat);
    scene.add(particlePoints);

    // ===== TRAIL POINTS =====
    const trailGeo = new THREE.BufferGeometry();
    trailGeo.setAttribute('position', new THREE.BufferAttribute(trailPositions, 3));
    trailGeo.setAttribute('color', new THREE.BufferAttribute(trailColors, 3));
    trailGeo.setAttribute('size', new THREE.BufferAttribute(trailSizes, 1));
    const trailMat = new THREE.PointsMaterial({
      size: 0.15, vertexColors: true, transparent: true, opacity: 0.6,
      depthWrite: false, blending: THREE.AdditiveBlending, sizeAttenuation: true
    });
    const trailPoints = new THREE.Points(trailGeo, trailMat);
    scene.add(trailPoints);

    // ===== PARTICLE HELPERS =====
    function spawnGiftParticles(x, y, z, color, count) {
      const r = ((color >> 16) & 0xff) / 255;
      const g = ((color >> 8) & 0xff) / 255;
      const b = (color & 0xff) / 255;
      for (let i = 0; i < count; i++) {
        const idx = nextParticle % MAX_PARTICLES;
        nextParticle++;
        const angle = Math.random() * Math.PI * 2;
        const speed = 1.5 + Math.random() * 4;
        const upSpeed = 3 + Math.random() * 5;
        particlePositions[idx * 3] = x + (Math.random() - 0.5) * 0.5;
        particlePositions[idx * 3 + 1] = y + 1.5;
        particlePositions[idx * 3 + 2] = z + (Math.random() - 0.5) * 0.5;
        // Mix gift color with white/gold for sparkle
        const mix = Math.random() * 0.4;
        particleColors[idx * 3] = r * (1 - mix) + mix;
        particleColors[idx * 3 + 1] = g * (1 - mix) + mix * 0.85;
        particleColors[idx * 3 + 2] = b * (1 - mix) + mix * 0.2;
        particleSizes[idx] = 0.2 + Math.random() * 0.4;
        particleVelocities[idx] = {
          vx: Math.cos(angle) * speed * 0.5,
          vy: upSpeed,
          vz: Math.sin(angle) * speed * 0.5,
          life: 1.0,
          maxLife: 0.8 + Math.random() * 0.7
        };
      }
    }

    function spawnStunParticles(x, y, z) {
      for (let i = 0; i < 15; i++) {
        const idx = nextParticle % MAX_PARTICLES;
        nextParticle++;
        const angle = Math.random() * Math.PI * 2;
        particlePositions[idx * 3] = x;
        particlePositions[idx * 3 + 1] = y + 1;
        particlePositions[idx * 3 + 2] = z;
        particleColors[idx * 3] = 1;
        particleColors[idx * 3 + 1] = 0.3;
        particleColors[idx * 3 + 2] = 0.2;
        particleSizes[idx] = 0.3;
        particleVelocities[idx] = {
          vx: Math.cos(angle) * 3, vy: 2 + Math.random() * 3, vz: Math.sin(angle) * 3,
          life: 1.0, maxLife: 0.6 + Math.random() * 0.4
        };
      }
    }

    function spawnTrail(x, y, z, color) {
      const idx = nextTrail % MAX_TRAILS;
      nextTrail++;
      const r = ((color >> 16) & 0xff) / 255;
      const g = ((color >> 8) & 0xff) / 255;
      const b = (color & 0xff) / 255;
      trailPositions[idx * 3] = x + (Math.random() - 0.5) * 0.3;
      trailPositions[idx * 3 + 1] = y + 0.15;
      trailPositions[idx * 3 + 2] = z + (Math.random() - 0.5) * 0.2;
      trailColors[idx * 3] = r;
      trailColors[idx * 3 + 1] = g;
      trailColors[idx * 3 + 2] = b;
      trailSizes[idx] = 0.1 + Math.random() * 0.15;
      trailMeta[idx] = { life: 1.0, maxLife: 0.5 + Math.random() * 0.5 };
    }

    function updateParticles(dt) {
      for (let i = 0; i < MAX_PARTICLES; i++) {
        const v = particleVelocities[i];
        if (v.life <= 0) continue;
        v.life -= dt / v.maxLife;
        if (v.life <= 0) {
          particlePositions[i * 3 + 1] = -100;
          particleSizes[i] = 0;
          continue;
        }
        particlePositions[i * 3] += v.vx * dt;
        particlePositions[i * 3 + 1] += v.vy * dt;
        particlePositions[i * 3 + 2] += v.vz * dt;
        v.vy -= 9.8 * dt; // gravity
        particleSizes[i] *= (1 - dt * 1.5); // shrink
      }
      particleGeo.attributes.position.needsUpdate = true;
      particleGeo.attributes.color.needsUpdate = true;
      particleGeo.attributes.size.needsUpdate = true;
    }

    function updateTrails(dt) {
      for (let i = 0; i < MAX_TRAILS; i++) {
        const m = trailMeta[i];
        if (m.life <= 0) continue;
        m.life -= dt / m.maxLife;
        if (m.life <= 0) {
          trailPositions[i * 3 + 1] = -100;
          trailSizes[i] = 0;
          continue;
        }
        trailSizes[i] *= (1 - dt * 2);
        trailPositions[i * 3 + 1] += dt * 0.3; // slight float up
      }
      trailGeo.attributes.position.needsUpdate = true;
      trailGeo.attributes.color.needsUpdate = true;
      trailGeo.attributes.size.needsUpdate = true;
    }

    function triggerGiftFlash(color) {
      const flash = document.getElementById('giftFlash');
      flash.style.background = `radial-gradient(ellipse at center, ${color}44 0%, transparent 70%)`;
      flash.classList.remove('active');
      void flash.offsetWidth; // force reflow
      flash.classList.add('active');
    }

    // ===== RANDOM EVENT SYSTEM =====
    function triggerRandomEvent(eventType, creditName) {
      if (activeEvent) return; // don't overlap events
      const evt = eventType || RANDOM_EVENTS[Math.floor(Math.random() * RANDOM_EVENTS.length)];
      const now = Date.now();
      activeEvent = { type: evt, startTime: now, duration: evt.duration };

      // Show big center notification
      const el = document.getElementById('eventNotif');
      const colorHex = '#' + evt.color.toString(16).padStart(6, '0');
      el.innerHTML = `<span class="event-icon">${evt.icon}</span><div class="event-label" style="color:${colorHex}">${evt.name}!</div>${creditName ? `<div class="event-credit">Triggered by ${creditName}</div>` : ''}`;
      el.classList.remove('show');
      void el.offsetWidth;
      el.classList.add('show');
      setTimeout(() => el.classList.remove('show'), 3000);

      // Spawn particles across the road at leader position
      const leaderZ = getLeaderTile() * TILE;
      for (let i = 0; i < 30; i++) {
        const x = (Math.random() - 0.5) * ROAD_WIDTH;
        spawnGiftParticles(x, 3, leaderZ + Math.random() * 20, evt.color, 3);
      }

      // Apply event effects
      if (evt.name === 'Dragon Attack') {
        // Stun all players in 2 random lanes for 2s
        const lane1 = Math.floor(Math.random() * LANE_COUNT);
        let lane2;
        do { lane2 = Math.floor(Math.random() * LANE_COUNT); } while (lane2 === lane1);
        players.forEach(p => {
          if (p.lane === lane1 || p.lane === lane2) {
            p.isStunned = true;
            p.stunStart = now;
          }
        });
        triggerGiftFlash('#ff2200');
        showNotif(`üêâ <strong>Dragon Attack!</strong> Lanes ${lane1 + 1} & ${lane2 + 1} stunned!`, 'gift');
      } else if (evt.name === 'Meteor Shower') {
        // Random players pushed back 3 tiles
        players.forEach(p => {
          if (Math.random() < 0.4) {
            p.targetTile = Math.max(0, p.tilePos - 3);
            spawnStunParticles(p.mesh.position.x, p.mesh.position.y, p.mesh.position.z);
          }
        });
        triggerGiftFlash('#ff8800');
        showNotif(`‚òÑÔ∏è <strong>Meteor Shower!</strong> Some runners knocked back!`, 'gift');
      } else if (evt.name === 'Speed Wave') {
        // ALL players get +5 tiles forward
        players.forEach(p => {
          p.targetTile += 5;
        });
        triggerGiftFlash('#00ff88');
        showNotif(`üåä <strong>Speed Wave!</strong> Everyone surges +5 tiles!`, 'gift');
      } else if (evt.name === 'Earthquake') {
        // Screen shake + all players randomize lanes
        cameraShakeAmount = 1.0;
        players.forEach(p => {
          p.lane = Math.floor(Math.random() * LANE_COUNT);
        });
        triggerGiftFlash('#aa6633');
        showNotif(`üåã <strong>Earthquake!</strong> Everyone shuffled to random lanes!`, 'gift');
      }
    }

    // ===== SUN =====
    const sunGeo = new THREE.SphereGeometry(8, 12, 8);
    const sunMat = new THREE.MeshBasicMaterial({ color: env.sun });
    const sunMesh = new THREE.Mesh(sunGeo, sunMat);
    sunMesh.position.set(40, 60, 200);
    scene.add(sunMesh);

    // ===== CLOUDS =====
    const cloudGroup = new THREE.Group();
    const cloudMat = new THREE.MeshLambertMaterial({ color: 0xffffff, transparent: true, opacity: 0.7, flatShading: true });
    for (let i = 0; i < 12; i++) {
      const cg = new THREE.Group();
      for (let j = 0; j < 3; j++) {
        const s = 3 + Math.random() * 5;
        const cGeo = new THREE.SphereGeometry(s, 6, 4);
        const cloud = new THREE.Mesh(cGeo, cloudMat);
        cloud.position.set((j - 1) * s * 0.8, Math.random() * 1, 0);
        cloud.scale.y = 0.4;
        cg.add(cloud);
      }
      cg.position.set(-80 + Math.random() * 160, 30 + Math.random() * 20, 50 + Math.random() * 150);
      cloudGroup.add(cg);
    }
    scene.add(cloudGroup);

    // ===== TERRAIN (sides of road) =====
    const terrainGroup = new THREE.Group();
    const terrainMat = new THREE.MeshLambertMaterial({ color: env.ground, flatShading: true });
    const terrainMatAlt = new THREE.MeshLambertMaterial({ color: env.groundAlt, flatShading: true });

    // Left terrain
    const tGeo = new THREE.PlaneGeometry(60, CHUNK_LENGTH * CHUNK_COUNT, 20, 40);
    // Add vertex displacement for hills
    const tPos = tGeo.attributes.position;
    for (let i = 0; i < tPos.count; i++) {
      const x = tPos.getX(i);
      const z = tPos.getZ(i);
      const dist = Math.max(0, (Math.abs(x) - 5) * 0.1);
      tPos.setY(i, Math.sin(z * 0.05) * 3 * dist + Math.sin(x * 0.1 + z * 0.08) * 2 * dist - 0.1);
    }
    tGeo.computeVertexNormals();

    const leftTerrain = new THREE.Mesh(tGeo, terrainMat);
    leftTerrain.rotation.x = -Math.PI / 2;
    leftTerrain.position.set(-ROAD_WIDTH / 2 - 30, 0, CHUNK_LENGTH * CHUNK_COUNT / 2);
    terrainGroup.add(leftTerrain);

    const rightTerrain = new THREE.Mesh(tGeo.clone(), terrainMatAlt);
    rightTerrain.rotation.x = -Math.PI / 2;
    rightTerrain.position.set(ROAD_WIDTH / 2 + 30, 0, CHUNK_LENGTH * CHUNK_COUNT / 2);
    terrainGroup.add(rightTerrain);
    scene.add(terrainGroup);

    // ===== MOUNTAINS =====
    const mountainGroup = new THREE.Group();
    const mtMat = new THREE.MeshLambertMaterial({ color: env.mountain, flatShading: true });
    for (let i = 0; i < 20; i++) {
      const w = 10 + Math.random() * 20;
      const h = 15 + Math.random() * 25;
      const shape = new THREE.Shape();
      shape.moveTo(-w / 2, 0);
      shape.lineTo(0, h);
      shape.lineTo(w / 2, 0);
      shape.closePath();
      const extGeo = new THREE.ExtrudeGeometry(shape, { depth: 5 + Math.random() * 10, bevelEnabled: false });
      const mt = new THREE.Mesh(extGeo, mtMat);
      const side = i % 2 === 0 ? -1 : 1;
      mt.position.set(side * (40 + Math.random() * 40), 0, i * 20 + Math.random() * 10);
      mt.rotation.y = side * 0.3;
      mountainGroup.add(mt);
    }
    scene.add(mountainGroup);

    // ===== ROAD CHUNKS =====
    const roadGroup = new THREE.Group();
    const roadMat = new THREE.MeshLambertMaterial({ color: env.road, flatShading: true });
    const roadMatAlt = new THREE.MeshLambertMaterial({ color: env.roadAlt, flatShading: true });
    const rumbleMat = new THREE.MeshLambertMaterial({ color: env.rumble });
    const rumbleMatAlt = new THREE.MeshLambertMaterial({ color: env.rumbleAlt });
    const laneMat = new THREE.MeshBasicMaterial({ color: 0xffffff });

    function createRoadChunk(index) {
      const group = new THREE.Group();
      const isEven = index % 2 === 0;

      // Road surface
      const roadGeo = new THREE.PlaneGeometry(ROAD_WIDTH, CHUNK_LENGTH);
      const road = new THREE.Mesh(roadGeo, isEven ? roadMat : roadMatAlt);
      road.rotation.x = -Math.PI / 2;
      road.position.y = 0.01;
      group.add(road);

      // Rumble strips
      const rumbleGeo = new THREE.PlaneGeometry(0.5, CHUNK_LENGTH);
      const leftRumble = new THREE.Mesh(rumbleGeo, isEven ? rumbleMat : rumbleMatAlt);
      leftRumble.rotation.x = -Math.PI / 2;
      leftRumble.position.set(-ROAD_WIDTH / 2 - 0.25, 0.02, 0);
      group.add(leftRumble);

      const rightRumble = new THREE.Mesh(rumbleGeo.clone(), isEven ? rumbleMat : rumbleMatAlt);
      rightRumble.rotation.x = -Math.PI / 2;
      rightRumble.position.set(ROAD_WIDTH / 2 + 0.25, 0.02, 0);
      group.add(rightRumble);

      // Lane dividers (dashed)
      for (let l = 1; l < LANE_COUNT; l++) {
        const lx = -ROAD_WIDTH / 2 + l * LANE_WIDTH;
        for (let d = -CHUNK_LENGTH / 2; d < CHUNK_LENGTH / 2; d += 4) {
          const dashGeo = new THREE.PlaneGeometry(0.1, 1.5);
          const dash = new THREE.Mesh(dashGeo, laneMat);
          dash.rotation.x = -Math.PI / 2;
          dash.position.set(lx, 0.03, d);
          group.add(dash);
        }
      }

      group.position.z = index * CHUNK_LENGTH + CHUNK_LENGTH / 2;
      group.userData = { chunkIndex: index };
      roadGroup.add(group);
      return group;
    }

    for (let i = 0; i < CHUNK_COUNT; i++) {
      roadChunks.push(createRoadChunk(i));
    }
    scene.add(roadGroup);

    // ===== SCENERY POOL =====
    const sceneryGroup = new THREE.Group();
    function createTree(color) {
      const g = new THREE.Group();
      // Trunk
      const trunkGeo = new THREE.CylinderGeometry(0.15, 0.2, 1.5, 5);
      const trunkMat = new THREE.MeshLambertMaterial({ color: 0x8B4513, flatShading: true });
      const trunk = new THREE.Mesh(trunkGeo, trunkMat);
      trunk.position.y = 0.75;
      g.add(trunk);
      // Foliage
      const foliageGeo = new THREE.ConeGeometry(1.2, 2.5, 6);
      const foliageMat = new THREE.MeshLambertMaterial({ color, flatShading: true });
      const foliage = new THREE.Mesh(foliageGeo, foliageMat);
      foliage.position.y = 2.5;
      g.add(foliage);
      return g;
    }

    function createRock(color) {
      const geo = new THREE.DodecahedronGeometry(0.6 + Math.random() * 0.5, 0);
      const mat = new THREE.MeshLambertMaterial({ color, flatShading: true });
      const rock = new THREE.Mesh(geo, mat);
      rock.position.y = 0.4;
      rock.rotation.set(Math.random(), Math.random(), Math.random());
      return rock;
    }

    for (let i = 0; i < MAX_SCENERY; i++) {
      const side = i % 2 === 0 ? -1 : 1;
      const xOff = ROAD_WIDTH / 2 + 3 + Math.random() * 15;
      const colors = env.sceneryColors;
      const color = colors[i % colors.length];
      const obj = i % 3 === 0 ? createRock(color) : createTree(color);
      obj.position.x = side * xOff;
      obj.position.z = i * 6;
      obj.userData = { baseZ: i * 6, side, xOff };
      sceneryPool.push(obj);
      sceneryGroup.add(obj);
    }
    scene.add(sceneryGroup);

    // ===== OBSTACLE POOL =====
    const obstacleGroup = new THREE.Group();

    function createObstacleMesh(type) {
      const g = new THREE.Group();
      const mat = new THREE.MeshLambertMaterial({ color: type.color, flatShading: true });

      if (type.name === 'rock') {
        const geo = new THREE.DodecahedronGeometry(0.5, 0);
        const m = new THREE.Mesh(geo, mat);
        m.position.y = 0.4;
        g.add(m);
      } else if (type.name === 'tree') {
        const tGeo = new THREE.CylinderGeometry(0.1, 0.15, 0.8, 5);
        const trunk = new THREE.Mesh(tGeo, new THREE.MeshLambertMaterial({ color: 0x8B4513, flatShading: true }));
        trunk.position.y = 0.4;
        g.add(trunk);
        const fGeo = new THREE.ConeGeometry(0.6, 1.2, 5);
        const fol = new THREE.Mesh(fGeo, mat);
        fol.position.y = 1.2;
        g.add(fol);
      } else if (type.name === 'water') {
        const geo = new THREE.PlaneGeometry(1.5, 1.5);
        const m = new THREE.Mesh(geo, new THREE.MeshLambertMaterial({ color: type.color, transparent: true, opacity: 0.7 }));
        m.rotation.x = -Math.PI / 2;
        m.position.y = 0.05;
        g.add(m);
      } else if (type.name === 'wall') {
        const geo = new THREE.BoxGeometry(1.8, 1.2, 0.4);
        const m = new THREE.Mesh(geo, mat);
        m.position.y = 0.6;
        g.add(m);
      } else if (type.name === 'fire') {
        // Fire: orange cone + red cone
        const geo1 = new THREE.ConeGeometry(0.3, 1.0, 5);
        const m1 = new THREE.Mesh(geo1, new THREE.MeshBasicMaterial({ color: 0xff4400 }));
        m1.position.y = 0.5;
        g.add(m1);
        const geo2 = new THREE.ConeGeometry(0.2, 0.6, 5);
        const m2 = new THREE.Mesh(geo2, new THREE.MeshBasicMaterial({ color: 0xffaa00 }));
        m2.position.y = 0.7;
        g.add(m2);
      } else if (type.name === 'bomb') {
        const geo = new THREE.SphereGeometry(0.35, 6, 4);
        const m = new THREE.Mesh(geo, mat);
        m.position.y = 0.35;
        g.add(m);
        // Fuse
        const fGeo = new THREE.CylinderGeometry(0.03, 0.03, 0.3, 4);
        const fuse = new THREE.Mesh(fGeo, new THREE.MeshBasicMaterial({ color: 0x888888 }));
        fuse.position.set(0, 0.65, 0);
        fuse.rotation.z = 0.3;
        g.add(fuse);
      }

      g.visible = false;
      obstacleGroup.add(g);
      return g;
    }

    // Pre-create obstacle meshes
    for (let i = 0; i < MAX_VISIBLE_OBSTACLES; i++) {
      const type = OBSTACLE_TYPES[i % OBSTACLE_TYPES.length];
      obstaclePool.push({ mesh: createObstacleMesh(type), type, inUse: false });
    }
    scene.add(obstacleGroup);

    // ===== ACTIVE OBSTACLES (logical) =====
    const activeObstacles = []; // { tile, lane, typeIndex, poolIndex }

    // ===== POWER-UP MESHES =====
    const powerupGroup = new THREE.Group();
    function createPowerupMesh(type) {
      const g = new THREE.Group();
      // Glowing gem shape
      const gemGeo = new THREE.OctahedronGeometry(0.4, 0);
      const gemMat = new THREE.MeshBasicMaterial({ color: type.color, transparent: true, opacity: 0.9 });
      const gem = new THREE.Mesh(gemGeo, gemMat);
      gem.position.y = 0.8;
      g.add(gem);
      // Outer glow ring
      const ringGeo = new THREE.TorusGeometry(0.5, 0.06, 6, 12);
      const ringMat = new THREE.MeshBasicMaterial({ color: type.color, transparent: true, opacity: 0.5 });
      const ring = new THREE.Mesh(ringGeo, ringMat);
      ring.position.y = 0.8;
      ring.rotation.x = Math.PI / 2;
      g.add(ring);
      g.visible = false;
      g.userData = { gem, ring };
      powerupGroup.add(g);
      return g;
    }
    for (let i = 0; i < MAX_POWERUPS; i++) {
      const type = POWERUP_TYPES[i % POWERUP_TYPES.length];
      powerupMeshPool.push({ mesh: createPowerupMesh(type), typeIndex: i % POWERUP_TYPES.length, inUse: false });
    }
    scene.add(powerupGroup);

    function generatePowerups(upToTile) {
      while (lastPowerupTile < upToTile) {
        lastPowerupTile += 8 + Math.floor(Math.random() * 12); // every 8-20 tiles
        if (lastPowerupTile < 10) continue;
        const lane = Math.floor(Math.random() * LANE_COUNT);
        const typeIdx = Math.floor(Math.random() * ROAD_POWERUP_COUNT); // only road-pickup types
        activePowerups.push({ tile: lastPowerupTile, lane, typeIndex: typeIdx, poolIndex: -1 });
      }
    }

    function updatePowerups(cameraZ, now) {
      // Remove passed powerups
      for (let i = activePowerups.length - 1; i >= 0; i--) {
        const pu = activePowerups[i];
        if (pu.tile * TILE < cameraZ - 20) {
          if (pu.poolIndex >= 0) {
            powerupMeshPool[pu.poolIndex].mesh.visible = false;
            powerupMeshPool[pu.poolIndex].inUse = false;
          }
          activePowerups.splice(i, 1);
        }
      }
      // Assign meshes and animate
      for (const pu of activePowerups) {
        const worldZ = pu.tile * TILE;
        if (worldZ < cameraZ - 10 || worldZ > cameraZ + FOG_FAR) continue;
        if (pu.poolIndex < 0) {
          const slot = powerupMeshPool.findIndex(p => !p.inUse);
          if (slot < 0) continue;
          pu.poolIndex = slot;
          powerupMeshPool[slot].inUse = true;
          powerupMeshPool[slot].typeIndex = pu.typeIndex;
        }
        const pm = powerupMeshPool[pu.poolIndex];
        pm.mesh.visible = true;
        pm.mesh.position.x = getLaneX(pu.lane);
        pm.mesh.position.z = worldZ;
        // Floating bob + spin
        const ud = pm.mesh.userData;
        ud.gem.rotation.y = now * 0.003;
        ud.gem.position.y = 0.8 + Math.sin(now * 0.004 + pu.tile) * 0.2;
        ud.ring.rotation.z = now * 0.002;
        ud.ring.position.y = ud.gem.position.y;
      }
    }

    function checkPowerupPickup(now) {
      players.forEach(p => {
        if (p.isStunned) return;
        for (let i = activePowerups.length - 1; i >= 0; i--) {
          const pu = activePowerups[i];
          if (Math.abs(pu.tile - p.tilePos) < 0.8 && pu.lane === p.lane) {
            const type = POWERUP_TYPES[pu.typeIndex];
            // Store in inventory (max 3)
            if (p.inventory.length < MAX_INVENTORY) {
              p.inventory.push(pu.typeIndex);
              sfxPowerup();
              spawnGiftParticles(p.mesh.position.x, p.mesh.position.y, p.mesh.position.z, type.color, 15);
              showNotif(`<strong>${p.nickname}</strong> picked up ${type.icon} ${type.name}!`);
              updateInventorySprite(p);
            }
            // Remove powerup from road
            if (pu.poolIndex >= 0) {
              powerupMeshPool[pu.poolIndex].mesh.visible = false;
              powerupMeshPool[pu.poolIndex].inUse = false;
            }
            activePowerups.splice(i, 1);
            break;
          }
        }
      });
    }

    // Use a power from inventory
    function usePower(p, slotIndex, now) {
      if (slotIndex >= p.inventory.length) return;
      const typeIdx = p.inventory[slotIndex];
      const type = POWERUP_TYPES[typeIdx];
      p.inventory.splice(slotIndex, 1);
      updateInventorySprite(p);
      activatePower(p, type, now);
    }

    // Activate a power effect (works for both inventory and gift-given powers)
    function activatePower(p, type, now) {
      sfxPowerup();
      spawnGiftParticles(p.mesh.position.x, p.mesh.position.y, p.mesh.position.z, type.color, 25);

      const notifEl = document.getElementById('powerupNotif');
      notifEl.textContent = `${type.icon} ${p.nickname}: ${type.name}!`;
      notifEl.classList.remove('show');
      void notifEl.offsetWidth;
      notifEl.classList.add('show');

      if (type.effect === 'speed') {
        p.targetTile += 5;
        showNotif(`<strong>${p.nickname}</strong> ${type.icon} Speed Boost! +5 tiles!`, 'gift');
      } else if (type.effect === 'shield') {
        p.hasShield = true;
        showNotif(`<strong>${p.nickname}</strong> ${type.icon} Shield activated!`);
      } else if (type.effect === 'lightning') {
        let target = null, minDist = Infinity;
        players.forEach(other => {
          if (other.id === p.id || other.isStunned) return;
          const dist = Math.abs(other.tilePos - p.tilePos);
          if (dist < 15 && dist < minDist) { minDist = dist; target = other; }
        });
        if (target) {
          target.isStunned = true;
          target.stunStart = now;
          spawnStunParticles(target.mesh.position.x, target.mesh.position.y, target.mesh.position.z);
          sfxHit();
          showNotif(`<strong>${p.nickname}</strong> ${type.icon} zapped <strong>${target.nickname}</strong>!`, 'gift');
        } else {
          p.targetTile += 3;
          showNotif(`<strong>${p.nickname}</strong> ${type.icon} No target, +3 tiles!`, 'gift');
        }
      } else if (type.effect === 'magnet') {
        const ahead = activeObstacles.filter(o => o.tile > p.tilePos && o.tile < p.tilePos + 10);
        const blocked = new Set(ahead.map(o => o.lane));
        let bestLane = p.lane;
        for (let l = 0; l < LANE_COUNT; l++) {
          if (!blocked.has(l)) { bestLane = l; break; }
        }
        p.lane = bestLane;
        p.targetTile += 2;
        showNotif(`<strong>${p.nickname}</strong> ${type.icon} Magnet! Safe lane +2!`, 'gift');
      } else if (type.effect === 'kick') {
        // Mega Kick: send nearest player back 15 tiles!
        let target = null, minDist = Infinity;
        players.forEach(other => {
          if (other.id === p.id || other.isStunned) return;
          const dist = Math.abs(other.tilePos - p.tilePos);
          if (dist < 20 && dist < minDist) { minDist = dist; target = other; }
        });
        if (target) {
          target.targetTile = Math.max(0, target.tilePos - 15);
          target.tilePos = target.targetTile;
          target.isStunned = true;
          target.stunStart = now;
          spawnStunParticles(target.mesh.position.x, target.mesh.position.y, target.mesh.position.z);
          triggerGiftFlash('#ff2222');
          sfxHit();
          showNotif(`<strong>${p.nickname}</strong> ${type.icon} KICKED <strong>${target.nickname}</strong> back 15 tiles!`, 'gift');
        } else {
          p.targetTile += 5;
          showNotif(`<strong>${p.nickname}</strong> ${type.icon} No target! +5 tiles instead!`, 'gift');
        }
      } else if (type.effect === 'pushout') {
        // Push Out: push nearest player to random lane + stun 3s
        let target = null, minDist = Infinity;
        players.forEach(other => {
          if (other.id === p.id || other.isStunned) return;
          const dist = Math.abs(other.tilePos - p.tilePos);
          if (dist < 15 && dist < minDist) { minDist = dist; target = other; }
        });
        if (target) {
          // Push to a different lane
          let newLane;
          do { newLane = Math.floor(Math.random() * LANE_COUNT); } while (newLane === target.lane);
          target.lane = newLane;
          target.isStunned = true;
          target.stunStart = now - (STUN_DURATION - 3000); // 3 second stun
          spawnStunParticles(target.mesh.position.x, target.mesh.position.y, target.mesh.position.z);
          triggerGiftFlash('#ff8800');
          sfxHit();
          showNotif(`<strong>${p.nickname}</strong> ${type.icon} PUSHED <strong>${target.nickname}</strong> off-lane!`, 'gift');
        } else {
          p.targetTile += 3;
          showNotif(`<strong>${p.nickname}</strong> ${type.icon} No target! +3 tiles instead!`, 'gift');
        }
      }
    }

    // Visual inventory indicator floating beside character
    function updateInventorySprite(p) {
      const ud = p.mesh.userData;
      // Remove old inventory sprites
      if (ud.inventorySprites) {
        ud.inventorySprites.forEach(s => (ud.riderGroup || p.mesh).remove(s));
        ud.inventorySprites = null;
      }
      if (p.inventory.length === 0) return;

      ud.inventorySprites = [];
      p.inventory.forEach((typeIdx, i) => {
        const type = POWERUP_TYPES[typeIdx];
        const c = document.createElement('canvas');
        c.width = 128;
        c.height = 128;
        const ctx = c.getContext('2d');

        // Glowing background circle
        const gradient = ctx.createRadialGradient(64, 64, 20, 64, 64, 60);
        const hex = '#' + type.color.toString(16).padStart(6, '0');
        gradient.addColorStop(0, hex + 'ee');
        gradient.addColorStop(0.6, hex + '88');
        gradient.addColorStop(1, hex + '00');
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(64, 64, 58, 0, Math.PI * 2);
        ctx.fill();

        // Inner solid circle
        ctx.fillStyle = hex + 'cc';
        ctx.beginPath();
        ctx.arc(64, 64, 38, 0, Math.PI * 2);
        ctx.fill();

        // White border ring
        ctx.strokeStyle = '#ffffffdd';
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.arc(64, 64, 38, 0, Math.PI * 2);
        ctx.stroke();

        // Emoji icon (large)
        ctx.font = '40px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(type.icon, 64, 64);

        const tex = new THREE.CanvasTexture(c);
        const mat = new THREE.SpriteMaterial({ map: tex, transparent: true, depthWrite: false });
        const sprite = new THREE.Sprite(mat);
        sprite.scale.set(0.7, 0.7, 1);
        // Float to the right side of character, stacked vertically
        sprite.position.set(0.9, 0.8 + i * 0.75, 0);
        sprite.userData = { bobOffset: i * 1.2 }; // for floating animation
        (ud.riderGroup || p.mesh).add(sprite);
        ud.inventorySprites.push(sprite);
      });
    }

    // Animate inventory icons (gentle bob)
    function animateInventory(p, now) {
      const ud = p.mesh.userData;
      if (!ud.inventorySprites) return;
      ud.inventorySprites.forEach((sprite, i) => {
        const bob = Math.sin(now * 0.003 + sprite.userData.bobOffset) * 0.1;
        sprite.position.y = 0.8 + i * 0.75 + bob;
      });
    }

    // ===== CHARACTER FACTORY =====
    const playersGroup = new THREE.Group();
    scene.add(playersGroup);

    function hashColor(id) {
      let hash = 0;
      for (let i = 0; i < id.length; i++) hash = ((hash << 5) - hash + id.charCodeAt(i)) | 0;
      return PLAYER_COLORS[Math.abs(hash) % PLAYER_COLORS.length];
    }

    function createNameSprite(name) {
      const c = document.createElement('canvas');
      c.width = 256;
      c.height = 64;
      const ctx = c.getContext('2d');
      ctx.fillStyle = 'rgba(0,0,0,0.6)';
      ctx.roundRect(4, 4, 248, 56, 12);
      ctx.fill();
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 28px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      const display = name.length > 12 ? name.slice(0, 11) + '..' : name;
      ctx.fillText(display, 128, 32);

      const tex = new THREE.CanvasTexture(c);
      const mat = new THREE.SpriteMaterial({ map: tex, transparent: true, depthWrite: false });
      const sprite = new THREE.Sprite(mat);
      sprite.scale.set(2.5, 0.65, 1);
      return sprite;
    }

    // Create a profile photo sprite (circular, facing camera)
    function createProfileSprite(color) {
      // Start with a colored circle placeholder
      const c = document.createElement('canvas');
      c.width = 128;
      c.height = 128;
      const ctx = c.getContext('2d');

      // Circular clip
      ctx.beginPath();
      ctx.arc(64, 64, 60, 0, Math.PI * 2);
      ctx.closePath();
      ctx.fillStyle = '#' + color.toString(16).padStart(6, '0');
      ctx.fill();

      // Border
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 4;
      ctx.stroke();

      // Default face icon
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 48px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('üòä', 64, 64);

      const tex = new THREE.CanvasTexture(c);
      const mat = new THREE.SpriteMaterial({ map: tex, transparent: true, depthWrite: false });
      const sprite = new THREE.Sprite(mat);
      sprite.scale.set(0.7, 0.7, 1);
      sprite.userData = { canvas: c, texture: tex };
      return sprite;
    }

    // Load actual profile photo into the sprite
    function loadProfilePhoto(sprite, profilePicUrl) {
      if (!profilePicUrl) return;
      const proxyUrl = `/api/proxy-image?url=${encodeURIComponent(profilePicUrl)}`;
      const img = new Image();
      img.crossOrigin = 'anonymous';
      img.onload = () => {
        const c = sprite.userData.canvas;
        const ctx = c.getContext('2d');
        ctx.clearRect(0, 0, 128, 128);

        // Circular clip
        ctx.save();
        ctx.beginPath();
        ctx.arc(64, 64, 60, 0, Math.PI * 2);
        ctx.closePath();
        ctx.clip();

        // Draw profile pic
        const size = Math.min(img.width, img.height);
        const sx = (img.width - size) / 2;
        const sy = (img.height - size) / 2;
        ctx.drawImage(img, sx, sy, size, size, 4, 4, 120, 120);
        ctx.restore();

        // White border
        ctx.beginPath();
        ctx.arc(64, 64, 60, 0, Math.PI * 2);
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 4;
        ctx.stroke();

        sprite.userData.texture.needsUpdate = true;
      };
      img.onerror = () => {}; // Keep placeholder on error
      img.src = proxyUrl;
    }

    // Create chat bubble sprite
    function createChatBubble(text) {
      const c = document.createElement('canvas');
      c.width = 512;
      c.height = 128;
      const ctx = c.getContext('2d');

      const displayText = text.length > 25 ? text.slice(0, 24) + '..' : text;
      ctx.font = 'bold 26px sans-serif';
      const textWidth = Math.min(ctx.measureText(displayText).width + 40, 500);

      // Bubble background
      const bx = (512 - textWidth) / 2;
      ctx.fillStyle = 'rgba(255,255,255,0.95)';
      ctx.beginPath();
      ctx.roundRect(bx, 10, textWidth, 70, 16);
      ctx.fill();
      ctx.strokeStyle = 'rgba(0,0,0,0.15)';
      ctx.lineWidth = 2;
      ctx.stroke();

      // Tail triangle
      ctx.fillStyle = 'rgba(255,255,255,0.95)';
      ctx.beginPath();
      ctx.moveTo(246, 80);
      ctx.lineTo(256, 100);
      ctx.lineTo(266, 80);
      ctx.fill();

      // Text
      ctx.fillStyle = '#222';
      ctx.font = 'bold 26px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(displayText, 256, 46);

      const tex = new THREE.CanvasTexture(c);
      const mat = new THREE.SpriteMaterial({ map: tex, transparent: true, depthWrite: false });
      const sprite = new THREE.Sprite(mat);
      sprite.scale.set(3.5, 0.9, 1);
      return sprite;
    }

    function createCharacter(id, name, profilePic) {
      const color = hashColor(id);
      const mat = new THREE.MeshLambertMaterial({ color, flatShading: true });

      const group = new THREE.Group();

      // === RIDER SUB-GROUP (body + arms, no legs ‚Äî they're riding) ===
      const riderGroup = new THREE.Group();

      // Body
      const bodyGeo = new THREE.BoxGeometry(0.6, 0.7, 0.4);
      const body = new THREE.Mesh(bodyGeo, mat);
      body.position.y = 0;
      riderGroup.add(body);

      // Arms
      const armGeo = new THREE.CylinderGeometry(0.08, 0.08, 0.45, 5);
      const leftArm = new THREE.Mesh(armGeo, mat);
      leftArm.position.set(-0.38, -0.05, 0);
      riderGroup.add(leftArm);
      const rightArm = new THREE.Mesh(armGeo.clone(), mat);
      rightArm.position.set(0.38, -0.05, 0);
      riderGroup.add(rightArm);

      // Profile photo sprite
      const profileSprite = createProfileSprite(color);
      profileSprite.position.set(0, 0.65, -0.05);
      riderGroup.add(profileSprite);
      if (profilePic) loadProfilePhoto(profileSprite, profilePic);

      // Name label
      const nameSprite = createNameSprite(name);
      nameSprite.position.y = 1.2;
      riderGroup.add(nameSprite);

      // === MOUNT SUB-GROUP ===
      const mountDef = MOUNT_TYPES[DEFAULT_MOUNT_INDEX];
      const { mountGroup, animParts } = mountDef.build(color);
      group.add(mountGroup);

      // Position rider on mount
      riderGroup.position.y = mountDef.riderY;
      group.add(riderGroup);

      group.userData = {
        leftArm, rightArm, body,
        head: null, leftLeg: null, rightLeg: null,
        profileSprite,
        riderGroup,
        mountGroup,
        mountAnimParts: animParts,
        mountTypeIndex: DEFAULT_MOUNT_INDEX,
        chatBubble: null,
        chatTimer: null,
        animPhase: Math.random() * Math.PI * 2
      };

      return group;
    }

    // ===== PLAYER MANAGEMENT =====
    function addPlayer(data) {
      const id = (data.id || data.uniqueId || '').toString();
      if (!id) return null;

      let p = players.get(id);
      if (p) {
        p.lastActive = Date.now();
        p.fadeOut = 0; // reset fade if they come back
        p.mesh.visible = true;
        // Restore all children visibility (undo ghost state)
        p.mesh.traverse(child => {
          child.visible = true;
          if (child.material && child.material.opacity !== undefined) {
            child.material.opacity = 1;
          }
        });
        // Update profile pic if we didn't have one before
        if (data.profilePic && !p.hasProfilePic) {
          loadProfilePhoto(p.mesh.userData.profileSprite, data.profilePic);
          p.hasProfilePic = true;
          p.profilePicUrl = data.profilePic;
        }
        return p;
      }

      const mesh = createCharacter(id, data.nickname || data.uniqueId || 'Viewer', data.profilePic || '');
      // New joiners start slightly behind the leader ‚Äî visible on camera
      const leader = getLeaderTile();
      const startTile = Math.max(0, leader - 5);

      const lane = Math.floor(Math.random() * LANE_COUNT);
      mesh.position.x = getLaneX(lane);
      mesh.position.z = startTile * TILE;

      playersGroup.add(mesh);

      p = {
        id,
        nickname: data.nickname || data.uniqueId || 'Viewer',
        profilePicUrl: data.profilePic || '',
        mesh,
        tilePos: startTile,
        targetTile: startTile,
        lane,
        isJumping: false,
        jumpStart: 0,
        isStunned: false,
        stunStart: 0,
        totalDiamonds: 0,
        hasShield: false,
        inventory: [], // power-up type indices, max 3
        isPushedOut: false,
        hasProfilePic: !!data.profilePic,
        mountType: DEFAULT_MOUNT_INDEX,
        // Rate limiting for likes (anti-spam)
        lastLikeTime: 0,
        likeBank: 0,       // accumulated tiles from rapid likes
        likeBankMax: 8,     // max tiles queued from likes
        likeCooldown: 400,  // ms between like movements
        // Inactivity tracking
        lastActive: Date.now(),
        fadeOut: 0, // 0 = visible, 1 = fully faded
      };
      // Initial forward burst so they don't just stand still
      p.targetTile += 3;
      players.set(id, p);
      updateHUD();
      return p;
    }

    function getLaneX(lane) {
      return -ROAD_WIDTH / 2 + LANE_WIDTH / 2 + lane * LANE_WIDTH;
    }

    // ===== INACTIVE PLAYER CLEANUP =====
    const INACTIVE_FADE_START = 120000;  // 2min: start fading body
    const INACTIVE_GHOST_START = 180000; // 3min: hide body, show only name as ghost
    const INACTIVE_REMOVE = 300000;      // 5min: remove entirely

    function cleanupInactivePlayers(now) {
      const toRemove = [];
      players.forEach((p, id) => {
        const idle = now - p.lastActive;
        if (idle > INACTIVE_REMOVE) {
          // Fully inactive ‚Äî remove
          toRemove.push(id);
        } else if (idle > INACTIVE_GHOST_START) {
          // Ghost phase: hide body, keep only floating name
          p.fadeOut = 1;
          p.mesh.traverse(child => {
            if (child.isSprite && child.scale.x > 2) {
              // This is the name sprite ‚Äî keep visible but ghostly
              child.visible = true;
              child.material.transparent = true;
              child.material.opacity = 0.4;
            } else if (child !== p.mesh) {
              // Hide body parts and profile sprite
              child.visible = false;
            }
          });
        } else if (idle > INACTIVE_FADE_START) {
          // Fading out ‚Äî make character translucent
          p.fadeOut = (idle - INACTIVE_FADE_START) / (INACTIVE_GHOST_START - INACTIVE_FADE_START);
          p.mesh.traverse(child => {
            if (child.material && child.material.opacity !== undefined) {
              child.material.transparent = true;
              child.material.opacity = 1 - p.fadeOut * 0.8;
            }
          });
        }
      });

      for (const id of toRemove) {
        const p = players.get(id);
        if (p) {
          playersGroup.remove(p.mesh);
          const ud = p.mesh.userData;
          // Dispose mount geometry
          if (ud.mountGroup) {
            ud.mountGroup.traverse(child => {
              if (child.geometry) child.geometry.dispose();
              if (child.material) child.material.dispose();
            });
          }
          if (ud.inventorySprites) ud.inventorySprites.forEach(s => (ud.riderGroup || p.mesh).remove(s));
          if (ud.chatBubble) (ud.riderGroup || p.mesh).remove(ud.chatBubble);
          players.delete(id);
        }
      }

      if (toRemove.length > 0) updateHUD();
    }

    // ===== OBSTACLE GENERATION =====
    function generateObstacles(upToTile) {
      while (lastObstacleTile < upToTile) {
        lastObstacleTile += 3 + Math.floor(Math.random() * 4); // every 3-6 tiles
        if (Math.random() > OBSTACLE_CHANCE) continue;
        if (lastObstacleTile < 5) continue; // safe zone at start

        // Pick 1-3 lanes to block (never all 5)
        const blockedCount = 1 + Math.floor(Math.random() * 2);
        const lanes = [];
        while (lanes.length < blockedCount) {
          const l = Math.floor(Math.random() * LANE_COUNT);
          if (!lanes.includes(l)) lanes.push(l);
        }

        const typeIdx = Math.floor(Math.random() * OBSTACLE_TYPES.length);
        for (const lane of lanes) {
          activeObstacles.push({ tile: lastObstacleTile, lane, typeIndex: typeIdx, poolIndex: -1 });
        }
      }
    }

    function updateObstacles(cameraZ) {
      // Remove obstacles far behind camera
      for (let i = activeObstacles.length - 1; i >= 0; i--) {
        const obs = activeObstacles[i];
        const worldZ = obs.tile * TILE;
        if (worldZ < cameraZ - 20) {
          // Return pool mesh
          if (obs.poolIndex >= 0 && obstaclePool[obs.poolIndex]) {
            obstaclePool[obs.poolIndex].mesh.visible = false;
            obstaclePool[obs.poolIndex].inUse = false;
          }
          activeObstacles.splice(i, 1);
        }
      }

      // Assign pool meshes to visible obstacles
      for (const obs of activeObstacles) {
        const worldZ = obs.tile * TILE;
        if (worldZ < cameraZ - 10 || worldZ > cameraZ + FOG_FAR) continue;

        if (obs.poolIndex < 0) {
          // Find free pool slot
          const slot = obstaclePool.findIndex(p => !p.inUse);
          if (slot < 0) continue;
          obs.poolIndex = slot;
          obstaclePool[slot].inUse = true;
        }

        const pm = obstaclePool[obs.poolIndex];
        pm.mesh.visible = true;
        pm.mesh.position.x = getLaneX(obs.lane);
        pm.mesh.position.z = worldZ;
        pm.mesh.position.y = 0;
      }
    }

    // ===== COLLISION DETECTION =====
    function checkCollisions(now) {
      players.forEach(p => {
        if (p.isStunned || p.isJumping) return;

        const pz = p.tilePos;
        for (const obs of activeObstacles) {
          if (Math.abs(obs.tile - pz) < 0.8 && obs.lane === p.lane) {
            if (p.hasShield) {
              // Shield absorbs the hit
              p.hasShield = false;
              spawnGiftParticles(p.mesh.position.x, p.mesh.position.y, p.mesh.position.z, 0x44aaff, 15);
              sfxPowerup();
              showNotif(`${p.nickname}'s shield blocked the ${OBSTACLE_TYPES[obs.typeIndex].name}!`);
              break;
            }
            // Hit!
            p.isStunned = true;
            p.stunStart = now;
            spawnStunParticles(p.mesh.position.x, p.mesh.position.y, p.mesh.position.z);
            sfxHit();
            p.tilePos = Math.max(0, p.tilePos - 2); // pushback
            p.targetTile = p.tilePos;
            showNotif(`${p.nickname} hit a ${OBSTACLE_TYPES[obs.typeIndex].name}!`);
            break;
          }
        }
      });
    }

    // ===== ENVIRONMENT SWITCHING =====
    function getLeaderTile() {
      let max = 0;
      players.forEach(p => { if (p.tilePos > max) max = p.tilePos; });
      return max;
    }

    function applyEnvironment(idx) {
      envIndex = idx % ENVIRONMENTS.length;
      const e = ENVIRONMENTS[envIndex];
      scene.background.set(e.sky);
      scene.fog.color.set(e.fog);
      scene.fog.near = FOG_NEAR;
      scene.fog.far = FOG_FAR;
      sunMesh.material.color.set(e.sun);
      terrainMat.color.set(e.ground);
      terrainMatAlt.color.set(e.groundAlt);
      roadMat.color.set(e.road);
      roadMatAlt.color.set(e.roadAlt);
      rumbleMat.color.set(e.rumble);
      rumbleMatAlt.color.set(e.rumbleAlt);
      mtMat.color.set(e.mountain);
      document.getElementById('envBadge').textContent = e.name;
    }

    function checkEnvironmentChange() {
      const leader = getLeaderTile();
      const expectedEnv = Math.floor(leader / ENV_INTERVAL) % ENVIRONMENTS.length;
      if (expectedEnv !== envIndex) {
        applyEnvironment(expectedEnv);
      }
    }

    window.nextEnvironment = function() {
      const nextIdx = (envIndex + 1) % ENVIRONMENTS.length;
      emitHostCmd('change-env', { envIdx: nextIdx });
    };

    // ===== ANIMATION =====
    function animateCharacter(p, now, dt) {
      const ud = p.mesh.userData;
      const isMoving = !p.isStunned; // always animate running (auto-walk keeps everyone moving)

      // Run animation ‚Äî speed varies with actual movement speed
      const moveSpeed = Math.abs(p.targetTile - p.tilePos);
      if (isMoving || p.isJumping) {
        const animSpeed = 3 + Math.min(moveSpeed, 5) * 2;
        ud.animPhase += dt * animSpeed;
        const swing = Math.sin(ud.animPhase) * (0.3 + Math.min(moveSpeed, 3) * 0.15);
        // Rider arms sway gently (holding reins)
        ud.leftArm.rotation.x = swing * 0.4;
        ud.rightArm.rotation.x = -swing * 0.4;
        // Mount animation
        animateMount(ud, ud.animPhase, swing, dt);
      } else {
        // Idle breathing
        ud.animPhase += dt * 1.5;
        const idle = Math.sin(ud.animPhase) * 0.05;
        ud.leftArm.rotation.x = idle;
        ud.rightArm.rotation.x = -idle;
        animateMount(ud, ud.animPhase, idle * 0.3, dt);
      }

      // Jump arc
      if (p.isJumping) {
        const elapsed = now - p.jumpStart;
        if (elapsed >= JUMP_DURATION) {
          p.isJumping = false;
          p.mesh.position.y = 0;
        } else {
          const t = elapsed / JUMP_DURATION;
          p.mesh.position.y = Math.sin(t * Math.PI) * 2.5;
        }
      }

      // Stun wobble
      if (p.isStunned) {
        const elapsed = now - p.stunStart;
        if (elapsed >= STUN_DURATION) {
          p.isStunned = false;
          p.mesh.rotation.z = 0;
          // Switch lane randomly on recovery
          p.lane = Math.floor(Math.random() * LANE_COUNT);
        } else {
          p.mesh.rotation.z = Math.sin(elapsed * 0.02) * 0.3;
          // Flash effect
          const flash = Math.sin(elapsed * 0.015) > 0;
          ud.body.visible = flash;
        }
      } else {
        ud.body.visible = true;
        p.mesh.rotation.z = 0;
      }

      // Chat bubble float animation
      if (ud.chatBubble) {
        ud.chatBubble.position.y = 1.8 + Math.sin(now * 0.003) * 0.1;
      }

      // Smooth movement toward target position
      const targetZ = p.targetTile * TILE;
      const targetX = getLaneX(p.lane);
      const prevZ = p.mesh.position.z;
      p.mesh.position.z += (targetZ - p.mesh.position.z) * Math.min(1, dt * 5);
      p.mesh.position.x += (targetX - p.mesh.position.x) * Math.min(1, dt * 8);

      // Trail effect when running
      const speed = Math.abs(p.mesh.position.z - prevZ);
      if (speed > 0.05 && !p.isStunned) {
        // Spawn trail particles behind the character
        if (Math.random() < Math.min(speed * 3, 0.8)) {
          const color = hashColor(p.id);
          spawnTrail(p.mesh.position.x, p.mesh.position.y, p.mesh.position.z - 0.5, color);
        }
      }

      // Animate floating inventory icons
      animateInventory(p, now);

      // Update logical tile position (for collision)
      p.tilePos += (p.targetTile - p.tilePos) * Math.min(1, dt * 5);
    }

    // ===== CAMERA =====
    function updateCamera(dt) {
      if (players.size === 0) return;

      // Track the leader (max tilePos) so viewers see the front of the race
      const leader = getLeaderTile() * TILE;

      // Target: look at leader, positioned behind (portrait-aware)
      const co = getCameraOffset();
      const targetZ = leader + co.z;
      const targetY = co.y + players.size * 0.05; // rise slightly with more players

      camera.position.z += (targetZ - camera.position.z) * Math.min(1, dt * 2);
      camera.position.y += (targetY - camera.position.y) * Math.min(1, dt * 2);

      // Earthquake camera shake
      if (cameraShakeAmount > 0) {
        camera.position.x += (Math.random() - 0.5) * cameraShakeAmount * 0.5;
        camera.position.y += (Math.random() - 0.5) * cameraShakeAmount * 0.3;
      }

      camera.lookAt(0, co.lookY, camera.position.z + co.lookZ);

      cameraTargetZ = camera.position.z;
    }

    // ===== ROAD RECYCLING =====
    let nextChunkIndex = CHUNK_COUNT;

    function recycleRoads() {
      const camZ = camera.position.z;
      for (const chunk of roadChunks) {
        const chunkZ = chunk.position.z;
        if (chunkZ < camZ - CHUNK_LENGTH * 2) {
          chunk.position.z = nextChunkIndex * CHUNK_LENGTH + CHUNK_LENGTH / 2;
          chunk.userData.chunkIndex = nextChunkIndex;
          nextChunkIndex++;
        }
      }
    }

    // ===== SCENERY RECYCLING =====
    function recycleScenery() {
      const camZ = camera.position.z;
      for (const obj of sceneryPool) {
        if (obj.position.z < camZ - 30) {
          obj.position.z += MAX_SCENERY * 6;
          obj.userData.baseZ = obj.position.z;
        }
      }
    }

    // ===== TERRAIN FOLLOW =====
    function updateTerrain() {
      const camZ = camera.position.z;
      const tz = Math.floor(camZ / (CHUNK_LENGTH * CHUNK_COUNT)) * CHUNK_LENGTH * CHUNK_COUNT;
      leftTerrain.position.z = tz + CHUNK_LENGTH * CHUNK_COUNT / 2;
      rightTerrain.position.z = tz + CHUNK_LENGTH * CHUNK_COUNT / 2;

      // Mountains follow loosely
      mountainGroup.position.z = camZ * 0.8;
    }

    // ===== HUD =====
    function updateHUD() {
      document.getElementById('runnerCount').textContent = players.size;

      // Leader distance
      const leader = getLeaderTile();
      document.getElementById('leaderDist').textContent = Math.floor(leader * 2);

      // Podium
      const sorted = [...players.values()].sort((a, b) => b.tilePos - a.tilePos);
      const top3 = sorted.slice(0, 3);
      const medals = ['ü•á', 'ü•à', 'ü•â'];
      const podiumEl = document.getElementById('podiumList');
      podiumEl.innerHTML = top3.map((p, i) => {
        const avatarHtml = p.profilePicUrl
          ? `<img class="podium-avatar" src="/api/proxy-image?url=${encodeURIComponent(p.profilePicUrl)}" onerror="this.style.display='none'" />`
          : '';
        return `<div class="podium-row">
          <span class="podium-medal">${medals[i]}</span>
          ${avatarHtml}
          <span class="podium-name">${p.nickname}</span>
          <span class="podium-dist">${Math.floor(p.tilePos * 2)}m</span>
        </div>`;
      }).join('');
    }

    function showNotif(html, cls = '') {
      const area = document.getElementById('bannerArea');
      const div = document.createElement('div');
      div.className = `banner ${cls}`;
      div.innerHTML = html;
      area.appendChild(div);
      // Remove after animation (tips stay longer)
      const dur = cls === 'tip' ? 6200 : 3800;
      setTimeout(() => div.remove(), dur);
      // Keep max 3 banners visible at a time
      while (area.children.length > 3) area.firstChild.remove();
    }

    // ===== RANDOM TIPS / HOW-TO REMINDERS =====
    const GAME_TIPS = [
      // How to run / move
      { icon: '‚ù§Ô∏è', text: 'Tap the <strong>Like</strong> button to make your runner move forward!' },
      { icon: '‚ù§Ô∏è', text: 'Spam those <strong>Likes</strong> to run faster! Each like = +1 tile!' },
      { icon: 'üí¨', text: 'Type <strong>"jump"</strong> in chat to dodge obstacles!' },
      { icon: 'üí¨', text: 'Type <strong>"left"</strong> or <strong>"right"</strong> to switch lanes!' },
      { icon: 'üí¨', text: 'Malay commands work too! <strong>"lompat"</strong>, <strong>"kiri"</strong>, <strong>"kanan"</strong>' },
      { icon: '‚≠ê', text: '<strong>Follow</strong> for an instant +3 tile boost!' },
      // Gifts & powers
      { icon: 'üéÅ', text: 'Send a <strong>Gift</strong> to get exclusive powers like Mega Kick & Push Out!' },
      { icon: 'üéÅ', text: 'Gifts give you <strong>combat powers</strong> ‚Äî kick rivals back or push them off-lane!' },
      { icon: 'üéÅ', text: 'Big gifts (50+ diamonds) trigger <strong>random events</strong> for everyone!' },
      { icon: '‚ö°', text: 'Pick up <strong>road power-ups</strong>: Speed Boost, Shield, Lightning, Magnet!' },
      { icon: 'üí¨', text: 'Type <strong>"use"</strong> or <strong>"power"</strong> in chat to activate your stored power!' },
      // Strategy
      { icon: 'üõ°', text: '<strong>Shield</strong> blocks one obstacle hit ‚Äî grab it before a fire zone!' },
      { icon: 'üß≤', text: '<strong>Magnet</strong> pulls you 8 tiles forward + auto-collects nearby power-ups!' },
      { icon: 'ü¶µ', text: '<strong>Mega Kick</strong> sends the nearest rival 15 tiles backwards!' },
      { icon: 'üí®', text: '<strong>Push Out</strong> shoves a rival to a random lane + stuns them!' },
      // Events
      { icon: 'üêâ', text: 'Watch out for <strong>Dragon Attack</strong> ‚Äî it stuns 2 random lanes!' },
      { icon: 'üåä', text: '<strong>Speed Wave</strong> pushes everyone +5 tiles forward ‚Äî free boost!' },
      { icon: '‚òÑÔ∏è', text: '<strong>Meteor Shower</strong> can knock you back ‚Äî stay alert!' },
      { icon: 'üåã', text: '<strong>Earthquake</strong> shuffles everyone to random lanes!' },
      // General
      { icon: 'üèÜ', text: 'Race to the <strong>top 3</strong> podium! Like, Gift & Chat to climb!' },
      { icon: 'üèÉ', text: 'Everyone auto-walks slowly ‚Äî <strong>Like</strong> to sprint ahead of the pack!' },
      { icon: 'üíé', text: 'Your runner joins automatically when you <strong>interact</strong> ‚Äî like, chat, or gift!' },
      // Mounts
      { icon: 'üê¥', text: 'Everyone starts on a <strong>Horse</strong>! Send a gift to get a random mount!' },
      { icon: 'üéÅ', text: '10 mounts to collect: Horse, Motorcycle, Whale, Panda, Bear, Dragon, Unicorn, Tiger, Bull, Phoenix!' },
      { icon: 'üêâ', text: 'Send a <strong>Gift</strong> to ride a <strong>Dragon</strong>, <strong>Phoenix</strong>, or other epic mount!' },
      { icon: 'üèçÔ∏è', text: 'Each mount has unique animation ‚Äî watch the <strong>Dragon</strong> flap its wings!' },
    ];
    let lastTipIndex = -1;
    const TIP_INTERVAL = 15000; // show a tip every 15 seconds

    function showRandomTip() {
      if (players.size === 0) return; // no tips when game is empty
      let idx;
      do { idx = Math.floor(Math.random() * GAME_TIPS.length); } while (idx === lastTipIndex && GAME_TIPS.length > 1);
      lastTipIndex = idx;
      const tip = GAME_TIPS[idx];
      showNotif(`${tip.icon} <strong>TIP:</strong> ${tip.text}`, 'tip');
    }

    setInterval(showRandomTip, TIP_INTERVAL);

    // ===== SOCKET.IO =====
    const socket = io();
    _hostSocket = socket; // enable dashboard commands

    socket.on('viewer-join', (viewer) => {
      addPlayer(viewer);
      sfxJoin();
      showNotif(`<strong>${viewer.nickname}</strong> joined the marathon!`);
    });

    socket.on('viewer-list', (list) => {
      list.forEach(v => addPlayer(v));
    });

    socket.on('gift', (data) => {
      const p = addPlayer(data);
      if (!p) return;

      const diamonds = (data.diamondCount || 1) * (data.repeatCount || 1);
      p.totalDiamonds += diamonds;
      const now = Date.now();

      sfxGift(diamonds);
      const flashColors = ['#fe2c55', '#25f4ee', '#ffd700', '#ff6600', '#a855f7'];
      triggerGiftFlash(flashColors[Math.floor(Math.random() * flashColors.length)]);

      // Gift gives a random mount!
      const newIdx = swapMount(p, Math.floor(Math.random() * MOUNT_TYPES.length));
      const mountDef = MOUNT_TYPES[newIdx];
      showNotif(`<strong>${p.nickname}</strong> rides a ${mountDef.icon} <strong>${mountDef.name}</strong>! (${data.giftName})`, 'gift');

      if (p.inventory.length > 0 && !p.isStunned) {
        // Use first power in inventory
        usePower(p, 0, now);
        showNotif(`<strong>${p.nickname}</strong> used a power! (${data.giftName} x${data.repeatCount || 1})`, 'gift');
      } else {
        // No inventory: gift gives a random gift-exclusive power (Kick or Push Out)
        const exclusiveIdx = ROAD_POWERUP_COUNT + Math.floor(Math.random() * (POWERUP_TYPES.length - ROAD_POWERUP_COUNT));
        const type = POWERUP_TYPES[exclusiveIdx];

        if (p.inventory.length < MAX_INVENTORY) {
          // Store in inventory for next gift use
          p.inventory.push(exclusiveIdx);
          updateInventorySprite(p);
          sfxPowerup();
          spawnGiftParticles(p.mesh.position.x, p.mesh.position.y, p.mesh.position.z, type.color, 20);
          showNotif(`<strong>${p.nickname}</strong> received ${type.icon} ${type.name}! (${data.giftName})`, 'gift');
        } else {
          // Inventory full ‚Äî activate immediately
          activatePower(p, type, now);
          showNotif(`<strong>${p.nickname}</strong> got ${type.icon} ${type.name}! (${data.giftName})`, 'gift');
        }
      }

      // Big gift triggers a random event
      if (diamonds >= 50) {
        triggerRandomEvent(null, p.nickname);
      }

      checkEnvironmentChange();
      updateHUD();
    });

    socket.on('like', (data) => {
      const p = addPlayer(data);
      if (!p || p.isStunned) return;

      const now = Date.now();
      const likes = Math.min(data.likeCount || 1, 10);

      // Rate-limited movement: likes add to a "bank" that drains over time
      // This prevents auto-tappers from zooming 500 tiles ahead
      const timeSinceLast = now - p.lastLikeTime;
      p.lastLikeTime = now;

      // Drain bank over time (1 tile per cooldown period naturally)
      if (timeSinceLast > p.likeCooldown) {
        const drained = Math.floor(timeSinceLast / p.likeCooldown);
        p.likeBank = Math.max(0, p.likeBank - drained);
      }

      // Diminishing returns: the more banked, the less each new like gives
      let tilesEarned;
      if (p.likeBank < 3) {
        tilesEarned = Math.min(likes, 2); // normal: up to 2 tiles
      } else if (p.likeBank < 6) {
        tilesEarned = 1; // slowing down
      } else {
        tilesEarned = 0.3; // spam penalty: tiny movement
      }

      p.likeBank = Math.min(p.likeBankMax, p.likeBank + tilesEarned);
      p.targetTile += tilesEarned;

      // Random lane switch occasionally
      if (Math.random() < 0.15) {
        p.lane = Math.floor(Math.random() * LANE_COUNT);
      }

      const pColor = hashColor(p.id);
      spawnTrail(p.mesh.position.x, p.mesh.position.y, p.mesh.position.z, pColor);
      checkEnvironmentChange();
      updateHUD();
    });

    socket.on('follow', (data) => {
      const p = addPlayer(data);
      if (!p) return;

      p.targetTile += 3;
      sfxFollow();
      spawnGiftParticles(p.mesh.position.x, p.mesh.position.y, p.mesh.position.z, 0x25f4ee, 20);
      triggerGiftFlash('#25f4ee');
      showNotif(`<strong>${p.nickname}</strong> followed! +3 boost!`, 'gift');
      updateHUD();
    });

    socket.on('room-stats', (data) => {
      // Could update viewer count separately if needed
    });

    socket.on('connection-status', () => {});

    // Host dashboard commands ‚Äî synced across all tabs
    socket.on('host-command', (cmd) => {
      executeHostCommand(cmd);
    });

    socket.on('chat', (data) => {
      const p = addPlayer(data);
      if (!p) return;

      const ud = p.mesh.userData;
      const raw = data.comment || '';
      const comment = raw.trim().toLowerCase().replace(/[^a-z0-9 ]/g, '').trim();
      const now = Date.now();

      console.log(`üí¨ Chat from ${p.nickname}: "${raw}" ‚Üí parsed: "${comment}"`);

      // Parse commands from chat (uses includes for flexibility)
      let isCommand = false;
      if (!p.isStunned) {
        if (comment.includes('jump') || comment === 'j' || comment.includes('lompat')) {
          // Jump command
          if (!p.isJumping) {
            p.isJumping = true;
            p.jumpStart = now;
            p.targetTile += 0.5;
            sfxJump();
            spawnGiftParticles(p.mesh.position.x, p.mesh.position.y, p.mesh.position.z, 0xffee44, 6);
            isCommand = true;
            console.log(`ü¶ò ${p.nickname} JUMP!`);
          }
        } else if (comment.includes('left') || comment === 'l' || comment.includes('kiri')) {
          // Move left (from viewer's perspective = increase lane index)
          if (p.lane < LANE_COUNT - 1) {
            p.lane++;
            isCommand = true;
            console.log(`‚¨ÖÔ∏è ${p.nickname} LEFT ‚Üí lane ${p.lane}`);
          }
        } else if (comment.includes('right') || comment === 'r' || comment.includes('kanan')) {
          // Move right (from viewer's perspective = decrease lane index)
          if (p.lane > 0) {
            p.lane--;
            isCommand = true;
            console.log(`‚û°Ô∏è ${p.nickname} RIGHT ‚Üí lane ${p.lane}`);
          }
        } else if (comment.includes('use') || comment.includes('power') || comment.includes('guna')) {
          // Use first power in inventory
          if (p.inventory.length > 0) {
            usePower(p, 0, now);
            isCommand = true;
            console.log(`‚ö° ${p.nickname} USED POWER!`);
          }
        }
      }

      // Show chat bubble for non-command messages (or all messages)
      const chatParent = ud.riderGroup || p.mesh;
      // Remove old chat bubble
      if (ud.chatBubble) {
        chatParent.remove(ud.chatBubble);
        ud.chatBubble = null;
      }
      if (ud.chatTimer) clearTimeout(ud.chatTimer);

      const displayComment = data.comment || '';
      if (displayComment && !isCommand) {
        const bubble = createChatBubble(displayComment);
        bubble.position.y = 1.8;
        chatParent.add(bubble);
        ud.chatBubble = bubble;

        // Auto-remove after 4 seconds
        ud.chatTimer = setTimeout(() => {
          if (ud.chatBubble) {
            chatParent.remove(ud.chatBubble);
            ud.chatBubble = null;
          }
        }, 4000);
      }
    });

    // ===== HOST CONTROLS =====
    window.toggleDemo = function() {
      demoActive = !demoActive;
      const btn = document.getElementById('btnDemo');
      if (demoActive) {
        socket.emit('start-demo');
        btn.classList.add('active');
        btn.textContent = 'Stop Demo';
      } else {
        socket.emit('stop-demo');
        btn.classList.remove('active');
        btn.textContent = 'Demo Mode';
        // Clear players
        players.forEach(p => playersGroup.remove(p.mesh));
        players.clear();
        activeObstacles.forEach(obs => {
          if (obs.poolIndex >= 0 && obstaclePool[obs.poolIndex]) {
            obstaclePool[obs.poolIndex].mesh.visible = false;
            obstaclePool[obs.poolIndex].inUse = false;
          }
        });
        activeObstacles.length = 0;
        activePowerups.forEach(pu => {
          if (pu.poolIndex >= 0) { powerupMeshPool[pu.poolIndex].mesh.visible = false; powerupMeshPool[pu.poolIndex].inUse = false; }
        });
        activePowerups.length = 0;
        lastObstacleTile = 0;
        lastPowerupTile = 10;
        lastEventTile = 0;
        activeEvent = null;
        cameraShakeAmount = 0;
        updateHUD();
      }
    };

    window.showConnectModal = function() {
      document.getElementById('connectModal').classList.add('visible');
    };
    window.hideConnectModal = function() {
      document.getElementById('connectModal').classList.remove('visible');
    };
    window.connectTikTok = function() {
      const username = document.getElementById('tiktokUsername').value.trim().replace('@', '');
      if (username) {
        socket.emit('connect-tiktok', username);
        hideConnectModal();
        // Clear existing players
        players.forEach(p => playersGroup.remove(p.mesh));
        players.clear();
        activeObstacles.forEach(obs => {
          if (obs.poolIndex >= 0 && obstaclePool[obs.poolIndex]) {
            obstaclePool[obs.poolIndex].mesh.visible = false;
            obstaclePool[obs.poolIndex].inUse = false;
          }
        });
        activeObstacles.length = 0;
        activePowerups.forEach(pu => {
          if (pu.poolIndex >= 0) { powerupMeshPool[pu.poolIndex].mesh.visible = false; powerupMeshPool[pu.poolIndex].inUse = false; }
        });
        activePowerups.length = 0;
        lastObstacleTile = 0;
        lastPowerupTile = 10;
        lastEventTile = 0;
        activeEvent = null;
        cameraShakeAmount = 0;
        demoActive = false;
        document.getElementById('btnDemo').classList.remove('active');
        document.getElementById('btnDemo').textContent = 'Demo Mode';
        updateHUD();
        showNotif(`Connecting to @${username}...`);
      }
    };

    // ===== RESIZE =====
    window.addEventListener('resize', () => {
      const sz = getGameSize();
      camera.aspect = sz.width / sz.height;
      camera.fov = getCameraFOV();
      camera.updateProjectionMatrix();
      renderer.setSize(sz.width, sz.height);
    });

    // ===== MAIN GAME LOOP =====
    let lastTime = 0;
    let hudTimer = 0;

    function gameLoop(time) {
      requestAnimationFrame(gameLoop);
      const dt = Math.min(0.1, (time - lastTime) / 1000);
      lastTime = time;
      const now = Date.now();

      // Generate obstacles and powerups ahead of leader
      const leaderTile = getLeaderTile();
      generateObstacles(leaderTile + 50);
      generatePowerups(leaderTile + 50);

      // Check if leader passed next event threshold
      if (leaderTile > lastEventTile + EVENT_INTERVAL && players.size > 0) {
        lastEventTile = Math.floor(leaderTile / EVENT_INTERVAL) * EVENT_INTERVAL;
        triggerRandomEvent();
      }

      // Clear finished events
      if (activeEvent && now - activeEvent.startTime > activeEvent.duration) {
        activeEvent = null;
      }

      // Camera shake decay (for Earthquake)
      if (cameraShakeAmount > 0) {
        cameraShakeAmount *= (1 - dt * 3);
        if (cameraShakeAmount < 0.01) cameraShakeAmount = 0;
      }

      // Update obstacle and powerup visuals
      updateObstacles(camera.position.z);
      updatePowerups(camera.position.z, now);

      // Check collisions and pickups
      checkCollisions(now);
      checkPowerupPickup(now);

      // Animate characters
      players.forEach(p => animateCharacter(p, now, dt));

      // Offset overlapping name labels so they stack vertically
      const tileGroups = new Map();
      players.forEach(p => {
        const key = Math.round(p.tilePos * 2); // bucket by half-tile
        if (!tileGroups.has(key)) tileGroups.set(key, []);
        tileGroups.get(key).push(p);
      });
      function findNameSprite(mesh) {
        let ns = null;
        mesh.traverse(c => { if (c.isSprite && c.scale.x > 2) ns = c; });
        return ns;
      }
      tileGroups.forEach(group => {
        if (group.length <= 1) {
          if (group[0]) {
            const ns = findNameSprite(group[0].mesh);
            if (ns) ns.position.y = 1.2;
          }
          return;
        }
        group.forEach((p, i) => {
          const ns = findNameSprite(p.mesh);
          if (ns) ns.position.y = 1.2 + i * 0.7;
        });
      });

      // Slow auto-walk: everyone drifts forward so game looks alive
      // Likes/gifts give bursts on top of this base speed
      players.forEach(p => {
        if (!p.isStunned) {
          p.targetTile += dt * 0.4; // ~0.4 tiles/sec base drift
        }
      });

      // Auto-nudge stragglers: keep everyone visible within camera range
      // But give new joiners room ‚Äî only nudge after they've been idle too long
      if (players.size > 1) {
        const leaderPos = getLeaderTile();
        const softLimit = leaderPos - 25; // start gentle nudging at 25 tiles behind
        const hardLimit = leaderPos - 40; // teleport at 40 tiles behind (off-screen)
        players.forEach(p => {
          if (p.isStunned) return;
          if (p.tilePos < hardLimit) {
            // Way too far behind ‚Äî teleport to back of visible area
            p.tilePos = softLimit + 2;
            p.targetTile = softLimit + 2;
          } else if (p.tilePos < softLimit) {
            // Falling behind ‚Äî gentle pull forward
            const gap = softLimit - p.tilePos;
            p.targetTile += gap * 0.1;
            p.tilePos += gap * 0.05;
          }
        });
      }

      // Camera
      updateCamera(dt);

      // Recycle chunks and scenery
      recycleRoads();
      recycleScenery();
      updateTerrain();

      // Update particles and trails
      updateParticles(dt);
      updateTrails(dt);

      // Animate clouds
      cloudGroup.children.forEach((c, i) => {
        c.position.x += dt * (0.5 + i * 0.1);
        if (c.position.x > 100) c.position.x = -100;
      });

      // Animate fire obstacles
      for (const obs of activeObstacles) {
        if (obs.poolIndex >= 0 && obstaclePool[obs.poolIndex]) {
          const pm = obstaclePool[obs.poolIndex];
          if (OBSTACLE_TYPES[obs.typeIndex].name === 'fire') {
            pm.mesh.rotation.y = time * 0.003;
            pm.mesh.children.forEach(c => {
              c.scale.y = 1 + Math.sin(time * 0.01 + obs.tile) * 0.2;
            });
          }
          if (OBSTACLE_TYPES[obs.typeIndex].name === 'bomb') {
            pm.mesh.scale.setScalar(1 + Math.sin(time * 0.008) * 0.05);
          }
        }
      }

      // Update HUD periodically + cleanup inactive players
      hudTimer += dt;
      if (hudTimer > 0.5) {
        hudTimer = 0;
        updateHUD();
        cleanupInactivePlayers(now);
      }

      renderer.render(scene, camera);
    }

    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>
