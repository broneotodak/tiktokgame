<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>TikTok Live Marathon 3D</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { background: #000; overflow: hidden; width: 100vw; height: 100vh; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; }
    #game-canvas { display: block; width: 100vw; height: 100vh; }

    /* HUD Overlay */
    .hud { position: absolute; top: 0; left: 0; right: 0; padding: 12px 20px; display: flex; justify-content: space-between; align-items: flex-start; z-index: 100; pointer-events: none; }
    .hud-left, .hud-right { pointer-events: auto; }
    .hud-badge { padding: 6px 14px; background: rgba(0,0,0,0.7); backdrop-filter: blur(10px); border-radius: 20px; color: #fff; font-size: 14px; font-weight: 600; display: flex; align-items: center; gap: 6px; margin-bottom: 6px; }
    .live-dot { width: 8px; height: 8px; background: #fe2c55; border-radius: 50%; animation: pulse 1.5s infinite; }
    @keyframes pulse { 0%,100% { opacity: 1; } 50% { opacity: 0.4; } }

    /* Environment badge */
    .env-badge { position: absolute; top: 12px; left: 50%; transform: translateX(-50%); z-index: 100; padding: 6px 18px; background: rgba(37,244,238,0.15); border: 1px solid rgba(37,244,238,0.4); backdrop-filter: blur(10px); border-radius: 20px; color: #25f4ee; font-size: 13px; font-weight: 700; letter-spacing: 1px; text-transform: uppercase; pointer-events: none; }

    /* Podium */
    .podium { min-width: 170px; }
    .podium-title { font-size: 11px; font-weight: 700; color: #ffd700; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 6px; text-align: center; padding: 4px 12px; background: rgba(0,0,0,0.7); backdrop-filter: blur(10px); border-radius: 12px; }
    .podium-row { display: flex; align-items: center; gap: 8px; padding: 4px 12px; font-size: 12px; color: #fff; background: rgba(0,0,0,0.5); border-radius: 10px; margin-bottom: 3px; }
    .podium-medal { font-size: 16px; }
    .podium-name { flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    .podium-dist { font-weight: 700; color: #25f4ee; font-variant-numeric: tabular-nums; }

    /* Notification feed */
    .notif-area { position: absolute; top: 60px; left: 15px; display: flex; flex-direction: column; gap: 4px; z-index: 100; pointer-events: none; max-width: 320px; }
    .notif { padding: 6px 14px; background: rgba(0,0,0,0.6); backdrop-filter: blur(8px); border-radius: 20px; color: #fff; font-size: 12px; animation: slideIn 0.3s ease-out, fadeOut 0.4s ease-in 3s forwards; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .notif strong { color: #25f4ee; }
    .notif.gift strong { color: #fe2c55; }
    @keyframes slideIn { from { opacity: 0; transform: translateX(-30px); } to { opacity: 1; transform: translateX(0); } }
    @keyframes fadeOut { to { opacity: 0; transform: translateX(-20px); } }

    /* Game guide bar - auto-hides after 8s, tap to toggle */
    .game-guide { position: absolute; bottom: 0; left: 0; right: 0; z-index: 100; pointer-events: auto; transition: transform 0.4s ease, opacity 0.4s ease; }
    .game-guide.hidden { transform: translateY(100%); opacity: 0; pointer-events: none; }
    .guide-bar { display: flex; gap: 0; background: rgba(0,0,0,0.85); backdrop-filter: blur(12px); border-top: 1px solid rgba(255,255,255,0.1); padding: 6px 8px; justify-content: center; flex-wrap: wrap; }
    .guide-section { display: flex; align-items: center; gap: 4px; padding: 3px 10px; border-right: 1px solid rgba(255,255,255,0.08); white-space: nowrap; }
    .guide-section:last-child { border-right: none; }
    .guide-section .g-emoji { font-size: 16px; }
    .guide-section .g-label { font-size: 11px; color: #fff; font-weight: 600; }
    .guide-section .g-sub { font-size: 9px; color: #888; display: none; }
    @media (min-width: 640px) { .guide-section .g-sub { display: inline; } .guide-section .g-emoji { font-size: 20px; } .guide-section .g-label { font-size: 12px; } }
    .guide-section.guide-highlight { background: linear-gradient(135deg, rgba(254,44,85,0.25), rgba(37,244,238,0.15)); border-radius: 12px; border-right: none; margin: 0 2px; }
    .guide-show-btn { position: absolute; bottom: 8px; right: 8px; z-index: 101; width: 32px; height: 32px; border-radius: 50%; background: rgba(0,0,0,0.6); border: 1px solid #444; color: #fff; font-size: 14px; cursor: pointer; display: none; align-items: center; justify-content: center; pointer-events: auto; }
    .guide-show-btn.visible { display: flex; }

    /* Host controls - hidden for viewers via ?view param */
    .host-controls { position: absolute; bottom: 45px; left: 50%; transform: translateX(-50%); z-index: 100; display: flex; gap: 6px; flex-wrap: wrap; justify-content: center; }
    body.viewer-mode .host-controls { display: none; }
    body.viewer-mode .game-guide.hidden + .guide-show-btn { bottom: 8px; }

    /* Power-up notification */
    .powerup-notif { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 100; pointer-events: none; font-size: 28px; font-weight: 900; color: #fff; text-shadow: 0 0 20px rgba(255,200,0,0.8), 0 2px 4px rgba(0,0,0,0.5); opacity: 0; transition: opacity 0.2s; }
    .powerup-notif.show { opacity: 1; animation: powerPop 1.2s ease-out forwards; }
    @keyframes powerPop { 0% { transform: translate(-50%,-50%) scale(0.5); opacity: 0; } 15% { transform: translate(-50%,-50%) scale(1.2); opacity: 1; } 30% { transform: translate(-50%,-50%) scale(1); } 100% { transform: translate(-50%,-70%) scale(1); opacity: 0; } }

    /* Gift burst overlay flash */
    .gift-flash { position: fixed; inset: 0; pointer-events: none; z-index: 50; opacity: 0; transition: opacity 0.1s; }
    .gift-flash.active { opacity: 1; animation: flashOut 0.6s ease-out forwards; }
    @keyframes flashOut { from { opacity: 0.3; } to { opacity: 0; } }
    .host-btn { padding: 8px 18px; background: rgba(0,0,0,0.8); backdrop-filter: blur(10px); border: 1px solid #444; border-radius: 20px; color: #fff; font-size: 12px; font-weight: 600; cursor: pointer; transition: all 0.2s; }
    .host-btn:hover { background: rgba(37,244,238,0.2); border-color: #25f4ee; }
    .host-btn.active { background: rgba(254,44,85,0.3); border-color: #fe2c55; }

    /* TikTok connect modal */
    .modal-overlay { display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.7); z-index: 500; align-items: center; justify-content: center; }
    .modal-overlay.visible { display: flex; }
    .modal { background: #1a1a2e; border: 1px solid #333; border-radius: 16px; padding: 24px; min-width: 320px; }
    .modal h3 { color: #fff; margin-bottom: 12px; }
    .modal input { width: 100%; padding: 10px 14px; background: #0a0a1a; border: 1px solid #444; border-radius: 10px; color: #fff; font-size: 14px; margin-bottom: 12px; outline: none; }
    .modal input:focus { border-color: #25f4ee; }
    .modal-btns { display: flex; gap: 8px; justify-content: flex-end; }
    .modal-btn { padding: 8px 20px; border-radius: 10px; border: none; font-weight: 600; cursor: pointer; font-size: 13px; }
    .modal-btn.primary { background: #25f4ee; color: #000; }
    .modal-btn.secondary { background: #333; color: #fff; }
  </style>
</head>
<body>
  <canvas id="game-canvas"></canvas>
  <div class="gift-flash" id="giftFlash"></div>

  <!-- HUD -->
  <div class="hud">
    <div class="hud-left">
      <div class="hud-badge"><div class="live-dot"></div> <span id="runnerCount">0</span> runners</div>
      <div class="hud-badge">Leader: <span id="leaderDist">0</span>m</div>
    </div>
    <div class="hud-right podium">
      <div class="podium-title">Top 3</div>
      <div id="podiumList"></div>
    </div>
  </div>

  <div class="env-badge" id="envBadge">Grasslands</div>

  <div class="notif-area" id="notifArea"></div>

  <!-- Host controls -->
  <div class="host-controls">
    <button class="host-btn" id="btnDemo" onclick="toggleDemo()">Demo Mode</button>
    <button class="host-btn" onclick="nextEnvironment()">Change Env</button>
    <button class="host-btn" onclick="showConnectModal()">Connect TikTok</button>
  </div>

  <!-- Guide bar (auto-hides after 8s) -->
  <div class="game-guide" id="gameGuide">
    <div class="guide-bar">
      <div class="guide-section guide-highlight"><span class="g-emoji">‚ù§Ô∏è</span><span class="g-label">Like = Run</span><span class="g-sub">1 tile</span></div>
      <div class="guide-section"><span class="g-emoji">üí¨</span><span class="g-label">Chat: jump/left/right</span><span class="g-sub">dodge & move</span></div>
      <div class="guide-section"><span class="g-emoji">üéÅ</span><span class="g-label">Gift = Power</span><span class="g-sub">use or get</span></div>
      <div class="guide-section"><span class="g-emoji">‚≠ê</span><span class="g-label">Follow = +3</span><span class="g-sub">boost</span></div>
    </div>
  </div>
  <button class="guide-show-btn" id="guideShowBtn" onclick="toggleGuide()">?</button>
  <div class="powerup-notif" id="powerupNotif"></div>

  <!-- Connect Modal -->
  <div class="modal-overlay" id="connectModal">
    <div class="modal">
      <h3>Connect TikTok Live</h3>
      <input type="text" id="tiktokUsername" placeholder="@username" />
      <div class="modal-btns">
        <button class="modal-btn secondary" onclick="hideConnectModal()">Cancel</button>
        <button class="modal-btn primary" onclick="connectTikTok()">Connect</button>
      </div>
    </div>
  </div>

  <script src="/socket.io/socket.io.js"></script>
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/"
    }
  }
  </script>
  <script type="module">
    import * as THREE from 'three';

    // ===== CONSTANTS =====
    const TILE = 2; // world units per tile
    const LANE_COUNT = 5;
    const LANE_WIDTH = 2;
    const ROAD_WIDTH = LANE_COUNT * LANE_WIDTH;
    const CHUNK_LENGTH = 40;
    const CHUNK_COUNT = 8;
    const FOG_NEAR = 80;
    const FOG_FAR = 200;
    const JUMP_DURATION = 600;
    const STUN_DURATION = 1500;
    const ENV_INTERVAL = 100; // tiles per environment change
    const OBSTACLE_CHANCE = 0.25;
    const MAX_VISIBLE_OBSTACLES = 40;
    const MAX_SCENERY = 60;

    // ===== COLOR PALETTE =====
    const PLAYER_COLORS = [
      0xff4444, 0x44aaff, 0x44ff44, 0xff44ff, 0xffaa00,
      0x00ffcc, 0xff6600, 0xaa44ff, 0xffff00, 0xff2266,
      0x00aaff, 0x66ff66, 0xff8888, 0x8888ff, 0xaaffaa
    ];

    // ===== ENVIRONMENT THEMES =====
    const ENVIRONMENTS = [
      { name: 'Grasslands', sky: 0x87ceeb, fog: 0xa8d4f0, ground: 0x3a8a35, groundAlt: 0x2d7a2a, road: 0x555555, roadAlt: 0x4a4a4a, rumble: 0xee2222, rumbleAlt: 0xffffff, mountain: 0x4a6a9a, sun: 0xffee88, sceneryColors: [0x2d6b2d, 0x1a5c1a, 0x888888] },
      { name: 'Desert', sky: 0xf0d8a0, fog: 0xe8c890, ground: 0xd4b060, groundAlt: 0xc0a050, road: 0xb8a070, roadAlt: 0xa89060, rumble: 0xe8a020, rumbleAlt: 0xffffff, mountain: 0xc4956a, sun: 0xffdd44, sceneryColors: [0xc4a050, 0x8b7340, 0xaa8855] },
      { name: 'Snow', sky: 0xc8dae8, fog: 0xd8e8f0, ground: 0xe0e8f0, groundAlt: 0xd0d8e8, road: 0x8a8a9a, roadAlt: 0x7a7a8a, rumble: 0x44aaff, rumbleAlt: 0xffffff, mountain: 0x8aa8c8, sun: 0xeeeeff, sceneryColors: [0x2d6b2d, 0xd0e0f0, 0xaabbcc] },
      { name: 'Volcano', sky: 0x3a1a0a, fog: 0x5a2a0a, ground: 0x3a2a1a, groundAlt: 0x2a1a0a, road: 0x4a3a2a, roadAlt: 0x3a2a1a, rumble: 0xff4400, rumbleAlt: 0xffaa00, mountain: 0x5a2a1a, sun: 0xff6633, sceneryColors: [0x2a1a0a, 0x444444, 0x666666] },
      { name: 'Ocean', sky: 0x70c0e8, fog: 0x88d0f0, ground: 0x2a7aaa, groundAlt: 0x1a6a9a, road: 0x5a8aaa, roadAlt: 0x4a7a9a, rumble: 0x00aaff, rumbleAlt: 0xffffff, mountain: 0x2a5a9a, sun: 0xffee88, sceneryColors: [0x2a6a9a, 0x3388aa, 0x558899] },
      { name: 'Space', sky: 0x000015, fog: 0x0a0a2a, ground: 0x2a1a3a, groundAlt: 0x1a0a2a, road: 0x3a2a4a, roadAlt: 0x2a1a3a, rumble: 0xaa00ff, rumbleAlt: 0x5500ff, mountain: 0x1a1a3a, sun: 0xccccff, sceneryColors: [0x3a2a5a, 0x2a1a4a, 0x5544aa] },
      { name: 'Candy', sky: 0xffc0e0, fog: 0xffd0e8, ground: 0xffb0d0, groundAlt: 0xffa0c0, road: 0xe890b8, roadAlt: 0xd880a8, rumble: 0xff00ff, rumbleAlt: 0xffff00, mountain: 0xe080b0, sun: 0xffaacc, sceneryColors: [0xff88aa, 0xffaa88, 0xdd66aa] },
      { name: 'Jungle', sky: 0x6aaa40, fog: 0x4a8a30, ground: 0x1a6a15, groundAlt: 0x0a5a0a, road: 0x5a4a2a, roadAlt: 0x4a3a1a, rumble: 0x00aa00, rumbleAlt: 0x88ff44, mountain: 0x2a5a2a, sun: 0xddff88, sceneryColors: [0x1a5a1a, 0x2a7a2a, 0x4a3a1a] },
    ];

    // ===== OBSTACLE TYPES =====
    const OBSTACLE_TYPES = [
      { name: 'rock', color: 0x888888, height: 0.8, width: 0.7 },
      { name: 'tree', color: 0x2d6b2d, height: 1.5, width: 0.5 },
      { name: 'water', color: 0x4488ff, height: 0.3, width: 1.5 },
      { name: 'wall', color: 0xaa6633, height: 1.2, width: 1.8 },
      { name: 'fire', color: 0xff4400, height: 1.0, width: 0.6 },
      { name: 'bomb', color: 0x333333, height: 0.5, width: 0.5 },
    ];

    // ===== VIEWER MODE =====
    // ?view=1 hides host controls so viewers see a clean game
    const isViewerMode = new URLSearchParams(window.location.search).has('view');
    if (isViewerMode) document.body.classList.add('viewer-mode');

    // ===== STATE =====
    const players = new Map();
    let envIndex = 0;
    let lastObstacleTile = 0;
    let demoActive = false;
    const obstacles = []; // { tile, lane, type, mesh }
    const obstaclePool = [];
    const sceneryPool = [];
    const roadChunks = [];
    let cameraTargetZ = 0;

    // ===== PARTICLE SYSTEM =====
    const MAX_PARTICLES = 200;
    const particlePositions = new Float32Array(MAX_PARTICLES * 3);
    const particleColors = new Float32Array(MAX_PARTICLES * 3);
    const particleSizes = new Float32Array(MAX_PARTICLES);
    const particleVelocities = []; // { vx, vy, vz, life, maxLife }
    for (let i = 0; i < MAX_PARTICLES; i++) {
      particlePositions[i * 3] = 0;
      particlePositions[i * 3 + 1] = -100; // hidden below
      particlePositions[i * 3 + 2] = 0;
      particleColors[i * 3] = 1;
      particleColors[i * 3 + 1] = 1;
      particleColors[i * 3 + 2] = 1;
      particleSizes[i] = 0;
      particleVelocities.push({ vx: 0, vy: 0, vz: 0, life: 0, maxLife: 0 });
    }
    let nextParticle = 0;

    // ===== TRAIL SYSTEM =====
    const MAX_TRAILS = 600;
    const trailPositions = new Float32Array(MAX_TRAILS * 3);
    const trailColors = new Float32Array(MAX_TRAILS * 3);
    const trailSizes = new Float32Array(MAX_TRAILS);
    const trailMeta = []; // { life, maxLife }
    for (let i = 0; i < MAX_TRAILS; i++) {
      trailPositions[i * 3] = 0;
      trailPositions[i * 3 + 1] = -100;
      trailPositions[i * 3 + 2] = 0;
      trailColors[i * 3] = 1;
      trailColors[i * 3 + 1] = 1;
      trailColors[i * 3 + 2] = 1;
      trailSizes[i] = 0;
      trailMeta.push({ life: 0, maxLife: 0 });
    }
    let nextTrail = 0;

    // ===== SOUND ENGINE (Web Audio API, no files) =====
    let audioCtx = null;
    function getAudio() {
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      return audioCtx;
    }
    // Unlock audio on first interaction
    document.addEventListener('click', () => { getAudio(); }, { once: true });

    function playTone(freq, duration, type = 'sine', vol = 0.15) {
      try {
        const ctx = getAudio();
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, ctx.currentTime);
        gain.gain.setValueAtTime(vol, ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + duration);
        osc.connect(gain);
        gain.connect(ctx.destination);
        osc.start();
        osc.stop(ctx.currentTime + duration);
      } catch(e) {}
    }

    function sfxGift(diamonds) {
      // Rising arpeggio, higher notes for bigger gifts
      const base = 400 + Math.min(diamonds, 100) * 3;
      playTone(base, 0.12, 'sine', 0.12);
      setTimeout(() => playTone(base * 1.25, 0.12, 'sine', 0.10), 60);
      setTimeout(() => playTone(base * 1.5, 0.15, 'sine', 0.10), 120);
      if (diamonds > 20) setTimeout(() => playTone(base * 2, 0.2, 'triangle', 0.08), 180);
    }

    function sfxJump() {
      playTone(300, 0.08, 'sine', 0.10);
      setTimeout(() => playTone(500, 0.1, 'sine', 0.08), 50);
    }

    function sfxHit() {
      playTone(150, 0.15, 'sawtooth', 0.12);
      setTimeout(() => playTone(100, 0.2, 'sawtooth', 0.10), 80);
    }

    function sfxFollow() {
      playTone(500, 0.1, 'sine', 0.10);
      setTimeout(() => playTone(600, 0.1, 'sine', 0.10), 80);
      setTimeout(() => playTone(800, 0.15, 'triangle', 0.08), 160);
    }

    function sfxPowerup() {
      playTone(600, 0.08, 'sine', 0.12);
      setTimeout(() => playTone(800, 0.08, 'sine', 0.10), 70);
      setTimeout(() => playTone(1000, 0.08, 'sine', 0.10), 140);
      setTimeout(() => playTone(1200, 0.15, 'triangle', 0.08), 210);
    }

    function sfxJoin() {
      playTone(440, 0.1, 'sine', 0.06);
      setTimeout(() => playTone(550, 0.12, 'sine', 0.05), 100);
    }

    // ===== POWER-UP SYSTEM =====
    // Road pickup powers (first 4, collectible on track)
    // Gift-exclusive powers (last 2, only from gifts)
    const POWERUP_TYPES = [
      { name: 'Speed Boost', icon: '‚ö°', color: 0xffaa00, effect: 'speed' },
      { name: 'Shield', icon: 'üõ°', color: 0x44aaff, effect: 'shield' },
      { name: 'Lightning', icon: 'üîÆ', color: 0xaa44ff, effect: 'lightning' },
      { name: 'Magnet', icon: 'üß≤', color: 0xff44aa, effect: 'magnet' },
      // Gift-exclusive (cannot be picked up on road)
      { name: 'Mega Kick', icon: 'ü¶µ', color: 0xff2222, effect: 'kick' },
      { name: 'Push Out', icon: 'üí®', color: 0xff8800, effect: 'pushout' },
    ];
    const ROAD_POWERUP_COUNT = 4; // only first 4 spawn on road
    const MAX_INVENTORY = 3;
    const MAX_POWERUPS = 15;
    const activePowerups = []; // { tile, lane, typeIndex, mesh }
    const powerupMeshPool = [];
    let lastPowerupTile = 10;

    // ===== GUIDE AUTO-HIDE =====
    let guideVisible = true;
    setTimeout(() => {
      document.getElementById('gameGuide').classList.add('hidden');
      document.getElementById('guideShowBtn').classList.add('visible');
      guideVisible = false;
    }, 8000);

    window.toggleGuide = function() {
      guideVisible = !guideVisible;
      document.getElementById('gameGuide').classList.toggle('hidden', !guideVisible);
      document.getElementById('guideShowBtn').classList.toggle('visible', !guideVisible);
      if (guideVisible) {
        setTimeout(() => {
          document.getElementById('gameGuide').classList.add('hidden');
          document.getElementById('guideShowBtn').classList.add('visible');
          guideVisible = false;
        }, 6000);
      }
    };

    // ===== THREE.JS SETUP =====
    const canvas = document.getElementById('game-canvas');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: false });
    renderer.setPixelRatio(1);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.sortObjects = true;

    const scene = new THREE.Scene();
    const env = ENVIRONMENTS[envIndex];
    scene.background = new THREE.Color(env.sky);
    scene.fog = new THREE.Fog(env.fog, FOG_NEAR, FOG_FAR);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.5, 300);
    camera.position.set(0, 8, -12);
    camera.lookAt(0, 0, 20);

    // ===== LIGHTS =====
    const ambientLight = new THREE.AmbientLight(0x666666);
    scene.add(ambientLight);
    const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
    dirLight.position.set(5, 15, 10);
    scene.add(dirLight);
    const hemiLight = new THREE.HemisphereLight(0x88aaff, 0x445522, 0.5);
    scene.add(hemiLight);

    // ===== PARTICLE POINTS =====
    const particleGeo = new THREE.BufferGeometry();
    particleGeo.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
    particleGeo.setAttribute('color', new THREE.BufferAttribute(particleColors, 3));
    particleGeo.setAttribute('size', new THREE.BufferAttribute(particleSizes, 1));
    const particleMat = new THREE.PointsMaterial({
      size: 0.3, vertexColors: true, transparent: true, opacity: 0.9,
      depthWrite: false, blending: THREE.AdditiveBlending, sizeAttenuation: true
    });
    const particlePoints = new THREE.Points(particleGeo, particleMat);
    scene.add(particlePoints);

    // ===== TRAIL POINTS =====
    const trailGeo = new THREE.BufferGeometry();
    trailGeo.setAttribute('position', new THREE.BufferAttribute(trailPositions, 3));
    trailGeo.setAttribute('color', new THREE.BufferAttribute(trailColors, 3));
    trailGeo.setAttribute('size', new THREE.BufferAttribute(trailSizes, 1));
    const trailMat = new THREE.PointsMaterial({
      size: 0.15, vertexColors: true, transparent: true, opacity: 0.6,
      depthWrite: false, blending: THREE.AdditiveBlending, sizeAttenuation: true
    });
    const trailPoints = new THREE.Points(trailGeo, trailMat);
    scene.add(trailPoints);

    // ===== PARTICLE HELPERS =====
    function spawnGiftParticles(x, y, z, color, count) {
      const r = ((color >> 16) & 0xff) / 255;
      const g = ((color >> 8) & 0xff) / 255;
      const b = (color & 0xff) / 255;
      for (let i = 0; i < count; i++) {
        const idx = nextParticle % MAX_PARTICLES;
        nextParticle++;
        const angle = Math.random() * Math.PI * 2;
        const speed = 1.5 + Math.random() * 4;
        const upSpeed = 3 + Math.random() * 5;
        particlePositions[idx * 3] = x + (Math.random() - 0.5) * 0.5;
        particlePositions[idx * 3 + 1] = y + 1.5;
        particlePositions[idx * 3 + 2] = z + (Math.random() - 0.5) * 0.5;
        // Mix gift color with white/gold for sparkle
        const mix = Math.random() * 0.4;
        particleColors[idx * 3] = r * (1 - mix) + mix;
        particleColors[idx * 3 + 1] = g * (1 - mix) + mix * 0.85;
        particleColors[idx * 3 + 2] = b * (1 - mix) + mix * 0.2;
        particleSizes[idx] = 0.2 + Math.random() * 0.4;
        particleVelocities[idx] = {
          vx: Math.cos(angle) * speed * 0.5,
          vy: upSpeed,
          vz: Math.sin(angle) * speed * 0.5,
          life: 1.0,
          maxLife: 0.8 + Math.random() * 0.7
        };
      }
    }

    function spawnStunParticles(x, y, z) {
      for (let i = 0; i < 15; i++) {
        const idx = nextParticle % MAX_PARTICLES;
        nextParticle++;
        const angle = Math.random() * Math.PI * 2;
        particlePositions[idx * 3] = x;
        particlePositions[idx * 3 + 1] = y + 1;
        particlePositions[idx * 3 + 2] = z;
        particleColors[idx * 3] = 1;
        particleColors[idx * 3 + 1] = 0.3;
        particleColors[idx * 3 + 2] = 0.2;
        particleSizes[idx] = 0.3;
        particleVelocities[idx] = {
          vx: Math.cos(angle) * 3, vy: 2 + Math.random() * 3, vz: Math.sin(angle) * 3,
          life: 1.0, maxLife: 0.6 + Math.random() * 0.4
        };
      }
    }

    function spawnTrail(x, y, z, color) {
      const idx = nextTrail % MAX_TRAILS;
      nextTrail++;
      const r = ((color >> 16) & 0xff) / 255;
      const g = ((color >> 8) & 0xff) / 255;
      const b = (color & 0xff) / 255;
      trailPositions[idx * 3] = x + (Math.random() - 0.5) * 0.3;
      trailPositions[idx * 3 + 1] = y + 0.15;
      trailPositions[idx * 3 + 2] = z + (Math.random() - 0.5) * 0.2;
      trailColors[idx * 3] = r;
      trailColors[idx * 3 + 1] = g;
      trailColors[idx * 3 + 2] = b;
      trailSizes[idx] = 0.1 + Math.random() * 0.15;
      trailMeta[idx] = { life: 1.0, maxLife: 0.5 + Math.random() * 0.5 };
    }

    function updateParticles(dt) {
      for (let i = 0; i < MAX_PARTICLES; i++) {
        const v = particleVelocities[i];
        if (v.life <= 0) continue;
        v.life -= dt / v.maxLife;
        if (v.life <= 0) {
          particlePositions[i * 3 + 1] = -100;
          particleSizes[i] = 0;
          continue;
        }
        particlePositions[i * 3] += v.vx * dt;
        particlePositions[i * 3 + 1] += v.vy * dt;
        particlePositions[i * 3 + 2] += v.vz * dt;
        v.vy -= 9.8 * dt; // gravity
        particleSizes[i] *= (1 - dt * 1.5); // shrink
      }
      particleGeo.attributes.position.needsUpdate = true;
      particleGeo.attributes.color.needsUpdate = true;
      particleGeo.attributes.size.needsUpdate = true;
    }

    function updateTrails(dt) {
      for (let i = 0; i < MAX_TRAILS; i++) {
        const m = trailMeta[i];
        if (m.life <= 0) continue;
        m.life -= dt / m.maxLife;
        if (m.life <= 0) {
          trailPositions[i * 3 + 1] = -100;
          trailSizes[i] = 0;
          continue;
        }
        trailSizes[i] *= (1 - dt * 2);
        trailPositions[i * 3 + 1] += dt * 0.3; // slight float up
      }
      trailGeo.attributes.position.needsUpdate = true;
      trailGeo.attributes.color.needsUpdate = true;
      trailGeo.attributes.size.needsUpdate = true;
    }

    function triggerGiftFlash(color) {
      const flash = document.getElementById('giftFlash');
      flash.style.background = `radial-gradient(ellipse at center, ${color}44 0%, transparent 70%)`;
      flash.classList.remove('active');
      void flash.offsetWidth; // force reflow
      flash.classList.add('active');
    }

    // ===== SUN =====
    const sunGeo = new THREE.SphereGeometry(8, 12, 8);
    const sunMat = new THREE.MeshBasicMaterial({ color: env.sun });
    const sunMesh = new THREE.Mesh(sunGeo, sunMat);
    sunMesh.position.set(40, 60, 200);
    scene.add(sunMesh);

    // ===== CLOUDS =====
    const cloudGroup = new THREE.Group();
    const cloudMat = new THREE.MeshLambertMaterial({ color: 0xffffff, transparent: true, opacity: 0.7, flatShading: true });
    for (let i = 0; i < 12; i++) {
      const cg = new THREE.Group();
      for (let j = 0; j < 3; j++) {
        const s = 3 + Math.random() * 5;
        const cGeo = new THREE.SphereGeometry(s, 6, 4);
        const cloud = new THREE.Mesh(cGeo, cloudMat);
        cloud.position.set((j - 1) * s * 0.8, Math.random() * 1, 0);
        cloud.scale.y = 0.4;
        cg.add(cloud);
      }
      cg.position.set(-80 + Math.random() * 160, 30 + Math.random() * 20, 50 + Math.random() * 150);
      cloudGroup.add(cg);
    }
    scene.add(cloudGroup);

    // ===== TERRAIN (sides of road) =====
    const terrainGroup = new THREE.Group();
    const terrainMat = new THREE.MeshLambertMaterial({ color: env.ground, flatShading: true });
    const terrainMatAlt = new THREE.MeshLambertMaterial({ color: env.groundAlt, flatShading: true });

    // Left terrain
    const tGeo = new THREE.PlaneGeometry(60, CHUNK_LENGTH * CHUNK_COUNT, 20, 40);
    // Add vertex displacement for hills
    const tPos = tGeo.attributes.position;
    for (let i = 0; i < tPos.count; i++) {
      const x = tPos.getX(i);
      const z = tPos.getZ(i);
      const dist = Math.max(0, (Math.abs(x) - 5) * 0.1);
      tPos.setY(i, Math.sin(z * 0.05) * 3 * dist + Math.sin(x * 0.1 + z * 0.08) * 2 * dist - 0.1);
    }
    tGeo.computeVertexNormals();

    const leftTerrain = new THREE.Mesh(tGeo, terrainMat);
    leftTerrain.rotation.x = -Math.PI / 2;
    leftTerrain.position.set(-ROAD_WIDTH / 2 - 30, 0, CHUNK_LENGTH * CHUNK_COUNT / 2);
    terrainGroup.add(leftTerrain);

    const rightTerrain = new THREE.Mesh(tGeo.clone(), terrainMatAlt);
    rightTerrain.rotation.x = -Math.PI / 2;
    rightTerrain.position.set(ROAD_WIDTH / 2 + 30, 0, CHUNK_LENGTH * CHUNK_COUNT / 2);
    terrainGroup.add(rightTerrain);
    scene.add(terrainGroup);

    // ===== MOUNTAINS =====
    const mountainGroup = new THREE.Group();
    const mtMat = new THREE.MeshLambertMaterial({ color: env.mountain, flatShading: true });
    for (let i = 0; i < 20; i++) {
      const w = 10 + Math.random() * 20;
      const h = 15 + Math.random() * 25;
      const shape = new THREE.Shape();
      shape.moveTo(-w / 2, 0);
      shape.lineTo(0, h);
      shape.lineTo(w / 2, 0);
      shape.closePath();
      const extGeo = new THREE.ExtrudeGeometry(shape, { depth: 5 + Math.random() * 10, bevelEnabled: false });
      const mt = new THREE.Mesh(extGeo, mtMat);
      const side = i % 2 === 0 ? -1 : 1;
      mt.position.set(side * (40 + Math.random() * 40), 0, i * 20 + Math.random() * 10);
      mt.rotation.y = side * 0.3;
      mountainGroup.add(mt);
    }
    scene.add(mountainGroup);

    // ===== ROAD CHUNKS =====
    const roadGroup = new THREE.Group();
    const roadMat = new THREE.MeshLambertMaterial({ color: env.road, flatShading: true });
    const roadMatAlt = new THREE.MeshLambertMaterial({ color: env.roadAlt, flatShading: true });
    const rumbleMat = new THREE.MeshLambertMaterial({ color: env.rumble });
    const rumbleMatAlt = new THREE.MeshLambertMaterial({ color: env.rumbleAlt });
    const laneMat = new THREE.MeshBasicMaterial({ color: 0xffffff });

    function createRoadChunk(index) {
      const group = new THREE.Group();
      const isEven = index % 2 === 0;

      // Road surface
      const roadGeo = new THREE.PlaneGeometry(ROAD_WIDTH, CHUNK_LENGTH);
      const road = new THREE.Mesh(roadGeo, isEven ? roadMat : roadMatAlt);
      road.rotation.x = -Math.PI / 2;
      road.position.y = 0.01;
      group.add(road);

      // Rumble strips
      const rumbleGeo = new THREE.PlaneGeometry(0.5, CHUNK_LENGTH);
      const leftRumble = new THREE.Mesh(rumbleGeo, isEven ? rumbleMat : rumbleMatAlt);
      leftRumble.rotation.x = -Math.PI / 2;
      leftRumble.position.set(-ROAD_WIDTH / 2 - 0.25, 0.02, 0);
      group.add(leftRumble);

      const rightRumble = new THREE.Mesh(rumbleGeo.clone(), isEven ? rumbleMat : rumbleMatAlt);
      rightRumble.rotation.x = -Math.PI / 2;
      rightRumble.position.set(ROAD_WIDTH / 2 + 0.25, 0.02, 0);
      group.add(rightRumble);

      // Lane dividers (dashed)
      for (let l = 1; l < LANE_COUNT; l++) {
        const lx = -ROAD_WIDTH / 2 + l * LANE_WIDTH;
        for (let d = -CHUNK_LENGTH / 2; d < CHUNK_LENGTH / 2; d += 4) {
          const dashGeo = new THREE.PlaneGeometry(0.1, 1.5);
          const dash = new THREE.Mesh(dashGeo, laneMat);
          dash.rotation.x = -Math.PI / 2;
          dash.position.set(lx, 0.03, d);
          group.add(dash);
        }
      }

      group.position.z = index * CHUNK_LENGTH + CHUNK_LENGTH / 2;
      group.userData = { chunkIndex: index };
      roadGroup.add(group);
      return group;
    }

    for (let i = 0; i < CHUNK_COUNT; i++) {
      roadChunks.push(createRoadChunk(i));
    }
    scene.add(roadGroup);

    // ===== SCENERY POOL =====
    const sceneryGroup = new THREE.Group();
    function createTree(color) {
      const g = new THREE.Group();
      // Trunk
      const trunkGeo = new THREE.CylinderGeometry(0.15, 0.2, 1.5, 5);
      const trunkMat = new THREE.MeshLambertMaterial({ color: 0x8B4513, flatShading: true });
      const trunk = new THREE.Mesh(trunkGeo, trunkMat);
      trunk.position.y = 0.75;
      g.add(trunk);
      // Foliage
      const foliageGeo = new THREE.ConeGeometry(1.2, 2.5, 6);
      const foliageMat = new THREE.MeshLambertMaterial({ color, flatShading: true });
      const foliage = new THREE.Mesh(foliageGeo, foliageMat);
      foliage.position.y = 2.5;
      g.add(foliage);
      return g;
    }

    function createRock(color) {
      const geo = new THREE.DodecahedronGeometry(0.6 + Math.random() * 0.5, 0);
      const mat = new THREE.MeshLambertMaterial({ color, flatShading: true });
      const rock = new THREE.Mesh(geo, mat);
      rock.position.y = 0.4;
      rock.rotation.set(Math.random(), Math.random(), Math.random());
      return rock;
    }

    for (let i = 0; i < MAX_SCENERY; i++) {
      const side = i % 2 === 0 ? -1 : 1;
      const xOff = ROAD_WIDTH / 2 + 3 + Math.random() * 15;
      const colors = env.sceneryColors;
      const color = colors[i % colors.length];
      const obj = i % 3 === 0 ? createRock(color) : createTree(color);
      obj.position.x = side * xOff;
      obj.position.z = i * 6;
      obj.userData = { baseZ: i * 6, side, xOff };
      sceneryPool.push(obj);
      sceneryGroup.add(obj);
    }
    scene.add(sceneryGroup);

    // ===== OBSTACLE POOL =====
    const obstacleGroup = new THREE.Group();

    function createObstacleMesh(type) {
      const g = new THREE.Group();
      const mat = new THREE.MeshLambertMaterial({ color: type.color, flatShading: true });

      if (type.name === 'rock') {
        const geo = new THREE.DodecahedronGeometry(0.5, 0);
        const m = new THREE.Mesh(geo, mat);
        m.position.y = 0.4;
        g.add(m);
      } else if (type.name === 'tree') {
        const tGeo = new THREE.CylinderGeometry(0.1, 0.15, 0.8, 5);
        const trunk = new THREE.Mesh(tGeo, new THREE.MeshLambertMaterial({ color: 0x8B4513, flatShading: true }));
        trunk.position.y = 0.4;
        g.add(trunk);
        const fGeo = new THREE.ConeGeometry(0.6, 1.2, 5);
        const fol = new THREE.Mesh(fGeo, mat);
        fol.position.y = 1.2;
        g.add(fol);
      } else if (type.name === 'water') {
        const geo = new THREE.PlaneGeometry(1.5, 1.5);
        const m = new THREE.Mesh(geo, new THREE.MeshLambertMaterial({ color: type.color, transparent: true, opacity: 0.7 }));
        m.rotation.x = -Math.PI / 2;
        m.position.y = 0.05;
        g.add(m);
      } else if (type.name === 'wall') {
        const geo = new THREE.BoxGeometry(1.8, 1.2, 0.4);
        const m = new THREE.Mesh(geo, mat);
        m.position.y = 0.6;
        g.add(m);
      } else if (type.name === 'fire') {
        // Fire: orange cone + red cone
        const geo1 = new THREE.ConeGeometry(0.3, 1.0, 5);
        const m1 = new THREE.Mesh(geo1, new THREE.MeshBasicMaterial({ color: 0xff4400 }));
        m1.position.y = 0.5;
        g.add(m1);
        const geo2 = new THREE.ConeGeometry(0.2, 0.6, 5);
        const m2 = new THREE.Mesh(geo2, new THREE.MeshBasicMaterial({ color: 0xffaa00 }));
        m2.position.y = 0.7;
        g.add(m2);
      } else if (type.name === 'bomb') {
        const geo = new THREE.SphereGeometry(0.35, 6, 4);
        const m = new THREE.Mesh(geo, mat);
        m.position.y = 0.35;
        g.add(m);
        // Fuse
        const fGeo = new THREE.CylinderGeometry(0.03, 0.03, 0.3, 4);
        const fuse = new THREE.Mesh(fGeo, new THREE.MeshBasicMaterial({ color: 0x888888 }));
        fuse.position.set(0, 0.65, 0);
        fuse.rotation.z = 0.3;
        g.add(fuse);
      }

      g.visible = false;
      obstacleGroup.add(g);
      return g;
    }

    // Pre-create obstacle meshes
    for (let i = 0; i < MAX_VISIBLE_OBSTACLES; i++) {
      const type = OBSTACLE_TYPES[i % OBSTACLE_TYPES.length];
      obstaclePool.push({ mesh: createObstacleMesh(type), type, inUse: false });
    }
    scene.add(obstacleGroup);

    // ===== ACTIVE OBSTACLES (logical) =====
    const activeObstacles = []; // { tile, lane, typeIndex, poolIndex }

    // ===== POWER-UP MESHES =====
    const powerupGroup = new THREE.Group();
    function createPowerupMesh(type) {
      const g = new THREE.Group();
      // Glowing gem shape
      const gemGeo = new THREE.OctahedronGeometry(0.4, 0);
      const gemMat = new THREE.MeshBasicMaterial({ color: type.color, transparent: true, opacity: 0.9 });
      const gem = new THREE.Mesh(gemGeo, gemMat);
      gem.position.y = 0.8;
      g.add(gem);
      // Outer glow ring
      const ringGeo = new THREE.TorusGeometry(0.5, 0.06, 6, 12);
      const ringMat = new THREE.MeshBasicMaterial({ color: type.color, transparent: true, opacity: 0.5 });
      const ring = new THREE.Mesh(ringGeo, ringMat);
      ring.position.y = 0.8;
      ring.rotation.x = Math.PI / 2;
      g.add(ring);
      g.visible = false;
      g.userData = { gem, ring };
      powerupGroup.add(g);
      return g;
    }
    for (let i = 0; i < MAX_POWERUPS; i++) {
      const type = POWERUP_TYPES[i % POWERUP_TYPES.length];
      powerupMeshPool.push({ mesh: createPowerupMesh(type), typeIndex: i % POWERUP_TYPES.length, inUse: false });
    }
    scene.add(powerupGroup);

    function generatePowerups(upToTile) {
      while (lastPowerupTile < upToTile) {
        lastPowerupTile += 8 + Math.floor(Math.random() * 12); // every 8-20 tiles
        if (lastPowerupTile < 10) continue;
        const lane = Math.floor(Math.random() * LANE_COUNT);
        const typeIdx = Math.floor(Math.random() * ROAD_POWERUP_COUNT); // only road-pickup types
        activePowerups.push({ tile: lastPowerupTile, lane, typeIndex: typeIdx, poolIndex: -1 });
      }
    }

    function updatePowerups(cameraZ, now) {
      // Remove passed powerups
      for (let i = activePowerups.length - 1; i >= 0; i--) {
        const pu = activePowerups[i];
        if (pu.tile * TILE < cameraZ - 20) {
          if (pu.poolIndex >= 0) {
            powerupMeshPool[pu.poolIndex].mesh.visible = false;
            powerupMeshPool[pu.poolIndex].inUse = false;
          }
          activePowerups.splice(i, 1);
        }
      }
      // Assign meshes and animate
      for (const pu of activePowerups) {
        const worldZ = pu.tile * TILE;
        if (worldZ < cameraZ - 10 || worldZ > cameraZ + FOG_FAR) continue;
        if (pu.poolIndex < 0) {
          const slot = powerupMeshPool.findIndex(p => !p.inUse);
          if (slot < 0) continue;
          pu.poolIndex = slot;
          powerupMeshPool[slot].inUse = true;
          powerupMeshPool[slot].typeIndex = pu.typeIndex;
        }
        const pm = powerupMeshPool[pu.poolIndex];
        pm.mesh.visible = true;
        pm.mesh.position.x = getLaneX(pu.lane);
        pm.mesh.position.z = worldZ;
        // Floating bob + spin
        const ud = pm.mesh.userData;
        ud.gem.rotation.y = now * 0.003;
        ud.gem.position.y = 0.8 + Math.sin(now * 0.004 + pu.tile) * 0.2;
        ud.ring.rotation.z = now * 0.002;
        ud.ring.position.y = ud.gem.position.y;
      }
    }

    function checkPowerupPickup(now) {
      players.forEach(p => {
        if (p.isStunned) return;
        for (let i = activePowerups.length - 1; i >= 0; i--) {
          const pu = activePowerups[i];
          if (Math.abs(pu.tile - p.tilePos) < 0.8 && pu.lane === p.lane) {
            const type = POWERUP_TYPES[pu.typeIndex];
            // Store in inventory (max 3)
            if (p.inventory.length < MAX_INVENTORY) {
              p.inventory.push(pu.typeIndex);
              sfxPowerup();
              spawnGiftParticles(p.mesh.position.x, p.mesh.position.y, p.mesh.position.z, type.color, 15);
              showNotif(`<strong>${p.nickname}</strong> picked up ${type.icon} ${type.name}!`);
              updateInventorySprite(p);
            }
            // Remove powerup from road
            if (pu.poolIndex >= 0) {
              powerupMeshPool[pu.poolIndex].mesh.visible = false;
              powerupMeshPool[pu.poolIndex].inUse = false;
            }
            activePowerups.splice(i, 1);
            break;
          }
        }
      });
    }

    // Use a power from inventory
    function usePower(p, slotIndex, now) {
      if (slotIndex >= p.inventory.length) return;
      const typeIdx = p.inventory[slotIndex];
      const type = POWERUP_TYPES[typeIdx];
      p.inventory.splice(slotIndex, 1);
      updateInventorySprite(p);
      activatePower(p, type, now);
    }

    // Activate a power effect (works for both inventory and gift-given powers)
    function activatePower(p, type, now) {
      sfxPowerup();
      spawnGiftParticles(p.mesh.position.x, p.mesh.position.y, p.mesh.position.z, type.color, 25);

      const notifEl = document.getElementById('powerupNotif');
      notifEl.textContent = `${type.icon} ${p.nickname}: ${type.name}!`;
      notifEl.classList.remove('show');
      void notifEl.offsetWidth;
      notifEl.classList.add('show');

      if (type.effect === 'speed') {
        p.targetTile += 5;
        showNotif(`<strong>${p.nickname}</strong> ${type.icon} Speed Boost! +5 tiles!`, 'gift');
      } else if (type.effect === 'shield') {
        p.hasShield = true;
        showNotif(`<strong>${p.nickname}</strong> ${type.icon} Shield activated!`);
      } else if (type.effect === 'lightning') {
        let target = null, minDist = Infinity;
        players.forEach(other => {
          if (other.id === p.id || other.isStunned) return;
          const dist = Math.abs(other.tilePos - p.tilePos);
          if (dist < 15 && dist < minDist) { minDist = dist; target = other; }
        });
        if (target) {
          target.isStunned = true;
          target.stunStart = now;
          spawnStunParticles(target.mesh.position.x, target.mesh.position.y, target.mesh.position.z);
          sfxHit();
          showNotif(`<strong>${p.nickname}</strong> ${type.icon} zapped <strong>${target.nickname}</strong>!`, 'gift');
        } else {
          p.targetTile += 3;
          showNotif(`<strong>${p.nickname}</strong> ${type.icon} No target, +3 tiles!`, 'gift');
        }
      } else if (type.effect === 'magnet') {
        const ahead = activeObstacles.filter(o => o.tile > p.tilePos && o.tile < p.tilePos + 10);
        const blocked = new Set(ahead.map(o => o.lane));
        let bestLane = p.lane;
        for (let l = 0; l < LANE_COUNT; l++) {
          if (!blocked.has(l)) { bestLane = l; break; }
        }
        p.lane = bestLane;
        p.targetTile += 2;
        showNotif(`<strong>${p.nickname}</strong> ${type.icon} Magnet! Safe lane +2!`, 'gift');
      } else if (type.effect === 'kick') {
        // Mega Kick: send nearest player back 15 tiles!
        let target = null, minDist = Infinity;
        players.forEach(other => {
          if (other.id === p.id || other.isStunned) return;
          const dist = Math.abs(other.tilePos - p.tilePos);
          if (dist < 20 && dist < minDist) { minDist = dist; target = other; }
        });
        if (target) {
          target.targetTile = Math.max(0, target.tilePos - 15);
          target.tilePos = target.targetTile;
          target.isStunned = true;
          target.stunStart = now;
          spawnStunParticles(target.mesh.position.x, target.mesh.position.y, target.mesh.position.z);
          triggerGiftFlash('#ff2222');
          sfxHit();
          showNotif(`<strong>${p.nickname}</strong> ${type.icon} KICKED <strong>${target.nickname}</strong> back 15 tiles!`, 'gift');
        } else {
          p.targetTile += 5;
          showNotif(`<strong>${p.nickname}</strong> ${type.icon} No target! +5 tiles instead!`, 'gift');
        }
      } else if (type.effect === 'pushout') {
        // Push Out: push nearest player to random lane + stun 3s
        let target = null, minDist = Infinity;
        players.forEach(other => {
          if (other.id === p.id || other.isStunned) return;
          const dist = Math.abs(other.tilePos - p.tilePos);
          if (dist < 15 && dist < minDist) { minDist = dist; target = other; }
        });
        if (target) {
          // Push to a different lane
          let newLane;
          do { newLane = Math.floor(Math.random() * LANE_COUNT); } while (newLane === target.lane);
          target.lane = newLane;
          target.isStunned = true;
          target.stunStart = now - (STUN_DURATION - 3000); // 3 second stun
          spawnStunParticles(target.mesh.position.x, target.mesh.position.y, target.mesh.position.z);
          triggerGiftFlash('#ff8800');
          sfxHit();
          showNotif(`<strong>${p.nickname}</strong> ${type.icon} PUSHED <strong>${target.nickname}</strong> off-lane!`, 'gift');
        } else {
          p.targetTile += 3;
          showNotif(`<strong>${p.nickname}</strong> ${type.icon} No target! +3 tiles instead!`, 'gift');
        }
      }
    }

    // Visual inventory indicator floating beside character
    function updateInventorySprite(p) {
      const ud = p.mesh.userData;
      // Remove old inventory sprites
      if (ud.inventorySprites) {
        ud.inventorySprites.forEach(s => p.mesh.remove(s));
        ud.inventorySprites = null;
      }
      if (p.inventory.length === 0) return;

      ud.inventorySprites = [];
      p.inventory.forEach((typeIdx, i) => {
        const type = POWERUP_TYPES[typeIdx];
        const c = document.createElement('canvas');
        c.width = 128;
        c.height = 128;
        const ctx = c.getContext('2d');

        // Glowing background circle
        const gradient = ctx.createRadialGradient(64, 64, 20, 64, 64, 60);
        const hex = '#' + type.color.toString(16).padStart(6, '0');
        gradient.addColorStop(0, hex + 'ee');
        gradient.addColorStop(0.6, hex + '88');
        gradient.addColorStop(1, hex + '00');
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(64, 64, 58, 0, Math.PI * 2);
        ctx.fill();

        // Inner solid circle
        ctx.fillStyle = hex + 'cc';
        ctx.beginPath();
        ctx.arc(64, 64, 38, 0, Math.PI * 2);
        ctx.fill();

        // White border ring
        ctx.strokeStyle = '#ffffffdd';
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.arc(64, 64, 38, 0, Math.PI * 2);
        ctx.stroke();

        // Emoji icon (large)
        ctx.font = '40px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(type.icon, 64, 64);

        const tex = new THREE.CanvasTexture(c);
        const mat = new THREE.SpriteMaterial({ map: tex, transparent: true, depthWrite: false });
        const sprite = new THREE.Sprite(mat);
        sprite.scale.set(0.7, 0.7, 1);
        // Float to the right side of character, stacked vertically
        sprite.position.set(0.9, 0.8 + i * 0.75, 0);
        sprite.userData = { bobOffset: i * 1.2 }; // for floating animation
        p.mesh.add(sprite);
        ud.inventorySprites.push(sprite);
      });
    }

    // Animate inventory icons (gentle bob)
    function animateInventory(p, now) {
      const ud = p.mesh.userData;
      if (!ud.inventorySprites) return;
      ud.inventorySprites.forEach((sprite, i) => {
        const bob = Math.sin(now * 0.003 + sprite.userData.bobOffset) * 0.1;
        sprite.position.y = 0.8 + i * 0.75 + bob;
      });
    }

    // ===== CHARACTER FACTORY =====
    const playersGroup = new THREE.Group();
    scene.add(playersGroup);

    function hashColor(id) {
      let hash = 0;
      for (let i = 0; i < id.length; i++) hash = ((hash << 5) - hash + id.charCodeAt(i)) | 0;
      return PLAYER_COLORS[Math.abs(hash) % PLAYER_COLORS.length];
    }

    function createNameSprite(name) {
      const c = document.createElement('canvas');
      c.width = 256;
      c.height = 64;
      const ctx = c.getContext('2d');
      ctx.fillStyle = 'rgba(0,0,0,0.6)';
      ctx.roundRect(4, 4, 248, 56, 12);
      ctx.fill();
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 28px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      const display = name.length > 12 ? name.slice(0, 11) + '..' : name;
      ctx.fillText(display, 128, 32);

      const tex = new THREE.CanvasTexture(c);
      const mat = new THREE.SpriteMaterial({ map: tex, transparent: true, depthWrite: false });
      const sprite = new THREE.Sprite(mat);
      sprite.scale.set(2.5, 0.65, 1);
      return sprite;
    }

    // Create a profile photo sprite (circular, facing camera)
    function createProfileSprite(color) {
      // Start with a colored circle placeholder
      const c = document.createElement('canvas');
      c.width = 128;
      c.height = 128;
      const ctx = c.getContext('2d');

      // Circular clip
      ctx.beginPath();
      ctx.arc(64, 64, 60, 0, Math.PI * 2);
      ctx.closePath();
      ctx.fillStyle = '#' + color.toString(16).padStart(6, '0');
      ctx.fill();

      // Border
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 4;
      ctx.stroke();

      // Default face icon
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 48px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('üòä', 64, 64);

      const tex = new THREE.CanvasTexture(c);
      const mat = new THREE.SpriteMaterial({ map: tex, transparent: true, depthWrite: false });
      const sprite = new THREE.Sprite(mat);
      sprite.scale.set(0.7, 0.7, 1);
      sprite.userData = { canvas: c, texture: tex };
      return sprite;
    }

    // Load actual profile photo into the sprite
    function loadProfilePhoto(sprite, profilePicUrl) {
      if (!profilePicUrl) return;
      const proxyUrl = `/api/proxy-image?url=${encodeURIComponent(profilePicUrl)}`;
      const img = new Image();
      img.crossOrigin = 'anonymous';
      img.onload = () => {
        const c = sprite.userData.canvas;
        const ctx = c.getContext('2d');
        ctx.clearRect(0, 0, 128, 128);

        // Circular clip
        ctx.save();
        ctx.beginPath();
        ctx.arc(64, 64, 60, 0, Math.PI * 2);
        ctx.closePath();
        ctx.clip();

        // Draw profile pic
        const size = Math.min(img.width, img.height);
        const sx = (img.width - size) / 2;
        const sy = (img.height - size) / 2;
        ctx.drawImage(img, sx, sy, size, size, 4, 4, 120, 120);
        ctx.restore();

        // White border
        ctx.beginPath();
        ctx.arc(64, 64, 60, 0, Math.PI * 2);
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 4;
        ctx.stroke();

        sprite.userData.texture.needsUpdate = true;
      };
      img.onerror = () => {}; // Keep placeholder on error
      img.src = proxyUrl;
    }

    // Create chat bubble sprite
    function createChatBubble(text) {
      const c = document.createElement('canvas');
      c.width = 512;
      c.height = 128;
      const ctx = c.getContext('2d');

      const displayText = text.length > 25 ? text.slice(0, 24) + '..' : text;
      ctx.font = 'bold 26px sans-serif';
      const textWidth = Math.min(ctx.measureText(displayText).width + 40, 500);

      // Bubble background
      const bx = (512 - textWidth) / 2;
      ctx.fillStyle = 'rgba(255,255,255,0.95)';
      ctx.beginPath();
      ctx.roundRect(bx, 10, textWidth, 70, 16);
      ctx.fill();
      ctx.strokeStyle = 'rgba(0,0,0,0.15)';
      ctx.lineWidth = 2;
      ctx.stroke();

      // Tail triangle
      ctx.fillStyle = 'rgba(255,255,255,0.95)';
      ctx.beginPath();
      ctx.moveTo(246, 80);
      ctx.lineTo(256, 100);
      ctx.lineTo(266, 80);
      ctx.fill();

      // Text
      ctx.fillStyle = '#222';
      ctx.font = 'bold 26px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(displayText, 256, 46);

      const tex = new THREE.CanvasTexture(c);
      const mat = new THREE.SpriteMaterial({ map: tex, transparent: true, depthWrite: false });
      const sprite = new THREE.Sprite(mat);
      sprite.scale.set(3.5, 0.9, 1);
      return sprite;
    }

    function createCharacter(id, name, profilePic) {
      const color = hashColor(id);
      const mat = new THREE.MeshLambertMaterial({ color, flatShading: true });
      const skinMat = new THREE.MeshLambertMaterial({ color: 0xffcc99, flatShading: true });

      const group = new THREE.Group();

      // Body
      const bodyGeo = new THREE.BoxGeometry(0.6, 0.8, 0.4);
      const body = new THREE.Mesh(bodyGeo, mat);
      body.position.y = 1.2;
      group.add(body);

      // Head (small sphere, mostly hidden behind profile sprite)
      const headGeo = new THREE.SphereGeometry(0.25, 8, 6);
      const head = new THREE.Mesh(headGeo, skinMat);
      head.position.y = 1.9;
      group.add(head);

      // Profile photo sprite on top of head (faces camera automatically)
      const profileSprite = createProfileSprite(color);
      profileSprite.position.y = 1.9;
      profileSprite.position.z = -0.05; // slightly behind center
      group.add(profileSprite);

      // Load actual profile photo if available
      if (profilePic) {
        loadProfilePhoto(profileSprite, profilePic);
      }

      // Arms
      const armGeo = new THREE.CylinderGeometry(0.08, 0.08, 0.5, 5);
      const leftArm = new THREE.Mesh(armGeo, mat);
      leftArm.position.set(-0.4, 1.1, 0);
      group.add(leftArm);
      const rightArm = new THREE.Mesh(armGeo.clone(), mat);
      rightArm.position.set(0.4, 1.1, 0);
      group.add(rightArm);

      // Legs
      const legGeo = new THREE.CylinderGeometry(0.09, 0.09, 0.5, 5);
      const leftLeg = new THREE.Mesh(legGeo, mat);
      leftLeg.position.set(-0.13, 0.45, 0);
      group.add(leftLeg);
      const rightLeg = new THREE.Mesh(legGeo.clone(), mat);
      rightLeg.position.set(0.13, 0.45, 0);
      group.add(rightLeg);

      // Name label
      const nameSprite = createNameSprite(name);
      nameSprite.position.y = 2.5;
      group.add(nameSprite);

      group.userData = {
        leftArm, rightArm, leftLeg, rightLeg, body, head,
        profileSprite,
        chatBubble: null,
        chatTimer: null,
        animPhase: Math.random() * Math.PI * 2
      };

      return group;
    }

    // ===== PLAYER MANAGEMENT =====
    function addPlayer(data) {
      const id = (data.id || data.uniqueId || '').toString();
      if (!id) return null;

      let p = players.get(id);
      if (p) {
        // Update profile pic if we didn't have one before
        if (data.profilePic && !p.hasProfilePic) {
          loadProfilePhoto(p.mesh.userData.profileSprite, data.profilePic);
          p.hasProfilePic = true;
        }
        return p;
      }

      const mesh = createCharacter(id, data.nickname || data.uniqueId || 'Viewer', data.profilePic || '');
      // Place at the back of the pack (slightly behind everyone)
      let backPos = 0;
      players.forEach(pp => { if (pp.tilePos < backPos) backPos = pp.tilePos; });
      const startTile = Math.max(0, backPos);

      const lane = Math.floor(Math.random() * LANE_COUNT);
      mesh.position.x = getLaneX(lane);
      mesh.position.z = startTile * TILE;

      playersGroup.add(mesh);

      p = {
        id,
        nickname: data.nickname || data.uniqueId || 'Viewer',
        mesh,
        tilePos: startTile,
        targetTile: startTile,
        lane,
        isJumping: false,
        jumpStart: 0,
        isStunned: false,
        stunStart: 0,
        totalDiamonds: 0,
        hasShield: false,
        inventory: [], // power-up type indices, max 3
        isPushedOut: false,
        hasProfilePic: !!data.profilePic,
      };
      players.set(id, p);
      updateHUD();
      return p;
    }

    function getLaneX(lane) {
      return -ROAD_WIDTH / 2 + LANE_WIDTH / 2 + lane * LANE_WIDTH;
    }

    // ===== OBSTACLE GENERATION =====
    function generateObstacles(upToTile) {
      while (lastObstacleTile < upToTile) {
        lastObstacleTile += 3 + Math.floor(Math.random() * 4); // every 3-6 tiles
        if (Math.random() > OBSTACLE_CHANCE) continue;
        if (lastObstacleTile < 5) continue; // safe zone at start

        // Pick 1-3 lanes to block (never all 5)
        const blockedCount = 1 + Math.floor(Math.random() * 2);
        const lanes = [];
        while (lanes.length < blockedCount) {
          const l = Math.floor(Math.random() * LANE_COUNT);
          if (!lanes.includes(l)) lanes.push(l);
        }

        const typeIdx = Math.floor(Math.random() * OBSTACLE_TYPES.length);
        for (const lane of lanes) {
          activeObstacles.push({ tile: lastObstacleTile, lane, typeIndex: typeIdx, poolIndex: -1 });
        }
      }
    }

    function updateObstacles(cameraZ) {
      // Remove obstacles far behind camera
      for (let i = activeObstacles.length - 1; i >= 0; i--) {
        const obs = activeObstacles[i];
        const worldZ = obs.tile * TILE;
        if (worldZ < cameraZ - 20) {
          // Return pool mesh
          if (obs.poolIndex >= 0 && obstaclePool[obs.poolIndex]) {
            obstaclePool[obs.poolIndex].mesh.visible = false;
            obstaclePool[obs.poolIndex].inUse = false;
          }
          activeObstacles.splice(i, 1);
        }
      }

      // Assign pool meshes to visible obstacles
      for (const obs of activeObstacles) {
        const worldZ = obs.tile * TILE;
        if (worldZ < cameraZ - 10 || worldZ > cameraZ + FOG_FAR) continue;

        if (obs.poolIndex < 0) {
          // Find free pool slot
          const slot = obstaclePool.findIndex(p => !p.inUse);
          if (slot < 0) continue;
          obs.poolIndex = slot;
          obstaclePool[slot].inUse = true;
        }

        const pm = obstaclePool[obs.poolIndex];
        pm.mesh.visible = true;
        pm.mesh.position.x = getLaneX(obs.lane);
        pm.mesh.position.z = worldZ;
        pm.mesh.position.y = 0;
      }
    }

    // ===== COLLISION DETECTION =====
    function checkCollisions(now) {
      players.forEach(p => {
        if (p.isStunned || p.isJumping) return;

        const pz = p.tilePos;
        for (const obs of activeObstacles) {
          if (Math.abs(obs.tile - pz) < 0.8 && obs.lane === p.lane) {
            if (p.hasShield) {
              // Shield absorbs the hit
              p.hasShield = false;
              spawnGiftParticles(p.mesh.position.x, p.mesh.position.y, p.mesh.position.z, 0x44aaff, 15);
              sfxPowerup();
              showNotif(`${p.nickname}'s shield blocked the ${OBSTACLE_TYPES[obs.typeIndex].name}!`);
              break;
            }
            // Hit!
            p.isStunned = true;
            p.stunStart = now;
            spawnStunParticles(p.mesh.position.x, p.mesh.position.y, p.mesh.position.z);
            sfxHit();
            p.tilePos = Math.max(0, p.tilePos - 2); // pushback
            p.targetTile = p.tilePos;
            showNotif(`${p.nickname} hit a ${OBSTACLE_TYPES[obs.typeIndex].name}!`);
            break;
          }
        }
      });
    }

    // ===== ENVIRONMENT SWITCHING =====
    function getLeaderTile() {
      let max = 0;
      players.forEach(p => { if (p.tilePos > max) max = p.tilePos; });
      return max;
    }

    function applyEnvironment(idx) {
      envIndex = idx % ENVIRONMENTS.length;
      const e = ENVIRONMENTS[envIndex];
      scene.background.set(e.sky);
      scene.fog.color.set(e.fog);
      scene.fog.near = FOG_NEAR;
      scene.fog.far = FOG_FAR;
      sunMesh.material.color.set(e.sun);
      terrainMat.color.set(e.ground);
      terrainMatAlt.color.set(e.groundAlt);
      roadMat.color.set(e.road);
      roadMatAlt.color.set(e.roadAlt);
      rumbleMat.color.set(e.rumble);
      rumbleMatAlt.color.set(e.rumbleAlt);
      mtMat.color.set(e.mountain);
      document.getElementById('envBadge').textContent = e.name;
    }

    function checkEnvironmentChange() {
      const leader = getLeaderTile();
      const expectedEnv = Math.floor(leader / ENV_INTERVAL) % ENVIRONMENTS.length;
      if (expectedEnv !== envIndex) {
        applyEnvironment(expectedEnv);
      }
    }

    window.nextEnvironment = function() {
      applyEnvironment(envIndex + 1);
    };

    // ===== ANIMATION =====
    function animateCharacter(p, now, dt) {
      const ud = p.mesh.userData;
      const isMoving = Math.abs(p.targetTile - p.tilePos) > 0.1;

      // Run animation
      if (isMoving || p.isJumping) {
        ud.animPhase += dt * 8;
        const swing = Math.sin(ud.animPhase) * 0.6;
        ud.leftArm.rotation.x = swing;
        ud.rightArm.rotation.x = -swing;
        ud.leftLeg.rotation.x = -swing;
        ud.rightLeg.rotation.x = swing;
      } else {
        // Idle breathing
        ud.animPhase += dt * 1.5;
        const idle = Math.sin(ud.animPhase) * 0.05;
        ud.leftArm.rotation.x = idle;
        ud.rightArm.rotation.x = -idle;
        ud.leftLeg.rotation.x = 0;
        ud.rightLeg.rotation.x = 0;
      }

      // Jump arc
      if (p.isJumping) {
        const elapsed = now - p.jumpStart;
        if (elapsed >= JUMP_DURATION) {
          p.isJumping = false;
          p.mesh.position.y = 0;
        } else {
          const t = elapsed / JUMP_DURATION;
          p.mesh.position.y = Math.sin(t * Math.PI) * 2.5;
        }
      }

      // Stun wobble
      if (p.isStunned) {
        const elapsed = now - p.stunStart;
        if (elapsed >= STUN_DURATION) {
          p.isStunned = false;
          p.mesh.rotation.z = 0;
          // Switch lane randomly on recovery
          p.lane = Math.floor(Math.random() * LANE_COUNT);
        } else {
          p.mesh.rotation.z = Math.sin(elapsed * 0.02) * 0.3;
          // Flash effect
          const flash = Math.sin(elapsed * 0.015) > 0;
          ud.body.visible = flash;
        }
      } else {
        ud.body.visible = true;
        p.mesh.rotation.z = 0;
      }

      // Chat bubble float animation
      if (ud.chatBubble) {
        ud.chatBubble.position.y = 3.2 + Math.sin(now * 0.003) * 0.1;
      }

      // Smooth movement toward target position
      const targetZ = p.targetTile * TILE;
      const targetX = getLaneX(p.lane);
      const prevZ = p.mesh.position.z;
      p.mesh.position.z += (targetZ - p.mesh.position.z) * Math.min(1, dt * 5);
      p.mesh.position.x += (targetX - p.mesh.position.x) * Math.min(1, dt * 8);

      // Trail effect when running
      const speed = Math.abs(p.mesh.position.z - prevZ);
      if (speed > 0.05 && !p.isStunned) {
        // Spawn trail particles behind the character
        if (Math.random() < Math.min(speed * 3, 0.8)) {
          const color = hashColor(p.id);
          spawnTrail(p.mesh.position.x, p.mesh.position.y, p.mesh.position.z - 0.5, color);
        }
      }

      // Animate floating inventory icons
      animateInventory(p, now);

      // Update logical tile position (for collision)
      p.tilePos += (p.targetTile - p.tilePos) * Math.min(1, dt * 5);
    }

    // ===== CAMERA =====
    function updateCamera(dt) {
      if (players.size === 0) return;

      // Find median runner position
      const positions = [];
      players.forEach(p => positions.push(p.tilePos));
      positions.sort((a, b) => a - b);
      const median = positions[Math.floor(positions.length / 2)] * TILE;

      // Target: look at median, positioned behind
      const targetZ = median - 12;
      const targetY = 8 + positions.length * 0.05; // rise slightly with more players

      camera.position.z += (targetZ - camera.position.z) * Math.min(1, dt * 2);
      camera.position.y += (targetY - camera.position.y) * Math.min(1, dt * 2);
      camera.lookAt(0, 1, camera.position.z + 25);

      cameraTargetZ = camera.position.z;
    }

    // ===== ROAD RECYCLING =====
    let nextChunkIndex = CHUNK_COUNT;

    function recycleRoads() {
      const camZ = camera.position.z;
      for (const chunk of roadChunks) {
        const chunkZ = chunk.position.z;
        if (chunkZ < camZ - CHUNK_LENGTH * 2) {
          chunk.position.z = nextChunkIndex * CHUNK_LENGTH + CHUNK_LENGTH / 2;
          chunk.userData.chunkIndex = nextChunkIndex;
          nextChunkIndex++;
        }
      }
    }

    // ===== SCENERY RECYCLING =====
    function recycleScenery() {
      const camZ = camera.position.z;
      for (const obj of sceneryPool) {
        if (obj.position.z < camZ - 30) {
          obj.position.z += MAX_SCENERY * 6;
          obj.userData.baseZ = obj.position.z;
        }
      }
    }

    // ===== TERRAIN FOLLOW =====
    function updateTerrain() {
      const camZ = camera.position.z;
      const tz = Math.floor(camZ / (CHUNK_LENGTH * CHUNK_COUNT)) * CHUNK_LENGTH * CHUNK_COUNT;
      leftTerrain.position.z = tz + CHUNK_LENGTH * CHUNK_COUNT / 2;
      rightTerrain.position.z = tz + CHUNK_LENGTH * CHUNK_COUNT / 2;

      // Mountains follow loosely
      mountainGroup.position.z = camZ * 0.8;
    }

    // ===== HUD =====
    function updateHUD() {
      document.getElementById('runnerCount').textContent = players.size;

      // Leader distance
      const leader = getLeaderTile();
      document.getElementById('leaderDist').textContent = Math.floor(leader * 2);

      // Podium
      const sorted = [...players.values()].sort((a, b) => b.tilePos - a.tilePos);
      const top3 = sorted.slice(0, 3);
      const medals = ['ü•á', 'ü•à', 'ü•â'];
      const podiumEl = document.getElementById('podiumList');
      podiumEl.innerHTML = top3.map((p, i) =>
        `<div class="podium-row">
          <span class="podium-medal">${medals[i]}</span>
          <span class="podium-name">${p.nickname}</span>
          <span class="podium-dist">${Math.floor(p.tilePos * 2)}m</span>
        </div>`
      ).join('');
    }

    function showNotif(html, cls = '') {
      const area = document.getElementById('notifArea');
      const div = document.createElement('div');
      div.className = `notif ${cls}`;
      div.innerHTML = html;
      area.appendChild(div);
      // Remove after animation
      setTimeout(() => div.remove(), 3500);
      // Keep max 6
      while (area.children.length > 6) area.firstChild.remove();
    }

    // ===== SOCKET.IO =====
    const socket = io();

    socket.on('viewer-join', (viewer) => {
      addPlayer(viewer);
      sfxJoin();
      showNotif(`<strong>${viewer.nickname}</strong> joined the marathon!`);
    });

    socket.on('viewer-list', (list) => {
      list.forEach(v => addPlayer(v));
    });

    socket.on('gift', (data) => {
      const p = addPlayer(data);
      if (!p) return;

      const diamonds = (data.diamondCount || 1) * (data.repeatCount || 1);
      p.totalDiamonds += diamonds;
      const now = Date.now();

      sfxGift(diamonds);
      const flashColors = ['#fe2c55', '#25f4ee', '#ffd700', '#ff6600', '#a855f7'];
      triggerGiftFlash(flashColors[Math.floor(Math.random() * flashColors.length)]);

      if (p.inventory.length > 0 && !p.isStunned) {
        // Use first power in inventory
        usePower(p, 0, now);
        showNotif(`<strong>${p.nickname}</strong> used a power! (${data.giftName} x${data.repeatCount || 1})`, 'gift');
      } else {
        // No inventory: gift gives a random gift-exclusive power (Kick or Push Out)
        const exclusiveIdx = ROAD_POWERUP_COUNT + Math.floor(Math.random() * (POWERUP_TYPES.length - ROAD_POWERUP_COUNT));
        const type = POWERUP_TYPES[exclusiveIdx];

        if (p.inventory.length < MAX_INVENTORY) {
          // Store in inventory for next gift use
          p.inventory.push(exclusiveIdx);
          updateInventorySprite(p);
          sfxPowerup();
          spawnGiftParticles(p.mesh.position.x, p.mesh.position.y, p.mesh.position.z, type.color, 20);
          showNotif(`<strong>${p.nickname}</strong> received ${type.icon} ${type.name}! (${data.giftName})`, 'gift');
        } else {
          // Inventory full ‚Äî activate immediately
          activatePower(p, type, now);
          showNotif(`<strong>${p.nickname}</strong> got ${type.icon} ${type.name}! (${data.giftName})`, 'gift');
        }
      }

      checkEnvironmentChange();
      updateHUD();
    });

    socket.on('like', (data) => {
      const p = addPlayer(data);
      if (!p || p.isStunned) return;

      // Like = Run forward 1 tile per tap
      const likes = data.likeCount || 1;
      const tiles = Math.min(likes, 5); // cap at 5 tiles per event
      p.targetTile += tiles;
      // Random lane switch occasionally
      if (Math.random() < 0.15) {
        p.lane = Math.floor(Math.random() * LANE_COUNT);
      }

      const pColor = hashColor(p.id);
      spawnTrail(p.mesh.position.x, p.mesh.position.y, p.mesh.position.z, pColor);
      checkEnvironmentChange();
      updateHUD();
    });

    socket.on('follow', (data) => {
      const p = addPlayer(data);
      if (!p) return;

      p.targetTile += 3;
      sfxFollow();
      spawnGiftParticles(p.mesh.position.x, p.mesh.position.y, p.mesh.position.z, 0x25f4ee, 20);
      triggerGiftFlash('#25f4ee');
      showNotif(`<strong>${p.nickname}</strong> followed! +3 boost!`, 'gift');
      updateHUD();
    });

    socket.on('room-stats', (data) => {
      // Could update viewer count separately if needed
    });

    socket.on('connection-status', () => {});

    socket.on('chat', (data) => {
      const p = addPlayer(data);
      if (!p) return;

      const ud = p.mesh.userData;
      const comment = (data.comment || '').trim().toLowerCase();
      const now = Date.now();

      // Parse commands from chat
      let isCommand = false;
      if (!p.isStunned) {
        if (comment === 'jump' || comment === 'j' || comment === 'lompat') {
          // Jump command
          if (!p.isJumping) {
            p.isJumping = true;
            p.jumpStart = now;
            p.targetTile += 0.5; // slight forward nudge
            sfxJump();
            spawnGiftParticles(p.mesh.position.x, p.mesh.position.y, p.mesh.position.z, 0xffee44, 6);
            isCommand = true;
          }
        } else if (comment === 'left' || comment === 'l' || comment === 'kiri') {
          // Move left
          if (p.lane > 0) {
            p.lane--;
            isCommand = true;
          }
        } else if (comment === 'right' || comment === 'r' || comment === 'kanan') {
          // Move right
          if (p.lane < LANE_COUNT - 1) {
            p.lane++;
            isCommand = true;
          }
        } else if (comment === 'use' || comment === 'power' || comment === 'guna') {
          // Use first power in inventory
          if (p.inventory.length > 0) {
            usePower(p, 0, now);
            isCommand = true;
          }
        }
      }

      // Show chat bubble for non-command messages (or all messages)
      // Remove old chat bubble
      if (ud.chatBubble) {
        p.mesh.remove(ud.chatBubble);
        ud.chatBubble = null;
      }
      if (ud.chatTimer) clearTimeout(ud.chatTimer);

      const displayComment = data.comment || '';
      if (displayComment && !isCommand) {
        const bubble = createChatBubble(displayComment);
        bubble.position.y = 3.2;
        p.mesh.add(bubble);
        ud.chatBubble = bubble;

        // Auto-remove after 4 seconds
        ud.chatTimer = setTimeout(() => {
          if (ud.chatBubble) {
            p.mesh.remove(ud.chatBubble);
            ud.chatBubble = null;
          }
        }, 4000);
      }
    });

    // ===== HOST CONTROLS =====
    window.toggleDemo = function() {
      demoActive = !demoActive;
      const btn = document.getElementById('btnDemo');
      if (demoActive) {
        socket.emit('start-demo');
        btn.classList.add('active');
        btn.textContent = 'Stop Demo';
      } else {
        socket.emit('stop-demo');
        btn.classList.remove('active');
        btn.textContent = 'Demo Mode';
        // Clear players
        players.forEach(p => playersGroup.remove(p.mesh));
        players.clear();
        activeObstacles.forEach(obs => {
          if (obs.poolIndex >= 0 && obstaclePool[obs.poolIndex]) {
            obstaclePool[obs.poolIndex].mesh.visible = false;
            obstaclePool[obs.poolIndex].inUse = false;
          }
        });
        activeObstacles.length = 0;
        activePowerups.forEach(pu => {
          if (pu.poolIndex >= 0) { powerupMeshPool[pu.poolIndex].mesh.visible = false; powerupMeshPool[pu.poolIndex].inUse = false; }
        });
        activePowerups.length = 0;
        lastObstacleTile = 0;
        lastPowerupTile = 10;
        updateHUD();
      }
    };

    window.showConnectModal = function() {
      document.getElementById('connectModal').classList.add('visible');
    };
    window.hideConnectModal = function() {
      document.getElementById('connectModal').classList.remove('visible');
    };
    window.connectTikTok = function() {
      const username = document.getElementById('tiktokUsername').value.trim().replace('@', '');
      if (username) {
        socket.emit('connect-tiktok', username);
        hideConnectModal();
        // Clear existing players
        players.forEach(p => playersGroup.remove(p.mesh));
        players.clear();
        activeObstacles.forEach(obs => {
          if (obs.poolIndex >= 0 && obstaclePool[obs.poolIndex]) {
            obstaclePool[obs.poolIndex].mesh.visible = false;
            obstaclePool[obs.poolIndex].inUse = false;
          }
        });
        activeObstacles.length = 0;
        activePowerups.forEach(pu => {
          if (pu.poolIndex >= 0) { powerupMeshPool[pu.poolIndex].mesh.visible = false; powerupMeshPool[pu.poolIndex].inUse = false; }
        });
        activePowerups.length = 0;
        lastObstacleTile = 0;
        lastPowerupTile = 10;
        demoActive = false;
        document.getElementById('btnDemo').classList.remove('active');
        document.getElementById('btnDemo').textContent = 'Demo Mode';
        updateHUD();
        showNotif(`Connecting to @${username}...`);
      }
    };

    // ===== RESIZE =====
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // ===== MAIN GAME LOOP =====
    let lastTime = 0;
    let hudTimer = 0;

    function gameLoop(time) {
      requestAnimationFrame(gameLoop);
      const dt = Math.min(0.1, (time - lastTime) / 1000);
      lastTime = time;
      const now = Date.now();

      // Generate obstacles and powerups ahead of leader
      const leaderTile = getLeaderTile();
      generateObstacles(leaderTile + 50);
      generatePowerups(leaderTile + 50);

      // Update obstacle and powerup visuals
      updateObstacles(camera.position.z);
      updatePowerups(camera.position.z, now);

      // Check collisions and pickups
      checkCollisions(now);
      checkPowerupPickup(now);

      // Animate characters
      players.forEach(p => animateCharacter(p, now, dt));

      // Offset overlapping name labels so they stack vertically
      const tileGroups = new Map();
      players.forEach(p => {
        const key = Math.round(p.tilePos * 2); // bucket by half-tile
        if (!tileGroups.has(key)) tileGroups.set(key, []);
        tileGroups.get(key).push(p);
      });
      tileGroups.forEach(group => {
        if (group.length <= 1) {
          // Reset to default
          if (group[0]) {
            const ns = group[0].mesh.children.find(c => c.isSprite && c.scale.x > 2);
            if (ns) ns.position.y = 2.5;
          }
          return;
        }
        // Stack names vertically
        group.forEach((p, i) => {
          const ns = p.mesh.children.find(c => c.isSprite && c.scale.x > 2);
          if (ns) ns.position.y = 2.5 + i * 0.7;
        });
      });

      // Auto-nudge stragglers: keep everyone visible within camera range
      if (players.size > 1) {
        const leaderPos = getLeaderTile();
        const minVisible = leaderPos - 25; // max 25 tiles behind leader
        players.forEach(p => {
          if (p.tilePos < minVisible && !p.isStunned) {
            // Gently push forward so they stay in frame
            const nudge = (minVisible - p.tilePos) * 0.05; // gradual catch-up
            p.targetTile += Math.max(0.1, nudge);
            p.tilePos += Math.max(0.05, nudge * 0.5);
          }
        });
      }

      // Camera
      updateCamera(dt);

      // Recycle chunks and scenery
      recycleRoads();
      recycleScenery();
      updateTerrain();

      // Update particles and trails
      updateParticles(dt);
      updateTrails(dt);

      // Animate clouds
      cloudGroup.children.forEach((c, i) => {
        c.position.x += dt * (0.5 + i * 0.1);
        if (c.position.x > 100) c.position.x = -100;
      });

      // Animate fire obstacles
      for (const obs of activeObstacles) {
        if (obs.poolIndex >= 0 && obstaclePool[obs.poolIndex]) {
          const pm = obstaclePool[obs.poolIndex];
          if (OBSTACLE_TYPES[obs.typeIndex].name === 'fire') {
            pm.mesh.rotation.y = time * 0.003;
            pm.mesh.children.forEach(c => {
              c.scale.y = 1 + Math.sin(time * 0.01 + obs.tile) * 0.2;
            });
          }
          if (OBSTACLE_TYPES[obs.typeIndex].name === 'bomb') {
            pm.mesh.scale.setScalar(1 + Math.sin(time * 0.008) * 0.05);
          }
        }
      }

      // Update HUD periodically
      hudTimer += dt;
      if (hudTimer > 0.5) {
        hudTimer = 0;
        updateHUD();
      }

      renderer.render(scene, camera);
    }

    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>
